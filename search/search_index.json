{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Go Tutorial \u00b6 English | T\u00fcrk\u00e7e This page contains educational material that includes the use of data structures in Go and principles about concurrent programming. Topics \u00b6 Data Structures Array, Slice, Map, Struct, Interface, Error, other common data structures and their usages. Concurrency The use of concurrency patterns in go.","title":"Home"},{"location":"#go-tutorial","text":"English | T\u00fcrk\u00e7e This page contains educational material that includes the use of data structures in Go and principles about concurrent programming.","title":"Go Tutorial"},{"location":"#topics","text":"Data Structures Array, Slice, Map, Struct, Interface, Error, other common data structures and their usages. Concurrency The use of concurrency patterns in go.","title":"Topics"},{"location":"concurrency/","text":"Concurrency \u00b6 English | T\u00fcrk\u00e7e In computer science, concurrency is the ability to run workpieces sequentially in a way that does not affect the final result. The ability to run the workpieces independently allows us to use the processor at maximum efficiency by executing the instructions in different cores. Goroutines \u00b6 Goroutines are functions in a task queue that waits to be executed by a system thread. To create a goroutine, we only need to write go when running the function. In the application below, every time the Work function is called it blocks the application until it is finished. func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { Work ( \"work work work work work work...\" ) Work ( \"zxcasfv\" ) } Let's run the blocking parts as goroutine. func main () { go Work ( \"work work work work work work...\" ) go Work ( \"zxcasfv\" ) } When we run the program, it will end without printing anything on the screen. This is because after the function main finishes the program exits without waiting Work function to write on the screen. We can capture the output of Work function by adding a small delay at the end of the main function, package main import ( \"fmt\" \"time\" ) func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { go Work ( \"work work work work work work...\" ) go Work ( \"zxcasfv\" ) time . Sleep ( time . Second * 3 ) } WaitGroup \u00b6 In some cases, we may need the to wait for a number of goroutines to finish at a certain moment of the runtime. With WaitGroup, we can specify the number of goroutines we want wait for and after the individual goroutine finishes its job it can call WaitGroup's Done() method to notify the waitgroup. func Work ( msg string , wg * sync . WaitGroup ) { time . Sleep ( time . Second * 2 ) fmt . Println ( msg ) wg . Done () } func main () { nWorkers := 5 wg := & sync . WaitGroup {} wg . Add ( nWorkers ) for i := 0 ; i < nWorkers ; i ++ { go Work ( \"work\" , wg ) } wg . Wait () } Channels \u00b6 Channels allows us to communicate goroutines with each other. In the above example, we cannot get the return value from the functions if we run them as goroutines. We can create a channel to send the result of a goroutine to the main function or to anoter goroutine. Channels can be created as make(chan data_type, buffer) . We can send data to channel using the channel <- data and wait data from channel using the data := <- channel signature. Both these operations block the runtime until they finish. func Work ( msg string , ch chan string ) { time . Sleep ( time . Second * 2 ) ch <- msg } func main () { channel := make ( chan string ) go Work ( \"work-1\" , channel ) go Work ( \"work-2\" , channel ) for i := 0 ; i < 2 ; i ++ { msg := <- channel fmt . Println ( msg ) } } Mutex \u00b6 Mutexes are the concurrency primitives that allow goroutines to change the value of a shared variable without causing a race condition. Wikipedia Definition In computer science, mutual exclusion is a property of concurrency control, which is instituted for the purpose of preventing race conditions. It is the requirement that one thread of execution never enters its critical section at the same time that another concurrent thread of execution enters its own critical section, which refers to an interval of time during which a thread of execution accesses a shared resource, such as shared memory. In the example below we use a Counter to count the user clicks. type Counter struct { Value int } func ( c * Counter ) Inc () { c . Value ++ } func Click ( c * Counter , wg * sync . WaitGroup ) { c . Inc () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) counter := & Counter {} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter . Value ) } At first glance, our program does not look suspicous but if we build the program with the --race flag and run; it will show us that we have a race condition here. What happens is that if we have a machine with multiple cores it can execute the Click function calls at the same time and program gets confused about the new c.Value . Now, lets fix this problem by defining a mutex in main and using the mx.Lock and mx.Unlock methods within the Click function. func Click ( c * Counter , wg * sync . WaitGroup , mx * sync . Mutex ) { mx . Lock () c . Inc () mx . Unlock () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) mx := & sync . Mutex {} counter := & Counter {} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg , mx ) } wg . Wait () fmt . Println ( counter . Value ) } It is also common to define mutex in structs. As we can see below, we have defined the *sync.Mutex as a promoted field in Counter and used the c.Lock and c.Unlock methods to protect the counter value. type Counter struct { Value int * sync . Mutex } func ( c * Counter ) Inc () { c . Value ++ } func Click ( c * Counter , wg * sync . WaitGroup ) { c . Lock () c . Inc () c . Unlock () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) counter := & Counter { Mutex : & sync . Mutex {}} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter . Value ) } Select \u00b6 Sending data to channels or waiting for data from channels blocks the application. Select allows us to await data from multiple channels at the same time. In the example below, two goroutines continuously sending data to chan1 and chan2 . We can read all incoming messages from both channels by selecting both of them inside an infinite loop. When a message comes from any of the channels, select statement will enter into the corresponding case and handle the message. After the case ends for loop will start the selection process again. func Work ( ch1 chan string , ch2 chan string ) { // Send data to ch1 every second go func () { for { time . Sleep ( 1 * time . Second ) ch1 <- \"work-1\" } }() // Send data to ch2 every 1.5 seconds go func () { for { time . Sleep ( 1.5 * time . Second ) ch2 <- \"work-2\" } }() } func main () { ch1 := make ( chan string ) ch2 := make ( chan string ) go Work ( ch1 , ch2 ) for { select { case msg1 := <- ch1 : fmt . Println ( msg1 ) case msg2 := <- ch2 : fmt . Println ( msg2 ) } } } Adding Timeout \u00b6 A program like above will be blocked if both channels does not receive any message. We can add timeouts to prevent this to happen. We can break the loop by waiting from a signal from another finite channel and then break the loop when it is triggered. Go has predefined channels for this kind of purposes. Time module has the time.After function which sends a signal after a certain delay. func main () { ch1 := make ( chan string ) ch2 := make ( chan string ) go Work ( ch1 , ch2 ) for { select { case msg1 := <- ch1 : fmt . Println ( msg1 ) case msg2 := <- ch2 : fmt . Println ( msg2 ) case <- time . After ( time . Second ): fmt . Println ( \"\ud83c\udfb5 Brave Sir Robin ran away \ud83c\udfb5\" ) fmt . Println ( \"\ud83c\udfb5 Bravely ran away away \ud83c\udfb5\" ) return } } Context \u00b6 \"We use Context to inform goroutines about cancellations and timeouts.\" Context deserve atleast the same amout of learning effort as the other concurrency units. When we spawn a goroutine using go Func() , it does not give us a reference to later learn about its status. Spawning goroutines all around without caring much about their status can significanly effect the performance without any obvious errors. We sometimes spawn resource intensive goroutines using another goroutines. When the spawner goroutine finishes other goroutine keeps running in background even it is not necessary. Our resoures gets wasted. Uncool.. This is where the Context comes handy. Context allows us to propagate cancellation across goroutines. We can create context hierarchies. When the parent context gets cancelled all child contexts also cancels. Without Context With Context Implementation \u00b6 GO provides all these stuff under the context package. The package has the context.Context interface that defines 4 methods. type Context interface { Deadline () ( deadline time . Time , ok bool ) Done () <- chan struct {} Err () error Value ( key interface {}) interface {} } Deadline() method returns the deadline for the work to be completed. Using this; we can dich a long running task if it has not enough time to finish anyway. Done() returns a channel that gets closed after the work is completed or the context gets cancelled . Err() returns an error that explains the reason why the context ended. It can be either Canceled or DeadlineExceeded . Value returns the value of given key. As the parent context data is shared through the hierarchy, same key will always return the same value. Warning Using this mechanic to deliver data accross tasks and hierarchies is a bad idea since the key and the value does not have any type checking. The context package provides functions to create types that implements the Context interface for various purpouses. These functions are: context.Background() that returns the root context. The background context does not contain any logic in it. All the other contexts are the children of the background context. context.TODO() that is basically same as context.Background() but we use this as a placeholder when we are not sure about the context type we are going to use. The package also provides some functions that wraps the parent context and add some cancellation logic to it. All these functions excepts a parent context and they all returns the wrapped context and a function to cancel the context manually. They send a signal to Done() channel when their criteria is meth. context.WithCancel(parent) is used to cancel the context manually. It does not contain a timeout or deadline logic. In the example below we create a background task and wrap it with context.WithCancel . Then we spawn 2 SendRequest goroutines and share the context with them and we spawn another goroutine that triggers the cancel function after 1 second. Notice how all functions passes the context to other and wait for the context to be done using the <- ctx.Done() statement. When the cancel function gets triggered it will notify all of the tasks by sending a signal to the ctx.Done() channel. // SearchDB finishes normally after 2 seconds func SearchDB ( ctx context . Context ){ fmt . Println ( \"Searching Database\" ) select { case <- ctx . Done (): fmt . Println ( \"Search Cancelled\" ) case <- time . After ( time . Second * 2 ): fmt . Println ( \"Search Finished\" ) } } // SendRequest finishes normally after 2 seconds func SendRequest ( ctx context . Context ){ fmt . Println ( \"Processing Request\" ) go SearchDB ( ctx ) go SearchDB ( ctx ) select { case <- ctx . Done (): fmt . Println ( \"Request Cancelled\" ) case <- time . After ( time . Second * 2 ): fmt . Println ( \"Request Finished\" ) } } func main () { ctx := context . Background () cancellingCtx , cancel := context . WithCancel ( ctx ) go SendRequest ( cancellingCtx ) go SendRequest ( cancellingCtx ) // This will manually cancel all request and database searches after 1 second go time . AfterFunc ( time . Second , cancel ) select { case <- cancellingCtx . Done (): fmt . Println ( \"Cancelled by Context\" ) case <- time . After ( time . Second * 3 ): fmt . Println ( \"Finished normally\" ) } // This will give time to goroutines to print stuff on screen <- time . After ( time . Second * 3 ) } context.WithTimeout(parent, duration) is used to set a certain time limit. We can also add a new timeout to existing context. For this example; we can add another timeout in SendRequest function. So that if the database does not return within 2 seconds we can cancel it. // SendRequest finishes normally after 5 seconds // Cancels database search after waiting for 2 seconds func SendRequest ( ctx context . Context ){ fmt . Println ( \"Processing Request\" ) // This will cancel all database searches after 2 seconds // We will not use the cancel function since we already set a timeout dbCtx , _ := context . WithTimeout ( ctx , time . Second * 2 ) go SearchDB ( dbCtx ) go SearchDB ( dbCtx ) select { case <- ctx . Done (): fmt . Println ( \"Request Cancelled\" ) case <- dbCtx . Done (): fmt . Println ( \"Search Timeout -\" , dbCtx . Err ()) // Search Timeout - context deadline exceeded case <- time . After ( time . Second * 5 ): fmt . Println ( \"Request Finished\" ) } } context.WithDeadline(parent, time) is used to when you want context to be cancelled on a specific time. Example \u00b6 A group of workers is working in a iron and coal mine deposit, where ores are explored, mined and processed. In the application below, we can see how workers can work in parallel with the concurrency tools provided by the go language. package main import ( \"fmt\" \"strconv\" \"sync\" \"time\" ) // Vein holds and yields ores type Vein struct { Ores [] string } // Reveal shows the next ore in the mine func ( vein * Vein ) Reveal () ( ore string ) { if len ( vein . Ores ) == 0 { return } ore = vein . Ores [ 0 ] vein . Ores = vein . Ores [ 1 :] return ore } // Worker can explore veins, mines or processes ores. type Worker struct { name string } // Find sends the next found ore in the mine to the miner channel func ( w * Worker ) Find ( vein * Vein , ch chan <- string ) { ore := vein . Reveal () if ore != \"\" { fmt . Println ( w . name , \"found\" , ore ) time . Sleep ( time . Second * 2 ) ch <- ore } } // Mine extracts the found ore and sends it to smelting channel func ( w * Worker ) Mine ( finder <- chan string , smelter chan <- string ) { for ore := range finder { fmt . Println ( w . name , \"mining\" , ore ) time . Sleep ( time . Second * 1 ) smelter <- ore } } // Smelt melts or processes the ore func ( w * Worker ) Smelt ( coal_miner , iron_miner <- chan string , wg * sync . WaitGroup ) { for { select { case coal_ore := <- coal_miner : time . Sleep ( time . Second * 1 ) fmt . Println ( w . name , \"processed\" , coal_ore ) case iron_ore := <- iron_miner : time . Sleep ( time . Second * 2 ) fmt . Println ( w . name , \"smelted\" , iron_ore ) } wg . Done () } } func main () { wg := & sync . WaitGroup {} // Create a Iron Vein with 100 ores in it n_iron_ores := 100 iron_vein := & Vein { make ([] string , n_iron_ores )} for i := range iron_vein . Ores { iron_vein . Ores [ i ] = \"iron-ore-\" + strconv . Itoa ( i ) } // Create a Coal Vein with 50 ores in it n_coal_ores := 50 coal_vein := & Vein { make ([] string , n_coal_ores )} for i := range coal_vein . Ores { coal_vein . Ores [ i ] = \"coal-ore-\" + strconv . Itoa ( i ) } // Create ore delivery channel between workers finder_to_miner := make ( chan string ) coal_miner_to_smelter := make ( chan string ) iron_miner_to_smelter := make ( chan string ) // Create ore explorers n_finders := 6 finders := make ([] * Worker , n_finders ) for i := range finders { finders [ i ] = & Worker { name : \"finder-\" + strconv . Itoa ( i ), } } // Create ore miners n_miners := 50 miners := make ([] * Worker , n_miners ) for i := range miners { miners [ i ] = & Worker { name : \"miner-\" + strconv . Itoa ( i ), } } // Create ore smelters n_smelters := 10 smelters := make ([] * Worker , n_smelters ) for i := range smelters { smelters [ i ] = & Worker { name : \"smelter-\" + strconv . Itoa ( i ), } } // Send half of the explorers to find ores in coal vein // and other half to iron vein for i := 0 ; i < n_iron_ores + n_coal_ores ; i ++ { wg . Add ( 1 ) finder_idx := i % len ( finders ) go finders [ finder_idx ]. Find ( coal_vein , finder_to_miner ) go finders [ finder_idx ]. Find ( iron_vein , finder_to_miner ) } // Assing half of the miners to mine iron ores and the other half to coal for i , miner := range miners { if i % 2 == 0 { go miner . Mine ( finder_to_miner , iron_miner_to_smelter ) } else { go miner . Mine ( finder_to_miner , coal_miner_to_smelter ) } } // Start working the smelters for _ , smelter := range smelters { go smelter . Smelt ( coal_miner_to_smelter , iron_miner_to_smelter , wg ) } // Wait for all ores to be found, mined and smelted wg . Wait () }","title":"Concurrency"},{"location":"concurrency/#concurrency","text":"English | T\u00fcrk\u00e7e In computer science, concurrency is the ability to run workpieces sequentially in a way that does not affect the final result. The ability to run the workpieces independently allows us to use the processor at maximum efficiency by executing the instructions in different cores.","title":"Concurrency"},{"location":"concurrency/#goroutines","text":"Goroutines are functions in a task queue that waits to be executed by a system thread. To create a goroutine, we only need to write go when running the function. In the application below, every time the Work function is called it blocks the application until it is finished. func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { Work ( \"work work work work work work...\" ) Work ( \"zxcasfv\" ) } Let's run the blocking parts as goroutine. func main () { go Work ( \"work work work work work work...\" ) go Work ( \"zxcasfv\" ) } When we run the program, it will end without printing anything on the screen. This is because after the function main finishes the program exits without waiting Work function to write on the screen. We can capture the output of Work function by adding a small delay at the end of the main function, package main import ( \"fmt\" \"time\" ) func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { go Work ( \"work work work work work work...\" ) go Work ( \"zxcasfv\" ) time . Sleep ( time . Second * 3 ) }","title":"Goroutines"},{"location":"concurrency/#waitgroup","text":"In some cases, we may need the to wait for a number of goroutines to finish at a certain moment of the runtime. With WaitGroup, we can specify the number of goroutines we want wait for and after the individual goroutine finishes its job it can call WaitGroup's Done() method to notify the waitgroup. func Work ( msg string , wg * sync . WaitGroup ) { time . Sleep ( time . Second * 2 ) fmt . Println ( msg ) wg . Done () } func main () { nWorkers := 5 wg := & sync . WaitGroup {} wg . Add ( nWorkers ) for i := 0 ; i < nWorkers ; i ++ { go Work ( \"work\" , wg ) } wg . Wait () }","title":"WaitGroup"},{"location":"concurrency/#channels","text":"Channels allows us to communicate goroutines with each other. In the above example, we cannot get the return value from the functions if we run them as goroutines. We can create a channel to send the result of a goroutine to the main function or to anoter goroutine. Channels can be created as make(chan data_type, buffer) . We can send data to channel using the channel <- data and wait data from channel using the data := <- channel signature. Both these operations block the runtime until they finish. func Work ( msg string , ch chan string ) { time . Sleep ( time . Second * 2 ) ch <- msg } func main () { channel := make ( chan string ) go Work ( \"work-1\" , channel ) go Work ( \"work-2\" , channel ) for i := 0 ; i < 2 ; i ++ { msg := <- channel fmt . Println ( msg ) } }","title":"Channels"},{"location":"concurrency/#mutex","text":"Mutexes are the concurrency primitives that allow goroutines to change the value of a shared variable without causing a race condition. Wikipedia Definition In computer science, mutual exclusion is a property of concurrency control, which is instituted for the purpose of preventing race conditions. It is the requirement that one thread of execution never enters its critical section at the same time that another concurrent thread of execution enters its own critical section, which refers to an interval of time during which a thread of execution accesses a shared resource, such as shared memory. In the example below we use a Counter to count the user clicks. type Counter struct { Value int } func ( c * Counter ) Inc () { c . Value ++ } func Click ( c * Counter , wg * sync . WaitGroup ) { c . Inc () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) counter := & Counter {} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter . Value ) } At first glance, our program does not look suspicous but if we build the program with the --race flag and run; it will show us that we have a race condition here. What happens is that if we have a machine with multiple cores it can execute the Click function calls at the same time and program gets confused about the new c.Value . Now, lets fix this problem by defining a mutex in main and using the mx.Lock and mx.Unlock methods within the Click function. func Click ( c * Counter , wg * sync . WaitGroup , mx * sync . Mutex ) { mx . Lock () c . Inc () mx . Unlock () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) mx := & sync . Mutex {} counter := & Counter {} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg , mx ) } wg . Wait () fmt . Println ( counter . Value ) } It is also common to define mutex in structs. As we can see below, we have defined the *sync.Mutex as a promoted field in Counter and used the c.Lock and c.Unlock methods to protect the counter value. type Counter struct { Value int * sync . Mutex } func ( c * Counter ) Inc () { c . Value ++ } func Click ( c * Counter , wg * sync . WaitGroup ) { c . Lock () c . Inc () c . Unlock () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) counter := & Counter { Mutex : & sync . Mutex {}} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter . Value ) }","title":"Mutex"},{"location":"concurrency/#select","text":"Sending data to channels or waiting for data from channels blocks the application. Select allows us to await data from multiple channels at the same time. In the example below, two goroutines continuously sending data to chan1 and chan2 . We can read all incoming messages from both channels by selecting both of them inside an infinite loop. When a message comes from any of the channels, select statement will enter into the corresponding case and handle the message. After the case ends for loop will start the selection process again. func Work ( ch1 chan string , ch2 chan string ) { // Send data to ch1 every second go func () { for { time . Sleep ( 1 * time . Second ) ch1 <- \"work-1\" } }() // Send data to ch2 every 1.5 seconds go func () { for { time . Sleep ( 1.5 * time . Second ) ch2 <- \"work-2\" } }() } func main () { ch1 := make ( chan string ) ch2 := make ( chan string ) go Work ( ch1 , ch2 ) for { select { case msg1 := <- ch1 : fmt . Println ( msg1 ) case msg2 := <- ch2 : fmt . Println ( msg2 ) } } }","title":"Select"},{"location":"concurrency/#adding-timeout","text":"A program like above will be blocked if both channels does not receive any message. We can add timeouts to prevent this to happen. We can break the loop by waiting from a signal from another finite channel and then break the loop when it is triggered. Go has predefined channels for this kind of purposes. Time module has the time.After function which sends a signal after a certain delay. func main () { ch1 := make ( chan string ) ch2 := make ( chan string ) go Work ( ch1 , ch2 ) for { select { case msg1 := <- ch1 : fmt . Println ( msg1 ) case msg2 := <- ch2 : fmt . Println ( msg2 ) case <- time . After ( time . Second ): fmt . Println ( \"\ud83c\udfb5 Brave Sir Robin ran away \ud83c\udfb5\" ) fmt . Println ( \"\ud83c\udfb5 Bravely ran away away \ud83c\udfb5\" ) return } }","title":"Adding Timeout"},{"location":"concurrency/#context","text":"\"We use Context to inform goroutines about cancellations and timeouts.\" Context deserve atleast the same amout of learning effort as the other concurrency units. When we spawn a goroutine using go Func() , it does not give us a reference to later learn about its status. Spawning goroutines all around without caring much about their status can significanly effect the performance without any obvious errors. We sometimes spawn resource intensive goroutines using another goroutines. When the spawner goroutine finishes other goroutine keeps running in background even it is not necessary. Our resoures gets wasted. Uncool.. This is where the Context comes handy. Context allows us to propagate cancellation across goroutines. We can create context hierarchies. When the parent context gets cancelled all child contexts also cancels. Without Context With Context","title":"Context"},{"location":"concurrency/#implementation","text":"GO provides all these stuff under the context package. The package has the context.Context interface that defines 4 methods. type Context interface { Deadline () ( deadline time . Time , ok bool ) Done () <- chan struct {} Err () error Value ( key interface {}) interface {} } Deadline() method returns the deadline for the work to be completed. Using this; we can dich a long running task if it has not enough time to finish anyway. Done() returns a channel that gets closed after the work is completed or the context gets cancelled . Err() returns an error that explains the reason why the context ended. It can be either Canceled or DeadlineExceeded . Value returns the value of given key. As the parent context data is shared through the hierarchy, same key will always return the same value. Warning Using this mechanic to deliver data accross tasks and hierarchies is a bad idea since the key and the value does not have any type checking. The context package provides functions to create types that implements the Context interface for various purpouses. These functions are: context.Background() that returns the root context. The background context does not contain any logic in it. All the other contexts are the children of the background context. context.TODO() that is basically same as context.Background() but we use this as a placeholder when we are not sure about the context type we are going to use. The package also provides some functions that wraps the parent context and add some cancellation logic to it. All these functions excepts a parent context and they all returns the wrapped context and a function to cancel the context manually. They send a signal to Done() channel when their criteria is meth. context.WithCancel(parent) is used to cancel the context manually. It does not contain a timeout or deadline logic. In the example below we create a background task and wrap it with context.WithCancel . Then we spawn 2 SendRequest goroutines and share the context with them and we spawn another goroutine that triggers the cancel function after 1 second. Notice how all functions passes the context to other and wait for the context to be done using the <- ctx.Done() statement. When the cancel function gets triggered it will notify all of the tasks by sending a signal to the ctx.Done() channel. // SearchDB finishes normally after 2 seconds func SearchDB ( ctx context . Context ){ fmt . Println ( \"Searching Database\" ) select { case <- ctx . Done (): fmt . Println ( \"Search Cancelled\" ) case <- time . After ( time . Second * 2 ): fmt . Println ( \"Search Finished\" ) } } // SendRequest finishes normally after 2 seconds func SendRequest ( ctx context . Context ){ fmt . Println ( \"Processing Request\" ) go SearchDB ( ctx ) go SearchDB ( ctx ) select { case <- ctx . Done (): fmt . Println ( \"Request Cancelled\" ) case <- time . After ( time . Second * 2 ): fmt . Println ( \"Request Finished\" ) } } func main () { ctx := context . Background () cancellingCtx , cancel := context . WithCancel ( ctx ) go SendRequest ( cancellingCtx ) go SendRequest ( cancellingCtx ) // This will manually cancel all request and database searches after 1 second go time . AfterFunc ( time . Second , cancel ) select { case <- cancellingCtx . Done (): fmt . Println ( \"Cancelled by Context\" ) case <- time . After ( time . Second * 3 ): fmt . Println ( \"Finished normally\" ) } // This will give time to goroutines to print stuff on screen <- time . After ( time . Second * 3 ) } context.WithTimeout(parent, duration) is used to set a certain time limit. We can also add a new timeout to existing context. For this example; we can add another timeout in SendRequest function. So that if the database does not return within 2 seconds we can cancel it. // SendRequest finishes normally after 5 seconds // Cancels database search after waiting for 2 seconds func SendRequest ( ctx context . Context ){ fmt . Println ( \"Processing Request\" ) // This will cancel all database searches after 2 seconds // We will not use the cancel function since we already set a timeout dbCtx , _ := context . WithTimeout ( ctx , time . Second * 2 ) go SearchDB ( dbCtx ) go SearchDB ( dbCtx ) select { case <- ctx . Done (): fmt . Println ( \"Request Cancelled\" ) case <- dbCtx . Done (): fmt . Println ( \"Search Timeout -\" , dbCtx . Err ()) // Search Timeout - context deadline exceeded case <- time . After ( time . Second * 5 ): fmt . Println ( \"Request Finished\" ) } } context.WithDeadline(parent, time) is used to when you want context to be cancelled on a specific time.","title":"Implementation"},{"location":"concurrency/#example","text":"A group of workers is working in a iron and coal mine deposit, where ores are explored, mined and processed. In the application below, we can see how workers can work in parallel with the concurrency tools provided by the go language. package main import ( \"fmt\" \"strconv\" \"sync\" \"time\" ) // Vein holds and yields ores type Vein struct { Ores [] string } // Reveal shows the next ore in the mine func ( vein * Vein ) Reveal () ( ore string ) { if len ( vein . Ores ) == 0 { return } ore = vein . Ores [ 0 ] vein . Ores = vein . Ores [ 1 :] return ore } // Worker can explore veins, mines or processes ores. type Worker struct { name string } // Find sends the next found ore in the mine to the miner channel func ( w * Worker ) Find ( vein * Vein , ch chan <- string ) { ore := vein . Reveal () if ore != \"\" { fmt . Println ( w . name , \"found\" , ore ) time . Sleep ( time . Second * 2 ) ch <- ore } } // Mine extracts the found ore and sends it to smelting channel func ( w * Worker ) Mine ( finder <- chan string , smelter chan <- string ) { for ore := range finder { fmt . Println ( w . name , \"mining\" , ore ) time . Sleep ( time . Second * 1 ) smelter <- ore } } // Smelt melts or processes the ore func ( w * Worker ) Smelt ( coal_miner , iron_miner <- chan string , wg * sync . WaitGroup ) { for { select { case coal_ore := <- coal_miner : time . Sleep ( time . Second * 1 ) fmt . Println ( w . name , \"processed\" , coal_ore ) case iron_ore := <- iron_miner : time . Sleep ( time . Second * 2 ) fmt . Println ( w . name , \"smelted\" , iron_ore ) } wg . Done () } } func main () { wg := & sync . WaitGroup {} // Create a Iron Vein with 100 ores in it n_iron_ores := 100 iron_vein := & Vein { make ([] string , n_iron_ores )} for i := range iron_vein . Ores { iron_vein . Ores [ i ] = \"iron-ore-\" + strconv . Itoa ( i ) } // Create a Coal Vein with 50 ores in it n_coal_ores := 50 coal_vein := & Vein { make ([] string , n_coal_ores )} for i := range coal_vein . Ores { coal_vein . Ores [ i ] = \"coal-ore-\" + strconv . Itoa ( i ) } // Create ore delivery channel between workers finder_to_miner := make ( chan string ) coal_miner_to_smelter := make ( chan string ) iron_miner_to_smelter := make ( chan string ) // Create ore explorers n_finders := 6 finders := make ([] * Worker , n_finders ) for i := range finders { finders [ i ] = & Worker { name : \"finder-\" + strconv . Itoa ( i ), } } // Create ore miners n_miners := 50 miners := make ([] * Worker , n_miners ) for i := range miners { miners [ i ] = & Worker { name : \"miner-\" + strconv . Itoa ( i ), } } // Create ore smelters n_smelters := 10 smelters := make ([] * Worker , n_smelters ) for i := range smelters { smelters [ i ] = & Worker { name : \"smelter-\" + strconv . Itoa ( i ), } } // Send half of the explorers to find ores in coal vein // and other half to iron vein for i := 0 ; i < n_iron_ores + n_coal_ores ; i ++ { wg . Add ( 1 ) finder_idx := i % len ( finders ) go finders [ finder_idx ]. Find ( coal_vein , finder_to_miner ) go finders [ finder_idx ]. Find ( iron_vein , finder_to_miner ) } // Assing half of the miners to mine iron ores and the other half to coal for i , miner := range miners { if i % 2 == 0 { go miner . Mine ( finder_to_miner , iron_miner_to_smelter ) } else { go miner . Mine ( finder_to_miner , coal_miner_to_smelter ) } } // Start working the smelters for _ , smelter := range smelters { go smelter . Smelt ( coal_miner_to_smelter , iron_miner_to_smelter , wg ) } // Wait for all ores to be found, mined and smelted wg . Wait () }","title":"Example"},{"location":"data-structures/","text":"English | T\u00fcrk\u00e7e This page describes the data structures of go language and their usages in general programming. Array \u00b6 Arrays are structures that enable us to keep the same types of data together. For example; A list consisting of 4, 5, 19 and 25 defines an array. Go does not allow us to create arrays from different data types. Definition \u00b6 Arrays are basically defined as [Size]Type . We can see several ways to create arrays below. An array capable of holding 3 units of type string . var fruits [ 3 ] string When defined as such, each field in the array is filled with the default value of the data type. Based on this example, it will be defined as [\"\", \"\", \"\"] . We can change these values \u200b\u200bby accessing them on their indexes. fruits [ 0 ] = \"\ud83c\udf4c\" fruits [ 1 ] = \"\ud83c\udf4f\" fruits // [\ud83c\udf4c \ud83c\udf4f] If we use a data type other than the one defined for Array, we will encounter an error. arr [ 2 ] = 1 cannot use 1 ( type int ) as type string in assignment We can define the same array in a shorter way. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" } fruits // [\ud83c\udf4c \ud83c\udf4f] In this definition, we assign a 3 unit long array whose first 2 elements we directly define to the variable 'arr'. If we are going to create the arrayi with the values, we can leave the dimension calculation part to compiler using the expression ... fruits := [ ... ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf49] Using with Loop Arrays can be used basically in 2 ways with the for loop. 1- Accessing with Index. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } for index := range fruits { fruit := fruits [ index ] fmt . Println ( fruit ) } 2- By directly accessing the value. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } for _ , fruit := range fruits { fmt . Println ( fruit ) } Slice \u00b6 Slices are very similar to arrays in terms of usage. The difference of slices is that their size is dynamic. When defining slice, we use the structure of []Type as in the array, but we leave the brackets empty. // define nil slice var slc [] int // assigning value to nill slice slc = [] int { 12 , 24 , 39 } // direct identification slc := [] int { 12 , 24 , 39 } make \u00b6 We can also use the make function to define the slice. The first parameter of the make function determines the size of the slice to be created. If we make a slice by defining only its size it will only allocate memory total of the size of its item type. And if we later append new items into the slice it will allocate some more memory in runtime. // define by size n_items = 3 slc := make ([] int , n_items ) Allocating new memory in runtime sometimes can be costly. If we have an estimation over the size of the slice; we can give a third parameter to the make function to pre-allocate some more memory. // definition by size and capacity n_items = 3 capacity := 5 slc := make ([] int , n_items , capacity ) Slice Operations \u00b6 While creating the slice, it is filled with the default value of the data type that it will hold, as much as its capacity. However, only part of its length can be accessed. If we want to increase the size of a slice, we can use the append and copy functions for this. mutate \u00b6 When we resize a slice and assign it to another variable, changes in the new slice will also affect the original slice. fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := fruits [: 2 ] apples [ 0 ] = \"\ud83c\udf4f\" apples [ 1 ] = \"\ud83c\udf4f\" apples // [\ud83c\udf4f \ud83c\udf4f] fruits // [\ud83c\udf4f \ud83c\udf4f \ud83c\udf47 \ud83c\udf52 \ud83c\udf49] copy \u00b6 copy allows us to copy one slice of another slicea of \u200b\u200bthe same or larger capacity and returns how many elements are copied. bucket := make ([] string , 5 ) fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } n_copied := copy ( bucket , fruits ) n_copied // 5 bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49] When copying a slice, the elements replace the elements in the same index in the target slice. fruits := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4e\" , \"\" , \"\ud83c\udf4f\" } copy ( fruits , apples ) fruits // [\ud83c\udf4e \ud83c\udf4f] filter \u00b6 We can filter the slice elements according to a certain criterion. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" , \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } apple_criteria := \"\ud83c\udf4e\" apples := [] string {} for _ , fruit := range fruits { if fruit == apple_criteria { apples = append ( apples , fruit ) } } apples // [\ud83c\udf4e \ud83c\udf4e] append \u00b6 The append function takes the slice that we will increase in size as the first parameter and the elements we will add later and return a new slice containing all the elements to us. Therefore, it is necessary to keep the return value in a variable (usually the old slice variable). bucket := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } green_apple := \"\ud83c\udf4f\" bucket = append ( bucket , green_apple ) bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf4f] pop \u00b6 In the example below, we have removed the last element of the slice and assigned it to a variable. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } item , fruits := fruits [ len ( fruits ) - 1 ], fruits [: len ( fruits ) - 1 ] item // \ud83c\udf49 fruits // [\ud83c\udf4f \ud83c\udf4e] push front (unshift) \u00b6 In this example, we put a new element at the beginning of the slice. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" fruits = append ([] string { banana }, fruits ... ) fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf4e \ud83c\udf49] pop front (shift) \u00b6 In this example, we removed the first element of the slice and assigned it to a variable. fruits := [] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana , fruits := fruits [ 0 ], fruits [ 1 :] banana // \ud83c\udf4c fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf49] insert \u00b6 If we want to add a new element to any part of the slice; we can use these methods. fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" insert_index := 2 fruits = append ( fruits [: insert_index ], append ([] string { banana }, fruits [ insert_index :] ... ) ... , ) fruits // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf4c \ud83c\udf52 \ud83c\udf49] Memory Concern The append([]string{banana}, fruits[insert_index:] ...) section in line 7 creates a new slice and copies the elements of the slice fruits[insert_index:] to the created slice. These elements are then copied to the fruits slice. Creating a new slice and copying for the 2nd time can be avoided. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" insert_index := 2 fruits = append ( fruits , \"\" ) copy ( fruits [ insert_index + 1 :], fruits [ insert_index :]) fruits [ insert_index ] = banana fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49] expand \u00b6 If we want to combine one slice and the other, we can use the following methods. bucket := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } bucket = append ( bucket , apples ... ) bucket // [\ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf4f \ud83c\udf4e] In the example below, we have combined the elements after the index determined by apples in line 7 . Afterwards, we added these slice elements to the bucket items up to the index we determined. bucket := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } expand_index := 2 bucket = append ( bucket [: expand_index ] append ( apples , bucket [ expand_index :] ... ) ... , ) bucket // [\ud83c\udf47 \ud83c\udf52 \ud83c\udf4f \ud83c\udf4e \ud83c\udf49] cut \u00b6 If we want to subtract a certain range in the slice, we can use the method below. This method will add the elements up to the start index we have specified in Slice and the elements after the end index. Thus, we will frustrate the elements in between. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } cut_start_index , cut_end_index := 4 , 6 edibles = append ( edibles [: cut_start_index ], edibles [ cut_end_index :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54] cut (memory safe) \u00b6 If we store memory addresses in slice, operations can cause memory leak. The reason for this is that after a portion of slice is deleted, it can keep the reference of the deleted elements. In addition to the operations we have done in the examples below, we filled in the fields that were idle after my process with nil values. Thus, garbage collector can understand that these areas will no longer be used and bring them back to the system. apple , grapes , cherry , wmelon := \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" pepper , egplnt , corn , potato := \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" edibles := [] * string { & apple , & grapes , & cherry , & wmelon , & pepper , & egplnt , & corn , & potato } cut_start_index , cut_end_index := 4 , 6 copy ( edibles [ cut_start_index :], edibles [ cut_end_index :]) cleanup_index := len ( edibles ) - cut_end_index + cut_start_index for free_index , free_end := cleanup_index , len ( edibles ); free_index < free_end ; free_index ++ { edibles [ free_index ] = nil } edibles = edibles [: cleanup_index ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54] delete \u00b6 If we want to delete an element in the slice using its index, we can use the following method. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } index_of_cherry := 2 edibles = append ( edibles [: index_of_cherry ], edibles [ index_of_cherry + 1 :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] Delete Without Preserving Order \u00b6 We can also do the deletion by ignoring the array order. In the example below, we have replaced the last element in the slice with the element we want to delete. Then we reduced the size of the slice by 1. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } index_of_cherry := 2 edibles [ index_of_cherry ] = edibles [ len ( edibles ) - 1 ] edibles = edibles [: len ( edibles ) - 1 ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83e\udd54 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d] Map \u00b6 One of the most frequently used data types is maps. map holds values with a unique keys. Definition \u00b6 Maps can be defined as map[KeyType]ValueType or make(map[KeyType]ValueType) . var mymap = map [ string ] string {} mymap = make ( map [ string ] string ) Assigning Value \u00b6 monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"1979\" : \"Life of Brian\" , } monty_python_films_by_year [ \"1983\" ] = \"The Meaning of Life\" We can access the values \u200b\u200bwe assign using the same key. film_name := monty_python_films_by_year [ \"1983\" ] film_name // The Meaning of Life When accessing an element of Mapin, we can access an additional value that indicates whether the element is registered in the map. film_name , registered := monty_python_films_by_year [ \"2019\" ] if ! registered { fmt . Println ( \"Monty python did not relase a film at 2019\" ) } else { fmt . Println ( film_name ) } Accessing to values using for \u00b6 Map values are accessible in 2 ways. 1- We can iterate over keys by using one variable in the for loop. monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"1979\" : \"Life of Brian\" , \"1983\" : \"The Meaning of Life\" , } for year := range monty_python_films_by_year { film_name := monty_python_films_by_year [ year ] fmt . Println ( film_name , \"was released at\" , year ) } 2- We can iterate over both keys and values by using two variable in the for loop. for year , film_name := range monty_python_films_by_year { fmt . Println ( film_name , \"was released at\" , year ) } /* Monty Python and the Holy Grail was released at 1971 Life of Brian was released at 1979 The Meaning of Life was released at 1983 */ delete \u00b6 We can use the delete function to delete an element on the map. monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"2016\" : \"Batman v Superman\" , } delete ( monty_python_films_by_year , \"2016\" ) _ , registered := monty_python_films_by_year [ \"2016\" ] registered // false len ( monty_python_films_by_year ) // 1 struct \u00b6 Structs are user-defined data structures that can hold different types of data with their names. Definition \u00b6 Structs can be defined as follows. type StructName struct { field fieldType } We can define the fields of the same type of struct in one line. type Film struct { name , director string imdb float32 release_year int } var new_film = Film {} new_film // {\"\" \"\" 0 0} We can also give tags to the struct fields. type Film struct { Name string `json:\"film_name\"` Director string `json:\"director_name\"` Imdb float32 `json:\"imdb_score\"` ReleaseYear int `json:\"year_of_release\"` } Tags are popular among ORMs and serialization libraries that deal with type conversion. These tags can be accessed with the 'reflect` module. f := Film {} t := reflect . TypeOf ( f ) for _ , f := range [] string { \"Name\" , \"Director\" , \"Imdb\" , \"ReleaseYear\" } { field , found := t . FieldByName ( f ) if ! found { continue } fmt . Println ( field . Tag . Get ( \"json\" )) } /* film_name director_name imdb_score year_of_release */ Assigning Value \u00b6 A struct can be created by giving its parameters in order. new_film := Film { \"Mad Max: Fury Road\" , \"George Miller\" , 8.1 , 2015 } new_film // {Mad Max: Fury Road George Miller 8.1 2015} Similarly, it can be created by specifying the parameters and the values with the separator : . new_film := Film { Name : \"Ran\" , Director : \"Akira Kurosawa\" , Imdb : 8.2 , ReleaseYear : 1985 , } new_film // {Ran Akira Kurosawa 8.2 1985} If some of the fields are left blank while creating Struct; these fields are defined by the null values of that data type. new_film := Film { name : \"Batman v Superman\" , director : \"Zack Snyder\" , release_year : 2016 , } new_film // {Batman v Superman Zack Snyder 0 2016} Anonymous struct \u00b6 In some special cases, we may need to define structs in the function body. provider_config := struct { name string baseUrl string apiKey string }{ name : \"mapbox\" , baseUrl : \"https://api.mapbox.com/geocoding/v5/\" , apiKey : \"123asds123\" , } provider_config // {mapbox https://api.mapbox.com/geocoding/v5/ 123asds123} Anonymous fields \u00b6 Struct can also be defined without specifying field names. In this case, the data types of the fields must be different from each other. type Item struct { string // code int // quantity float32 // price } item := Item { \"child-seat-1\" , 5 , 20.1 , } item // {child-seat-1 5 20.1} Promoted fields \u00b6 A struct can be used wintin another struct without giving the a field name. In this case, inner struct is accessed by its own name. Based on the example below, Content in Page can be accessed as page.Content . type Content struct { body string size int } type Page struct { nextUrl string previousURL string Content } content := Content { body : \"<h1>Hi</h1>\" , size : 11 , } page := Page { nextUrl : \"http://.../3\" , previousURL : \"http://.../1\" , Content : content , } page // {http://.../3 http://.../1 {<h1>Hi</h1> 11}} page . Content // {<h1>Hi</h1> 11} Functions \u00b6 In general, functions in GO are defined in the following structure. func fonksiyon_name ([ list of parameters ]) [ returning data types ] { function body } func sigmoid ( value float64 ) float64 { return 1.0 / ( 1.0 + math . Exp ( - value )) } sigmoid ( 0.5 ) // 0.62246 Parameters \u00b6 Parameters given to functions are copied . For this reason, modifying the parameters do not affect the status of variables outside the function. type Wallet struct { userID int balance float64 deposit float64 } func withdraw ( wallet Wallet , amount float64 ) { wallet . balance -= amount } In the code above, we have simply defined a wallet structure and the 'withdraw' function that can withdraw money from the wallet. In the lines below, we created a wallet and used it with withdraw function. wallet := Wallet { userID : 1 , balance : 30000.12 , deposit : 40000.01 , } item_price := 10023.0 withdraw ( wallet , item_price ) wallet . balance // 3000.12 As you can see, the money in the wallet has not changed. We can work around this in 2 ways. Method 1, we can return the new balance of the wallet and update the wallet later. func withdraw ( wallet Wallet , amount float64 ) float64 { new_balance := wallet . balance - amount return new_balance } wallet . balance = withdraw ( wallet , item_price ) wallet . balance // 19977.12 This method changes the intended use of the withdraw function, whose job is to withdraw money from the wallet. Method 2, we can give the address of the wallet variable as parameter. func withdraw ( wallet * Wallet , amount float64 ) { wallet . balance -= amount } withdraw ( & wallet , item_price ) wallet . balance // 19977.12 The disadvantage of this method is that it is not thread safe. When we want to withdraw money from the wallet with different threads, it will be difficult to keep track of the balance status. Dynamic parameters \u00b6 We can dynamic parameters in GO functions. To do that, we should put ... sign before the parameter. func ReLU ( nums ... float64 ) [] float64 { new_nums := make ([] float64 , len ( nums )) for idx , value := range nums { if value > 0 { new_nums [ idx ] = value } else { new_nums [ idx ] = 0. } } return new_nums } nums := [] float64 { 1. , 0.2 , 0. , 0. , - 0.1 , 0.1 } nums = ReLU ( nums ... ) nums // [1 0.2 0 0 0 0.1] Return Values \u00b6 Returning multiple values \u00b6 Go functions are able to return multiple values. It is necessary to define the values to be returned in order between () . func swap ( first_arg , second_arg string ) ( string , string ) { return second_arg , first_arg } var language1 , language2 string = \"Python\" , \"GO\" language1 , language2 = swap ( language1 , language2 ) language1 , language2 // GO Python Naming Return Values \u00b6 We can name the return values of the functions and determine the values with these variables. Since the named return values will take the null value of the data type, they can also be used as the default return values of the function. type Record struct { id int data string } type DB struct { records [] Record locked bool } func BulkCreate ( records [] Record , db * DB ) ( n_created int , err error ) { if db . locked { err = errors . New ( \"DB is locked\" ) } else { db . records = append ( db . records , records ... ) n_created = len ( records ) } return n_created , err } db := & DB { records : [] Record {}, locked : true , } data := [] Record {} for i := 0 ; i < 100 ; i ++ { rec := Record { id : i , data : \"test\" , } data = append ( data , rec ) } n_created , err := BulkCreate ( data , db ) if err != nil { fmt . Println ( err ) } Anonymous Function \u00b6 Functions in GO are also data types and can be assigned to variables within functions. records := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } batchSize := 3 batchedRecords := func ( data [] int , batchSize int ) [][] int { var batches [][] int for batchSize < len ( data ) { data , batches = data [ batchSize :], append ( batches , data [ 0 : batchSize : batchSize ]) } batches = append ( batches , data ) return batches }( records , batchSize ) batchedRecords // [[0 1 2] [3 4 5] [6 7 8] [9]] Methods \u00b6 There are no classes and thus class methods in GO. However, similar experience can be achieved by adding an additional argument called `receiver' to the functions. type Connection struct { host string port int timeOut int isClosed bool } func ( conn * Connection ) Close () { conn . isClosed = true fmt . Println ( \"Connection\" , conn . host + \":\" + strconv . Itoa ( conn . port ), \"closed.\" ) } In above, we have added (conn * Connection) to the Close function in order to define the Connection as receiver. Now we are able to access the function via the Connection type as c.Close () . c := Connection { host : \"0.0.0.0\" , port : 8080 , timeOut : 1 , isClosed : false , } c . Close () // Connection 0.0.0.0:8080 closed. Pointer receiver | Value receiver \u00b6 As with the function parameters, it should be decided whether the receivers will be defined as values or memory addresses. We can also use receivers for other data types. type Iterable [] int func ( iterable * Iterable ) Append ( items ... int ) { * iterable = append ( * iterable , items ... ) } arr := Iterable { 1 , 2 } arr . Append ( 4 , 5 , 6 ) arr // [1 2 4 5 6] Errors \u00b6 In GO, we can create our own error types. To achieve this, the data type must implement the Error method that takes no parameters and returns a string . Definition \u00b6 In the example below, we have defined a new error called 'HTTPError', which indicates the HTTP code and the reason for the error. type HTTPError struct { Status int Reason string } func ( e HTTPError ) Error () string { return fmt . Sprintf ( \"%v: %v\" , e . Status , e . Reason ) } func MakeRequest () error { return HTTPError { Status : 400 , Reason : \"Bad Request\" , } } err := MakeRequest () if err != nil { fmt . Println ( err ) } Interface \u00b6 Interfaces are structures that specify the methods an object can have. Therefore, interfaces express the behavior of objects. For example; data can be read from or written to a file. If an interface contains read and write methods and the file object has these methods, it can be said that the file has implemented this interface. The main purpose of Interfaces is to create a common protocol for different data types that show the same behavior but contains a different implementation. Definition \u00b6 We do not need to use expressions like class File implements IO to indicate that one type uses an interface. GO establishes the relationship between interfaces and types by sharing the same methods. type IO interface { Read () [] byte Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } type Socket struct { ip string port int buffer [] byte } func ( sock * Socket ) Read () [] byte { return sock . buffer } func ( sock * Socket ) Write ( stream [] byte ) int { sock . buffer = append ( sock . buffer , stream ... ) return len ( stream ) } We have defined the 'IO' interface that defines the 'Read' and 'Write' methods, and the 'File' and 'Socket' data types with these methods. Since the Log method takes the IO interface as a parameter, it can read the data and do its job without worrying about the data type. type Logger struct { } func ( log * Logger ) Log ( io IO ) { for _ , data := range io . Read () { fmt . Print ( string ( data )) } fmt . Println () } file := & File { name : \"test\" } sock := & Socket { ip : \"0.0.0.0\" , port : 21 } logger := Logger {} data := [] byte ( \"data\" ) file . Write ( data ) sock . Write ( file . Read ()) logger . Log ( file ) // \"data\" logger . Log ( sock ) // \"data\" Using Multiple Interfaces \u00b6 GO types can implement multiple interfaces. For this, data types only needs to have the methods of the interface. type Reader interface { Read () [] byte } type Writer interface { Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } var file Reader = & File { name : \"test\" , content : [] byte ( \"data\" ), } var sock Writer = & Socket { ip : \"0.0.0.0\" , port : 21 , } sock . Write ( file . Read ()) sock . buffer // sock.buffer undefined (type Writer has no field or method buffer Type Conversion (Assertion) \u00b6 Type assertion allows access to the concrete value of the underlying data type. s := sock .( * Socket ) string ( s . buffer ) // \"data\" We can check whether the type we are asserting correctly implements the interface. type Serializer interface { Serialize () } s , ok := sock .( Serializer ) s , ok // nil, false Empty Interface \u00b6 Interfaces are also data types and can be used in the same way. Empty interface in GO defined as interface{} . Since it has no method, the requirements of the empty interface are met by all types. This unique feature of the empty interface allows us to define dynamic parameters and values. type Booking struct { Provider string CustomerID string ExtraProviderParams interface {} } booking1 := Booking { Provider : \"ACL\" , CustomerID : \"customer-01a\" , ExtraProviderParams : map [ string ] interface {}{ \"Passengers\" : 4 , \"PaymentTime\" : \"after-booking\" , }, } booking2 := Booking { Provider : \"DCM\" , CustomerID : \"customer-03f\" , ExtraProviderParams : [] interface {}{ 4 , \"after-booking\" , }, } booking1 // {ACL customer-01a map[Passengers:4 PaymentTime:after-booking]} booking2 // {DCM customer-01a [4 after-booking]} Type Checking \u00b6 Interface types can be controlled by the switch structure. Stringify function allows us to use different data types in the function by taking interface{} as parameter. We will check the int, string and float data types and convert them to string. func Stringify ( value interface {}) ( string , error ) { switch value .( type ) { case string : return value .( string ), nil case float32 , float64 : return fmt . Sprintf ( \"%.2f\" , value ), nil case int : return fmt . Sprintf ( \"%d\" , value ), nil default : return \"\" , errors . New ( \"Invalid type\" ) } } Stringify ( 12 ) // \"12\" Stringify ( 12.52312313 ) // \"12.52\" Stringify ( \"test\" ) // \"test\"","title":"Data Structures"},{"location":"data-structures/#array","text":"Arrays are structures that enable us to keep the same types of data together. For example; A list consisting of 4, 5, 19 and 25 defines an array. Go does not allow us to create arrays from different data types.","title":"Array"},{"location":"data-structures/#definition","text":"Arrays are basically defined as [Size]Type . We can see several ways to create arrays below. An array capable of holding 3 units of type string . var fruits [ 3 ] string When defined as such, each field in the array is filled with the default value of the data type. Based on this example, it will be defined as [\"\", \"\", \"\"] . We can change these values \u200b\u200bby accessing them on their indexes. fruits [ 0 ] = \"\ud83c\udf4c\" fruits [ 1 ] = \"\ud83c\udf4f\" fruits // [\ud83c\udf4c \ud83c\udf4f] If we use a data type other than the one defined for Array, we will encounter an error. arr [ 2 ] = 1 cannot use 1 ( type int ) as type string in assignment We can define the same array in a shorter way. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" } fruits // [\ud83c\udf4c \ud83c\udf4f] In this definition, we assign a 3 unit long array whose first 2 elements we directly define to the variable 'arr'. If we are going to create the arrayi with the values, we can leave the dimension calculation part to compiler using the expression ... fruits := [ ... ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf49] Using with Loop Arrays can be used basically in 2 ways with the for loop. 1- Accessing with Index. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } for index := range fruits { fruit := fruits [ index ] fmt . Println ( fruit ) } 2- By directly accessing the value. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } for _ , fruit := range fruits { fmt . Println ( fruit ) }","title":"Definition"},{"location":"data-structures/#slice","text":"Slices are very similar to arrays in terms of usage. The difference of slices is that their size is dynamic. When defining slice, we use the structure of []Type as in the array, but we leave the brackets empty. // define nil slice var slc [] int // assigning value to nill slice slc = [] int { 12 , 24 , 39 } // direct identification slc := [] int { 12 , 24 , 39 }","title":"Slice"},{"location":"data-structures/#make","text":"We can also use the make function to define the slice. The first parameter of the make function determines the size of the slice to be created. If we make a slice by defining only its size it will only allocate memory total of the size of its item type. And if we later append new items into the slice it will allocate some more memory in runtime. // define by size n_items = 3 slc := make ([] int , n_items ) Allocating new memory in runtime sometimes can be costly. If we have an estimation over the size of the slice; we can give a third parameter to the make function to pre-allocate some more memory. // definition by size and capacity n_items = 3 capacity := 5 slc := make ([] int , n_items , capacity )","title":"make"},{"location":"data-structures/#slice-operations","text":"While creating the slice, it is filled with the default value of the data type that it will hold, as much as its capacity. However, only part of its length can be accessed. If we want to increase the size of a slice, we can use the append and copy functions for this.","title":"Slice Operations"},{"location":"data-structures/#mutate","text":"When we resize a slice and assign it to another variable, changes in the new slice will also affect the original slice. fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := fruits [: 2 ] apples [ 0 ] = \"\ud83c\udf4f\" apples [ 1 ] = \"\ud83c\udf4f\" apples // [\ud83c\udf4f \ud83c\udf4f] fruits // [\ud83c\udf4f \ud83c\udf4f \ud83c\udf47 \ud83c\udf52 \ud83c\udf49]","title":"mutate"},{"location":"data-structures/#copy","text":"copy allows us to copy one slice of another slicea of \u200b\u200bthe same or larger capacity and returns how many elements are copied. bucket := make ([] string , 5 ) fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } n_copied := copy ( bucket , fruits ) n_copied // 5 bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49] When copying a slice, the elements replace the elements in the same index in the target slice. fruits := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4e\" , \"\" , \"\ud83c\udf4f\" } copy ( fruits , apples ) fruits // [\ud83c\udf4e \ud83c\udf4f]","title":"copy"},{"location":"data-structures/#filter","text":"We can filter the slice elements according to a certain criterion. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" , \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } apple_criteria := \"\ud83c\udf4e\" apples := [] string {} for _ , fruit := range fruits { if fruit == apple_criteria { apples = append ( apples , fruit ) } } apples // [\ud83c\udf4e \ud83c\udf4e]","title":"filter"},{"location":"data-structures/#append","text":"The append function takes the slice that we will increase in size as the first parameter and the elements we will add later and return a new slice containing all the elements to us. Therefore, it is necessary to keep the return value in a variable (usually the old slice variable). bucket := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } green_apple := \"\ud83c\udf4f\" bucket = append ( bucket , green_apple ) bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf4f]","title":"append"},{"location":"data-structures/#pop","text":"In the example below, we have removed the last element of the slice and assigned it to a variable. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } item , fruits := fruits [ len ( fruits ) - 1 ], fruits [: len ( fruits ) - 1 ] item // \ud83c\udf49 fruits // [\ud83c\udf4f \ud83c\udf4e]","title":"pop"},{"location":"data-structures/#push-front-unshift","text":"In this example, we put a new element at the beginning of the slice. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" fruits = append ([] string { banana }, fruits ... ) fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"push front (unshift)"},{"location":"data-structures/#pop-front-shift","text":"In this example, we removed the first element of the slice and assigned it to a variable. fruits := [] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana , fruits := fruits [ 0 ], fruits [ 1 :] banana // \ud83c\udf4c fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"pop front (shift)"},{"location":"data-structures/#insert","text":"If we want to add a new element to any part of the slice; we can use these methods. fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" insert_index := 2 fruits = append ( fruits [: insert_index ], append ([] string { banana }, fruits [ insert_index :] ... ) ... , ) fruits // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf4c \ud83c\udf52 \ud83c\udf49] Memory Concern The append([]string{banana}, fruits[insert_index:] ...) section in line 7 creates a new slice and copies the elements of the slice fruits[insert_index:] to the created slice. These elements are then copied to the fruits slice. Creating a new slice and copying for the 2nd time can be avoided. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" insert_index := 2 fruits = append ( fruits , \"\" ) copy ( fruits [ insert_index + 1 :], fruits [ insert_index :]) fruits [ insert_index ] = banana fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49]","title":"insert"},{"location":"data-structures/#expand","text":"If we want to combine one slice and the other, we can use the following methods. bucket := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } bucket = append ( bucket , apples ... ) bucket // [\ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf4f \ud83c\udf4e] In the example below, we have combined the elements after the index determined by apples in line 7 . Afterwards, we added these slice elements to the bucket items up to the index we determined. bucket := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } expand_index := 2 bucket = append ( bucket [: expand_index ] append ( apples , bucket [ expand_index :] ... ) ... , ) bucket // [\ud83c\udf47 \ud83c\udf52 \ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"expand"},{"location":"data-structures/#cut","text":"If we want to subtract a certain range in the slice, we can use the method below. This method will add the elements up to the start index we have specified in Slice and the elements after the end index. Thus, we will frustrate the elements in between. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } cut_start_index , cut_end_index := 4 , 6 edibles = append ( edibles [: cut_start_index ], edibles [ cut_end_index :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54]","title":"cut"},{"location":"data-structures/#cut-memory-safe","text":"If we store memory addresses in slice, operations can cause memory leak. The reason for this is that after a portion of slice is deleted, it can keep the reference of the deleted elements. In addition to the operations we have done in the examples below, we filled in the fields that were idle after my process with nil values. Thus, garbage collector can understand that these areas will no longer be used and bring them back to the system. apple , grapes , cherry , wmelon := \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" pepper , egplnt , corn , potato := \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" edibles := [] * string { & apple , & grapes , & cherry , & wmelon , & pepper , & egplnt , & corn , & potato } cut_start_index , cut_end_index := 4 , 6 copy ( edibles [ cut_start_index :], edibles [ cut_end_index :]) cleanup_index := len ( edibles ) - cut_end_index + cut_start_index for free_index , free_end := cleanup_index , len ( edibles ); free_index < free_end ; free_index ++ { edibles [ free_index ] = nil } edibles = edibles [: cleanup_index ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54]","title":"cut (memory safe)"},{"location":"data-structures/#delete","text":"If we want to delete an element in the slice using its index, we can use the following method. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } index_of_cherry := 2 edibles = append ( edibles [: index_of_cherry ], edibles [ index_of_cherry + 1 :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54]","title":"delete"},{"location":"data-structures/#delete-without-preserving-order","text":"We can also do the deletion by ignoring the array order. In the example below, we have replaced the last element in the slice with the element we want to delete. Then we reduced the size of the slice by 1. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } index_of_cherry := 2 edibles [ index_of_cherry ] = edibles [ len ( edibles ) - 1 ] edibles = edibles [: len ( edibles ) - 1 ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83e\udd54 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d]","title":"Delete Without Preserving Order"},{"location":"data-structures/#map","text":"One of the most frequently used data types is maps. map holds values with a unique keys.","title":"Map"},{"location":"data-structures/#definition_1","text":"Maps can be defined as map[KeyType]ValueType or make(map[KeyType]ValueType) . var mymap = map [ string ] string {} mymap = make ( map [ string ] string )","title":"Definition"},{"location":"data-structures/#assigning-value","text":"monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"1979\" : \"Life of Brian\" , } monty_python_films_by_year [ \"1983\" ] = \"The Meaning of Life\" We can access the values \u200b\u200bwe assign using the same key. film_name := monty_python_films_by_year [ \"1983\" ] film_name // The Meaning of Life When accessing an element of Mapin, we can access an additional value that indicates whether the element is registered in the map. film_name , registered := monty_python_films_by_year [ \"2019\" ] if ! registered { fmt . Println ( \"Monty python did not relase a film at 2019\" ) } else { fmt . Println ( film_name ) }","title":"Assigning Value"},{"location":"data-structures/#accessing-to-values-using-for","text":"Map values are accessible in 2 ways. 1- We can iterate over keys by using one variable in the for loop. monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"1979\" : \"Life of Brian\" , \"1983\" : \"The Meaning of Life\" , } for year := range monty_python_films_by_year { film_name := monty_python_films_by_year [ year ] fmt . Println ( film_name , \"was released at\" , year ) } 2- We can iterate over both keys and values by using two variable in the for loop. for year , film_name := range monty_python_films_by_year { fmt . Println ( film_name , \"was released at\" , year ) } /* Monty Python and the Holy Grail was released at 1971 Life of Brian was released at 1979 The Meaning of Life was released at 1983 */","title":"Accessing to values using for"},{"location":"data-structures/#delete_1","text":"We can use the delete function to delete an element on the map. monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"2016\" : \"Batman v Superman\" , } delete ( monty_python_films_by_year , \"2016\" ) _ , registered := monty_python_films_by_year [ \"2016\" ] registered // false len ( monty_python_films_by_year ) // 1","title":"delete"},{"location":"data-structures/#struct","text":"Structs are user-defined data structures that can hold different types of data with their names.","title":"struct"},{"location":"data-structures/#definition_2","text":"Structs can be defined as follows. type StructName struct { field fieldType } We can define the fields of the same type of struct in one line. type Film struct { name , director string imdb float32 release_year int } var new_film = Film {} new_film // {\"\" \"\" 0 0} We can also give tags to the struct fields. type Film struct { Name string `json:\"film_name\"` Director string `json:\"director_name\"` Imdb float32 `json:\"imdb_score\"` ReleaseYear int `json:\"year_of_release\"` } Tags are popular among ORMs and serialization libraries that deal with type conversion. These tags can be accessed with the 'reflect` module. f := Film {} t := reflect . TypeOf ( f ) for _ , f := range [] string { \"Name\" , \"Director\" , \"Imdb\" , \"ReleaseYear\" } { field , found := t . FieldByName ( f ) if ! found { continue } fmt . Println ( field . Tag . Get ( \"json\" )) } /* film_name director_name imdb_score year_of_release */","title":"Definition"},{"location":"data-structures/#assigning-value_1","text":"A struct can be created by giving its parameters in order. new_film := Film { \"Mad Max: Fury Road\" , \"George Miller\" , 8.1 , 2015 } new_film // {Mad Max: Fury Road George Miller 8.1 2015} Similarly, it can be created by specifying the parameters and the values with the separator : . new_film := Film { Name : \"Ran\" , Director : \"Akira Kurosawa\" , Imdb : 8.2 , ReleaseYear : 1985 , } new_film // {Ran Akira Kurosawa 8.2 1985} If some of the fields are left blank while creating Struct; these fields are defined by the null values of that data type. new_film := Film { name : \"Batman v Superman\" , director : \"Zack Snyder\" , release_year : 2016 , } new_film // {Batman v Superman Zack Snyder 0 2016}","title":"Assigning Value"},{"location":"data-structures/#anonymous-struct","text":"In some special cases, we may need to define structs in the function body. provider_config := struct { name string baseUrl string apiKey string }{ name : \"mapbox\" , baseUrl : \"https://api.mapbox.com/geocoding/v5/\" , apiKey : \"123asds123\" , } provider_config // {mapbox https://api.mapbox.com/geocoding/v5/ 123asds123}","title":"Anonymous struct"},{"location":"data-structures/#anonymous-fields","text":"Struct can also be defined without specifying field names. In this case, the data types of the fields must be different from each other. type Item struct { string // code int // quantity float32 // price } item := Item { \"child-seat-1\" , 5 , 20.1 , } item // {child-seat-1 5 20.1}","title":"Anonymous fields"},{"location":"data-structures/#promoted-fields","text":"A struct can be used wintin another struct without giving the a field name. In this case, inner struct is accessed by its own name. Based on the example below, Content in Page can be accessed as page.Content . type Content struct { body string size int } type Page struct { nextUrl string previousURL string Content } content := Content { body : \"<h1>Hi</h1>\" , size : 11 , } page := Page { nextUrl : \"http://.../3\" , previousURL : \"http://.../1\" , Content : content , } page // {http://.../3 http://.../1 {<h1>Hi</h1> 11}} page . Content // {<h1>Hi</h1> 11}","title":"Promoted fields"},{"location":"data-structures/#functions","text":"In general, functions in GO are defined in the following structure. func fonksiyon_name ([ list of parameters ]) [ returning data types ] { function body } func sigmoid ( value float64 ) float64 { return 1.0 / ( 1.0 + math . Exp ( - value )) } sigmoid ( 0.5 ) // 0.62246","title":"Functions"},{"location":"data-structures/#parameters","text":"Parameters given to functions are copied . For this reason, modifying the parameters do not affect the status of variables outside the function. type Wallet struct { userID int balance float64 deposit float64 } func withdraw ( wallet Wallet , amount float64 ) { wallet . balance -= amount } In the code above, we have simply defined a wallet structure and the 'withdraw' function that can withdraw money from the wallet. In the lines below, we created a wallet and used it with withdraw function. wallet := Wallet { userID : 1 , balance : 30000.12 , deposit : 40000.01 , } item_price := 10023.0 withdraw ( wallet , item_price ) wallet . balance // 3000.12 As you can see, the money in the wallet has not changed. We can work around this in 2 ways. Method 1, we can return the new balance of the wallet and update the wallet later. func withdraw ( wallet Wallet , amount float64 ) float64 { new_balance := wallet . balance - amount return new_balance } wallet . balance = withdraw ( wallet , item_price ) wallet . balance // 19977.12 This method changes the intended use of the withdraw function, whose job is to withdraw money from the wallet. Method 2, we can give the address of the wallet variable as parameter. func withdraw ( wallet * Wallet , amount float64 ) { wallet . balance -= amount } withdraw ( & wallet , item_price ) wallet . balance // 19977.12 The disadvantage of this method is that it is not thread safe. When we want to withdraw money from the wallet with different threads, it will be difficult to keep track of the balance status.","title":"Parameters"},{"location":"data-structures/#dynamic-parameters","text":"We can dynamic parameters in GO functions. To do that, we should put ... sign before the parameter. func ReLU ( nums ... float64 ) [] float64 { new_nums := make ([] float64 , len ( nums )) for idx , value := range nums { if value > 0 { new_nums [ idx ] = value } else { new_nums [ idx ] = 0. } } return new_nums } nums := [] float64 { 1. , 0.2 , 0. , 0. , - 0.1 , 0.1 } nums = ReLU ( nums ... ) nums // [1 0.2 0 0 0 0.1]","title":"Dynamic parameters"},{"location":"data-structures/#return-values","text":"","title":"Return Values"},{"location":"data-structures/#returning-multiple-values","text":"Go functions are able to return multiple values. It is necessary to define the values to be returned in order between () . func swap ( first_arg , second_arg string ) ( string , string ) { return second_arg , first_arg } var language1 , language2 string = \"Python\" , \"GO\" language1 , language2 = swap ( language1 , language2 ) language1 , language2 // GO Python","title":"Returning multiple values"},{"location":"data-structures/#naming-return-values","text":"We can name the return values of the functions and determine the values with these variables. Since the named return values will take the null value of the data type, they can also be used as the default return values of the function. type Record struct { id int data string } type DB struct { records [] Record locked bool } func BulkCreate ( records [] Record , db * DB ) ( n_created int , err error ) { if db . locked { err = errors . New ( \"DB is locked\" ) } else { db . records = append ( db . records , records ... ) n_created = len ( records ) } return n_created , err } db := & DB { records : [] Record {}, locked : true , } data := [] Record {} for i := 0 ; i < 100 ; i ++ { rec := Record { id : i , data : \"test\" , } data = append ( data , rec ) } n_created , err := BulkCreate ( data , db ) if err != nil { fmt . Println ( err ) }","title":"Naming Return Values"},{"location":"data-structures/#anonymous-function","text":"Functions in GO are also data types and can be assigned to variables within functions. records := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } batchSize := 3 batchedRecords := func ( data [] int , batchSize int ) [][] int { var batches [][] int for batchSize < len ( data ) { data , batches = data [ batchSize :], append ( batches , data [ 0 : batchSize : batchSize ]) } batches = append ( batches , data ) return batches }( records , batchSize ) batchedRecords // [[0 1 2] [3 4 5] [6 7 8] [9]]","title":"Anonymous Function"},{"location":"data-structures/#methods","text":"There are no classes and thus class methods in GO. However, similar experience can be achieved by adding an additional argument called `receiver' to the functions. type Connection struct { host string port int timeOut int isClosed bool } func ( conn * Connection ) Close () { conn . isClosed = true fmt . Println ( \"Connection\" , conn . host + \":\" + strconv . Itoa ( conn . port ), \"closed.\" ) } In above, we have added (conn * Connection) to the Close function in order to define the Connection as receiver. Now we are able to access the function via the Connection type as c.Close () . c := Connection { host : \"0.0.0.0\" , port : 8080 , timeOut : 1 , isClosed : false , } c . Close () // Connection 0.0.0.0:8080 closed.","title":"Methods"},{"location":"data-structures/#pointer-receiver-value-receiver","text":"As with the function parameters, it should be decided whether the receivers will be defined as values or memory addresses. We can also use receivers for other data types. type Iterable [] int func ( iterable * Iterable ) Append ( items ... int ) { * iterable = append ( * iterable , items ... ) } arr := Iterable { 1 , 2 } arr . Append ( 4 , 5 , 6 ) arr // [1 2 4 5 6]","title":"Pointer receiver | Value receiver"},{"location":"data-structures/#errors","text":"In GO, we can create our own error types. To achieve this, the data type must implement the Error method that takes no parameters and returns a string .","title":"Errors"},{"location":"data-structures/#definition_3","text":"In the example below, we have defined a new error called 'HTTPError', which indicates the HTTP code and the reason for the error. type HTTPError struct { Status int Reason string } func ( e HTTPError ) Error () string { return fmt . Sprintf ( \"%v: %v\" , e . Status , e . Reason ) } func MakeRequest () error { return HTTPError { Status : 400 , Reason : \"Bad Request\" , } } err := MakeRequest () if err != nil { fmt . Println ( err ) }","title":"Definition"},{"location":"data-structures/#interface","text":"Interfaces are structures that specify the methods an object can have. Therefore, interfaces express the behavior of objects. For example; data can be read from or written to a file. If an interface contains read and write methods and the file object has these methods, it can be said that the file has implemented this interface. The main purpose of Interfaces is to create a common protocol for different data types that show the same behavior but contains a different implementation.","title":"Interface"},{"location":"data-structures/#definition_4","text":"We do not need to use expressions like class File implements IO to indicate that one type uses an interface. GO establishes the relationship between interfaces and types by sharing the same methods. type IO interface { Read () [] byte Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } type Socket struct { ip string port int buffer [] byte } func ( sock * Socket ) Read () [] byte { return sock . buffer } func ( sock * Socket ) Write ( stream [] byte ) int { sock . buffer = append ( sock . buffer , stream ... ) return len ( stream ) } We have defined the 'IO' interface that defines the 'Read' and 'Write' methods, and the 'File' and 'Socket' data types with these methods. Since the Log method takes the IO interface as a parameter, it can read the data and do its job without worrying about the data type. type Logger struct { } func ( log * Logger ) Log ( io IO ) { for _ , data := range io . Read () { fmt . Print ( string ( data )) } fmt . Println () } file := & File { name : \"test\" } sock := & Socket { ip : \"0.0.0.0\" , port : 21 } logger := Logger {} data := [] byte ( \"data\" ) file . Write ( data ) sock . Write ( file . Read ()) logger . Log ( file ) // \"data\" logger . Log ( sock ) // \"data\"","title":"Definition"},{"location":"data-structures/#using-multiple-interfaces","text":"GO types can implement multiple interfaces. For this, data types only needs to have the methods of the interface. type Reader interface { Read () [] byte } type Writer interface { Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } var file Reader = & File { name : \"test\" , content : [] byte ( \"data\" ), } var sock Writer = & Socket { ip : \"0.0.0.0\" , port : 21 , } sock . Write ( file . Read ()) sock . buffer // sock.buffer undefined (type Writer has no field or method buffer","title":"Using Multiple Interfaces"},{"location":"data-structures/#type-conversion-assertion","text":"Type assertion allows access to the concrete value of the underlying data type. s := sock .( * Socket ) string ( s . buffer ) // \"data\" We can check whether the type we are asserting correctly implements the interface. type Serializer interface { Serialize () } s , ok := sock .( Serializer ) s , ok // nil, false","title":"Type Conversion (Assertion)"},{"location":"data-structures/#empty-interface","text":"Interfaces are also data types and can be used in the same way. Empty interface in GO defined as interface{} . Since it has no method, the requirements of the empty interface are met by all types. This unique feature of the empty interface allows us to define dynamic parameters and values. type Booking struct { Provider string CustomerID string ExtraProviderParams interface {} } booking1 := Booking { Provider : \"ACL\" , CustomerID : \"customer-01a\" , ExtraProviderParams : map [ string ] interface {}{ \"Passengers\" : 4 , \"PaymentTime\" : \"after-booking\" , }, } booking2 := Booking { Provider : \"DCM\" , CustomerID : \"customer-03f\" , ExtraProviderParams : [] interface {}{ 4 , \"after-booking\" , }, } booking1 // {ACL customer-01a map[Passengers:4 PaymentTime:after-booking]} booking2 // {DCM customer-01a [4 after-booking]}","title":"Empty Interface"},{"location":"data-structures/#type-checking","text":"Interface types can be controlled by the switch structure. Stringify function allows us to use different data types in the function by taking interface{} as parameter. We will check the int, string and float data types and convert them to string. func Stringify ( value interface {}) ( string , error ) { switch value .( type ) { case string : return value .( string ), nil case float32 , float64 : return fmt . Sprintf ( \"%.2f\" , value ), nil case int : return fmt . Sprintf ( \"%d\" , value ), nil default : return \"\" , errors . New ( \"Invalid type\" ) } } Stringify ( 12 ) // \"12\" Stringify ( 12.52312313 ) // \"12.52\" Stringify ( \"test\" ) // \"test\"","title":"Type Checking"},{"location":"tr/","text":"Go Tutorial \u00b6 English | T\u00fcrk\u00e7e Bu sayfa Go veri yap\u0131lar\u0131n\u0131n kullan\u0131m\u0131 ve e\u015fzamanl\u0131 programlama ile ilgili bilgi sunar. Konular \u00b6 Data Structures Array, Slice, Map, Struct, Interface, Error, ve di\u011fer temel veri yap\u0131lar\u0131n\u0131n kullan\u0131m\u0131. Concurrency E\u015fzamanl\u0131 \u00e7al\u0131\u015fma tasar\u0131mlar\u0131n\u0131n Go dilinde kullan\u0131m\u0131.","title":"Index"},{"location":"tr/#go-tutorial","text":"English | T\u00fcrk\u00e7e Bu sayfa Go veri yap\u0131lar\u0131n\u0131n kullan\u0131m\u0131 ve e\u015fzamanl\u0131 programlama ile ilgili bilgi sunar.","title":"Go Tutorial"},{"location":"tr/#konular","text":"Data Structures Array, Slice, Map, Struct, Interface, Error, ve di\u011fer temel veri yap\u0131lar\u0131n\u0131n kullan\u0131m\u0131. Concurrency E\u015fzamanl\u0131 \u00e7al\u0131\u015fma tasar\u0131mlar\u0131n\u0131n Go dilinde kullan\u0131m\u0131.","title":"Konular"},{"location":"tr/best-practices/","text":"Best Practices \u00b6 A language that doesn\u2019t affect the way you think about programming is not worth knowing.\u200a\u2014\u200aAlan Perlis Genel Prensipler \u00b6 Keep it simple Don\u2019t Repeat Yourself You ain't gonna need it Avoid Nesting \u00b6 \u0130yi GO kodu dilin kendi kodlar\u0131 gibidir. Standart olarak bu yaz\u0131m tercih edilmelidir. // Reset clears the state of the Writer z such that it is equivalent to its // initial state from NewWriterLevel or NewWriterLevelDict, but instead writing // to w. func ( z * Writer ) Reset ( w io . Writer ) { z . w = w // z.level and z.dict left unchanged. if z . compressor != nil { z . compressor . Reset ( w ) } if z . digest != nil { z . digest . Reset () } z . err = nil z . scratch = [ 4 ] byte {} z . wroteHeader = false } https://go-proverbs.github.io/ Kodlama \u00b6 Composition \u00b6 Fragile Base Class Problemi \u00b6 Fragile base class problemi nesne y\u00f6nelimli programlama sistemlerindeki temel bir mimari problemidir. Bu mimarilerde ana s\u0131n\u0131flar k\u0131r\u0131lgan kabul edilir. Bunun sebebi \u00fcst s\u0131n\u0131ftaki bir de\u011fi\u015fikli\u011fin alt s\u0131n\u0131flara da yans\u0131mas\u0131 ve alt s\u0131n\u0131flarda i\u015flev bozuklu\u011funa sebep olabilmesidir. Yaz\u0131l\u0131mc\u0131 bu t\u00fcr mimarilerde ana s\u0131n\u0131f\u0131n metodlar\u0131n\u0131 izole edemez ve bu nedenle ana s\u0131n\u0131fta yap\u0131lan de\u011fi\u015fikliklerin g\u00fcvenli olup olmad\u0131\u011f\u0131n\u0131ndan emin olamaz. Bu t\u00fcr dillerde kal\u0131t\u0131m yerine kompozisyon tercih edilmelidir. Kompleks ve hiyerar\u015fik yap\u0131lar kodun esnekli\u011fini kaybettirir. https://en.wikipedia.org/wiki/Composition_over_inheritance Kompozisyon y\u00f6nteminde ise bir s\u0131n\u0131f\u0131n di\u011ferinin t\u00fcm \u00f6zelliklerini miras almak yerine parametre olarak belli \u00f6zellikleri se\u00e7ilebilir. GO dilininin yaz\u0131l\u0131mc\u0131lar\u0131 kompozisyona itmesi en g\u00fc\u00e7l\u00fc \u00f6zelliklerinden birisidir. Loose Coupling \u00b6 Yaz\u0131l\u0131m d\u00fcnyas\u0131nda, coupling iki birimin birbirine ne kadar ba\u011f\u0131ml\u0131 oldu\u011funun \u00f6l\u00e7\u00fcs\u00fcd\u00fcr. Par\u00e7alar\u0131n\u0131n birbirine s\u0131k\u0131 s\u0131k\u0131ya ba\u011fl\u0131 oldu\u011fu programlarda de\u011fi\u015fiklik yapmak \u00e7ok zordur. Bu duruma shotgun surgery efekti de denir. Shotgun surgery terimi, projenin bir k\u0131sm\u0131nda yap\u0131lan de\u011fi\u015fikli\u011fin di\u011fer k\u0131s\u0131mlar\u0131nda s\u0131ral\u0131 halde ufak de\u011fi\u015fikliklere yol a\u00e7mas\u0131d\u0131r. \u00d6rnek vermek gerekirse: type Booking struct { ID int Status string } type DB struct {} func ( d DB ) Booking ( ID int ) * Booking {} type Client struct {} func Cancel ( ID int ) error { db := DB {} if booking := db . Booking ( ID ); booking . Status == \"active\" { return errors . New ( \"booking does not exists\" ) } return nil } func Get ( ID int ) error { db := DB {} if booking := db . Booking ( ID ); booking . Status == \"active\" { return errors . New ( \"booking does not exists\" ) } return nil } Yukar\u0131daki kodda Bookinge ait methodlarda tek bir kontrol var. O da bookingin aktif olmas\u0131. Her metoda bu kontrol\u00fc ekleyerek code smell olu\u015fturduk. \u015eimdi \"active\" kontrol\u00fc de\u011fi\u015firse Bookinge ait t\u00fcm metodlarda de\u011fi\u015fiklik yapmak gerekecek. Bu s\u0131k\u0131nt\u0131y\u0131 gidermek i\u00e7in ilk ad\u0131m, kontrol k\u0131sm\u0131n\u0131 ayr\u0131 bir fonksiyonda tan\u0131mlayabiliriz. func validateBooking ( db * DB , ID int ) bool { if booking := db . Booking ( ID ); booking . Status == \"active\" { return true } return false } func Cancel ( ID int ) error { db := DB {} if isActive := validateBooking ( & db , ID ); isActive { return errors . New ( \"booking does not exists\" ) } return nil } func Get ( ID int ) error { db := DB {} if isActive := validateBooking ( & db , ID ); isActive { return errors . New ( \"booking does not exists\" ) } return nil } Do\u011frulamada bir de\u011fi\u015fiklik oldu\u011funda art\u0131k sadece validateBooking fonksiyonun de\u011fi\u015ftirilmesi yeterli. Single Responsibility \u00b6 Yukar\u0131daki kod par\u00e7as\u0131nda hala d\u00fczeltilmesi gereken k\u0131s\u0131mlar var. validateBooking fonksiyonu DB tipini do\u011frudan kullan\u0131yor. Bu hem tight coupling olu\u015fmas\u0131na hem de i\u015fi sadece bookinglerin durumunu kontrol etmek olan fonksiyonun veritaban\u0131na da eri\u015ferek birden fazla i\u015f yapmas\u0131na sebep oluyor. // booking.go type Booking struct { ID int Status string } func ( b Booking ) Validate () bool { if b . Status == \"active\" { return true } return false } // db.go type DB struct {} func ( d DB ) Get ( ID int ) * Booking { return nil } // client.go type Client struct {} func Cancel ( ID int ) error { db := DB {} booking := db . Get ( ID ) if booking . Validate () { return errors . New ( \"booking does not exists\" ) } return nil } func Get ( ID int ) error { db := DB {} booking := db . Get ( ID ) if booking . Validate () { return errors . New ( \"booking does not exists\" ) } return nil } Liskov Substitution \u00b6 Nesne y\u00f6nelimli dillerde liskov substitution prensibi; miras alan s\u0131n\u0131f\u0131n, \u00fcst s\u0131n\u0131f ile yer de\u011fi\u015ftirdi\u011fi zaman, ayn\u0131 davran\u0131\u015f\u0131 sergilemesi gerekti\u011fini s\u00f6yler. GOda bu tarz soyut hiyerar\u015filer tan\u0131mlanamaz fakat substitution GO interfacelerinin \u00e7al\u0131\u015fma mant\u0131\u011f\u0131na \u00e7ok benzer. Interface \u00b6 Nesne y\u00f6nelimli programlamada \u00f6\u011frenilen y\u00f6ntemler GOya ta\u015f\u0131nmamal\u0131d\u0131r. Di\u011fer dillerden gelen yaz\u0131l\u0131mc\u0131lar interfaceleri genellikle a\u015fa\u011f\u0131daki \u015fekilde tan\u0131mlar. package rockband type Player interface { Play () } type BandMemeber struct {} func ( b BandMemeber ) Play (){ } package stage func Perform ( p Player ) { p . Play () } Bu tarz kullan\u0131mda Interface tan\u0131mlan\u0131r Interfacei kullanmak i\u00e7in tip tan\u0131mlan\u0131r Tan\u0131mlanan tiplerin interfacei implement eden metodlar\u0131 yaz\u0131l\u0131r Bu GO dilinde net bir \u015fekilde yanl\u0131\u015ft\u0131r \u00e7\u00fcnk\u00fc; interfacei uygulayacak ba\u015fka tipler olu\u015fmadan yani net bir nedenimiz olmadan tan\u0131mlad\u0131k. Daha ideali, \u00f6nce tipleri tan\u0131mlamak ve kullanmak. \u0130htiya\u00e7 duyulan yerde interfacelere ba\u015fvurmak olacakt\u0131r. package rockband type BandMemeber struct {} func ( b BandMemeber ) Play (){ } package stage type Player interface { Play () } func Perform ( p Player ) { p . Play () } Be conservative in what you send, be liberal in what you accept. Jon Postel Postel yasas\u0131n\u0131 GOya uyarlamak gerekirse. Fonksiyonlar parametre olarak interface almal\u0131, struct(belirli bir veri tipi) d\u00f6nmelidir. A great rule of thumb for Go is accept interfaces, return structs. Jack Lindamood Bununla birlikte fonksiyonlar\u0131n parametrelerinin de tamamen soyut olmamas\u0131nda fayda vard\u0131r. the empty interface says nothing Rob Pike Postel yasas\u0131n\u0131n \u00f6nemini test yazarken a\u00e7\u0131k \u015fekilde g\u00f6rebiliriz. Yukar\u0131daki fonksiyondaki Perform parametresinin belirli bir tip yerine interface olmas\u0131, bizi test yazarken ger\u00e7ek bir player objesi olu\u015fturmaktan kurtar\u0131r Open-Closed \u00b6 Software entities should be open for extension, but closed for modification. Bertrand Meyer package main import \"fmt\" type Cat struct { Name string } func ( c Cat ) Legs () int { return 4 } func ( c Cat ) PrintLegs () { fmt . Printf ( \"I have %d legs\\n\" , c . Legs ()) } type OctoCat struct { Cat } func ( o OctoCat ) Legs () int { return 5 } func main () { var octo OctoCat fmt . Println ( octo . Legs ()) // 5 octo . PrintLegs () // I have 4 legs } // source: https://dave.cheney.net/2016/08/20/solid-go-design Yukar\u0131daki \u00f6rnekte Cat tipi ve bu tipe ait ayak say\u0131s\u0131n\u0131 g\u00f6steren Legs metodu var. OctoCat tipine bu tipi g\u00f6md\u00fck ve Legs fonksiyonunu tan\u0131mlad\u0131k. Bu durumda OctoCat Legs metodundan 5 say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcyor ama PrintLegs metodu yine Legs metodunu kullanmas\u0131na ra\u011fmen 4 d\u00f6nd\u00fcr\u00fcyor. Bunun sebebi PrintLegs metodunun Cat tipi i\u00e7in tan\u0131mlanm\u0131\u015f olmas\u0131 ve receiver olarak Cati almas\u0131. Interface Segregation \u00b6 Clients should not be forced to depend on methods they do not use. Robert C. Martin Interface segregation, pek \u00e7ok davran\u0131\u015f i\u00e7eren b\u00fcy\u00fck veri yap\u0131lar\u0131 olu\u015fturmamam\u0131z\u0131 ve veri tipinin davran\u0131\u015f\u0131n\u0131 izole etmemizi s\u00f6yler. GO dilinde kompozisyon ve k\u00fc\u00e7\u00fck interface kullan\u0131mlar\u0131 benimsenir. Dependency Inversion \u00b6 High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. Robert C. Martin Bu prensibin GOda uygulamas\u0131n\u0131 paket seviyesinde g\u00f6rebiliriz. __ \u00d6nceki prensipler uyguland\u0131\u011f\u0131nda elimizde ama\u00e7lar\u0131 d\u00fczg\u00fcnce tan\u0131mlanm\u0131\u015f kod paketleri olacakt\u0131r. B\u00f6yle bir yap\u0131da kod i\u00e7indeki ba\u011f\u0131ml\u0131l\u0131klar\u0131n interfaceler ile tan\u0131mlanm\u0131\u015f olmas\u0131 ve bu interfacelerin sadece tan\u0131mlad\u0131klar\u0131 fonksiyonlarla alakal\u0131 olmas\u0131 gerekir. GOda importlar acyclic olmal\u0131d\u0131r. Yani A paketi B paketini import ediyorsa, B paketi A'y\u0131 import etmemelidir. __Bu ba\u011flamda Go projelerinin geni\u015f ve d\u00fcz \u015fekilde tasarlanmal\u0131d\u0131r. \u0130\u00e7 i\u00e7e paketler tan\u0131mlamaktan ka\u00e7\u0131n\u0131lmal\u0131d\u0131r. E\u011fer bir paketteki fonksiyon ba\u015fka bir paket olmadan d\u00fczg\u00fcn \u00e7al\u0131\u015fam\u0131yorsa; bu, projenin paket seviyesinde iyi \u015fekilde d\u00fczenlenmedi\u011fini g\u00f6sterir. Dependency inversion prensibi, projedeki as\u0131l i\u015flerin \u00fcst paketlerde, soyutlama/interface i\u015flerinin alt paketlere yapmaya te\u015fvik eder. Closure \u00b6 GO'nun sa\u011flad\u0131\u011f\u0131 interfaceler ve closurelar sayesinde \u00e7ok estetik ve kullan\u0131\u015fl\u0131 APIler yazabiliriz. Closure kendi g\u00f6vdesi d\u0131\u015f\u0131ndaki de\u011fi\u015fkenlere eri\u015fen fonksiyonlard\u0131r. Closure bir de\u011fi\u015fkene atan\u0131p istenildi\u011fi zaman \u00e7a\u011fr\u0131labilir veya ba\u015fka bir fonksiyona parametre olarak verilebilir. HTTP server olu\u015ftururken bu teknik s\u0131kl\u0131kla kullan\u0131l\u0131r. A\u015fa\u011f\u0131daki \u00f6rnekte home fonksiyonunu timed ile sarmalay\u0131p http.HandleFunc metoduna parametre olarak verdik. Bu da home/ end-pointine her istek geldi\u011finde, bu iste\u011fin i\u015flenme s\u00fcresini hesaplamam\u0131z\u0131 sa\u011flad\u0131. func main () { http . HandleFunc ( \"/hello\" , timed ( home )) http . ListenAndServe ( \":3000\" , nil ) } func timed ( f func ( http . ResponseWriter , * http . Request )) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { start := time . Now () f ( w , r ) end := time . Now () fmt . Println ( \"The request took\" , end . Sub ( start )) } } func home ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintln ( w , \"Home\" ) } GO kaynak kodlar\u0131nda da Closurelara bolca yer verilmi\u015ftir. {% embed url=\"https://github.com/golang/go/blob/4e215554aa0e76e534327b9e6721971b9e82c113/src/sort/sort.go#L307\" %} Concurrency \u00b6 Goroutineler her ne kadar boyutlar\u0131 k\u00fc\u00e7\u00fck ve \u00e7ok kullan\u0131\u015fl\u0131 yap\u0131lar olsa da ba\u011f\u0131ms\u0131z olmalar\u0131 kontrol edilmesi g\u00fc\u00e7 hatalara ve kod i\u00e7inde veri ak\u0131\u015f\u0131n\u0131n karma\u015f\u0131kla\u015fmas\u0131na yol a\u00e7makta. Bu y\u00fczden goroutinelerin \u00e7al\u0131\u015fma rutini API i\u00e7erisinde ve m\u00fcmk\u00fcn oldu\u011funca dar bir alanda tutulmal\u0131d\u0131r. Projede goroutine kullan\u0131lmaya karar verildi\u011finde race-conditionlar\u0131n \u00f6n\u00fcne ge\u00e7mek i\u00e7in \u00f6ncelikle kod senkron olarak tan\u0131mlanmal\u0131d\u0131r. Sonras\u0131nda, veri tipleri e\u015fzamanl\u0131 eri\u015fmeye kar\u015f\u0131 korunmal\u0131d\u0131r. Son olarak da korunan tipler goroutineler ile kullan\u0131lmal\u0131d\u0131r. make(chan struct{}) , sync.WaitGroup , context.Context and select yap\u0131lar\u0131 goroutineler s\u00f6z konusu oldu\u011funda s\u0131k\u00e7a kullan\u0131lmal\u0131 ve goroutinelerin \u00e7al\u0131\u015fma s\u00fcreci kontrol edilmelidir. \u0130deal \u00e7al\u0131\u015fma s\u00fcrecinde, goroutineler istenildi\u011fi zaman durdurulabilmeli. Ayr\u0131ca t\u00fcm sonu\u00e7lar gelene kadar goroutinelerin beklenmelidir. Ayn\u0131 WaitGroup ile farkl\u0131 tipte goroutineleri say\u0131lmamal\u0131d\u0131r. type Parent struct { wgFoo sync . WaitGroup wgBar sync . WaitGroup } func ( p * Parent ) foo () { defer p . wgFoo . Done () } func ( p * Parent ) bar () { defer p . wgBar . Done () } func ( p * Parent ) Go () { p . wgFoo . Add ( 1 ) go p . foo () p . wgBar . Add ( 1 ) go . bar () } Concurrency is a way of structuring your program to make it easy to understand and scaleable. Parallelism is simply the execution of goroutines in parallel. Channels \u00b6 Channel kullan\u0131c\u0131s\u0131 channeli keyfi kapatamamal\u0131d\u0131r. Daha \u00f6nce kapat\u0131lm\u0131\u015f bir channeli kapatmaya \u00e7al\u0131\u015fmak panic olu\u015fturacakt\u0131r. Channeller consumer ve producer olarak modellenmelidir. GO channellerin y\u00f6nlerini belirlememize olanak tan\u0131r. Bir i\u015fi da\u011f\u0131tmak i\u00e7in channelleri gerekti\u011finde s\u0131ral\u0131 halde i\u015flemek i\u00e7in mutexleri kullanmal\u0131y\u0131z. __ Yorumlama \u00b6 GO dilinde yorum sat\u0131rlar\u0131, yazd\u0131\u011f\u0131m\u0131z kodlar kadar \u00f6nemlidir. godoc arac\u0131 kaynak kodlardaki paketlerin d\u00f6k\u00fcmanlar\u0131 toplay\u0131p i\u015fler. Paketlerin, tiplerin, fonksiyonlar\u0131n ba\u015f\u0131na yaz\u0131lan yorum sat\u0131rlar\u0131, tan\u0131mlamalar\u0131 ile birlikte i\u015flenip o birim i\u015fin d\u00f6k\u00fcman olu\u015fturur. Yazd\u0131\u011f\u0131m\u0131z yorumlar\u0131n stili ve kalitesi godoc arac\u0131n\u0131n olu\u015fturaca\u011f\u0131 d\u00f6k\u00fcman\u0131 da etkiler. E\u011fer paket basitse a\u00e7\u0131klamas\u0131 k\u0131sa olabilir. // Package draw provides image composition functions. // package draw \u00c7ok yayg\u0131n kullan\u0131lacak bir kodu detayl\u0131ca a\u00e7\u0131klamam\u0131z gerekir. // The cap built-in function returns the capacity of v, according to its type: // Array: the number of elements in v (same as len(v)). // Pointer to array: the number of elements in *v (same as len(v)). // Slice: the maximum length the slice can reach when resliced; // if v is nil, cap(v) is zero. // Channel: the channel buffer capacity, in units of elements; // if v is nil, cap(v) is zero. // For some arguments, such as a simple array expression, the result can be a // constant. See the Go language specification's \"Length and capacity\" section for // details. func cap ( v Type ) int D\u00f6k\u00fcman \u00b6 Bir projenin anla\u015f\u0131l\u0131r ve s\u00fcrd\u00fcr\u00fclebilir olmas\u0131 i\u00e7in d\u00f6k\u00fcman \u00e7ok \u00f6nemlidir. D\u00f6k\u00fcmanlar\u0131n da t\u0131pk\u0131 iyi dizayn edilmi\u015f kodlar gibi, amac\u0131na uygun yaz\u0131lmas\u0131 gerekir. Ayn\u0131 zamanda d\u00f6k\u00fcmanlar\u0131n kolay yaz\u0131l\u0131p; d\u00fczenlenebilir olmas\u0131 gerekir. GO dilinde d\u00f6k\u00fcmanlar\u0131n kodla bir arada olmas\u0131 ve kodla birlikte geli\u015ftirilmesi uygun g\u00f6r\u00fcl\u00fcr. Bir go paketinde public olan her kod sat\u0131r\u0131 i\u00e7in mutlaka d\u00f6k\u00fcman yaz\u0131lmal\u0131d\u0131r. Paket i\u00e7inde kullan\u0131lan kodlar i\u00e7in de yazmak zaruri olmasa da projenin sa\u011fl\u0131\u011f\u0131 a\u00e7\u0131s\u0131ndan olduk\u00e7a faydal\u0131 olacakt\u0131r. E\u011fer go paketi birden fazla dosyadan olu\u015fuyorsa d\u00f6k\u00fcman doc.go ad\u0131ndaki ayr\u0131 bir dosyada tutulmal\u0131d\u0131r. D\u00f6k\u00fcman sat\u0131rlar\u0131 tam c\u00fcmleler halinde yaz\u0131lmal\u0131d\u0131r. \u0130lk c\u00fcmlenin ilk kelimesi paketin/tipin/fonksiyonun ismiyle ba\u015flamal\u0131d\u0131r. {% hint style=\"danger\" %} D\u00f6k\u00fcmanlar\u0131n i\u00e7eri\u011fi kodun nas\u0131l yaz\u0131ld\u0131\u011f\u0131, neleri kulland\u0131\u011f\u0131 ve nas\u0131l kulland\u0131\u011f\u0131 olmamal\u0131d\u0131r. Ayr\u0131ca kullan\u0131lmayan kodlar yorum sat\u0131r\u0131 olarak b\u0131rak\u0131lmamal\u0131d\u0131r. {% endhint %} // Ping the target server with a GET request func Ping ( url string , ch chan <- * Stat , waitGroup * sync . WaitGroup , logger * Log , sem chan bool ) { // ping start time start := time . Now () // make a get request to url resp , err := http . Get ( url ) if err != nil { log . Fatal ( err ) } // close the body regardless defer resp . Body . Close () // ping end time end := time . Now () // create a stat struct to hold the ping information stat := & Stat { start , end , url , resp . StatusCode , \"GET\" , resp . ContentLength } logger . AddStat ( * stat ) // extra := &Stat{} // send stat to channel ch <- stat // close semaphore sem <- true // wait for semaphore to be closed defer func () { <- sem }() // notify waitgroup waitGroup . Done () } {% hint style=\"success\" %} D\u00f6k\u00fcmanlar\u0131n i\u00e7eri\u011fi kodun neden yaz\u0131ld\u0131\u011f\u0131, i\u00e7eri\u011fi ve nas\u0131l kullan\u0131ld\u0131\u011f\u0131 olmal\u0131d\u0131r. {% endhint %} {% tabs %} {% tab title=\"ring_full\" %} // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Package ring implements operations on circular lists. package ring // A Ring is an element of a circular list, or ring. // Rings do not have a beginning or end; a pointer to any ring element // serves as reference to the entire ring. Empty rings are represented // as nil Ring pointers. The zero value for a Ring is a one-element // ring with a nil Value. // type Ring struct { next , prev * Ring Value interface {} // for use by client; untouched by this library } func ( r * Ring ) init () * Ring { r . next = r r . prev = r return r } // Next returns the next ring element. r must not be empty. func ( r * Ring ) Next () * Ring { if r . next == nil { return r . init () } return r . next } {% endtab %} {% tab title=\"ring_license\" %} // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. {% endtab %} {% tab title=\"ring_package_desc\" %} // Package ring implements operations on circular lists. package ring {% endtab %} {% tab title=\"ring_type_desc\" %} // A Ring is an element of a circular list, or ring. // Rings do not have a beginning or end; a pointer to any ring element // serves as reference to the entire ring. Empty rings are represented // as nil Ring pointers. The zero value for a Ring is a one-element // ring with a nil Value. // type Ring struct { next , prev * Ring Value interface {} // for use by client; untouched by this library } {% endtab %} {% tab title=\"ring_method_desc\" %} // Next returns the next ring element. r must not be empty. func ( r * Ring ) Next () * Ring { if r . next == nil { return r . init () } return r . next } {% endtab %} {% endtabs %} {% embed url=\"https://github.com/golang/go/blob/master/src/container/ring/ring.go\" %} \u0130simlendirme \u00b6 Paket \u00b6 Paketlerin isimleri belirlenirken paketin i\u00e7eri\u011fini an\u0131msatan isimler belirlenmelidir. Paket isimleri k\u0131sa, net, a\u00e7\u0131klay\u0131c\u0131, k\u00fc\u00e7\u00fck karakterlerle yaz\u0131lm\u0131\u015f tek bir kelime olmal\u0131d\u0131r. snake_case veya camelCase isimlere ihtiya\u00e7 yoktur. Paketlerin i\u00e7eri\u011finindeki isim \u00e7ak\u0131\u015fmalar\u0131 hakk\u0131nda endi\u015fe edilmemelidir. Paket isimleri, sadece paketler i\u00e7in belirlenen \u00f6n tan\u0131ml\u0131 isimdir ve proje genelinde tekil olmas\u0131na gerek yoktur. \u00c7ak\u0131\u015fma durumunda paketler farkl\u0131 bir isimle import edilebilirler. Kod Organizasyonu \u00b6 GO projelerinde network, veritaban\u0131 gibi i\u015fler i\u00e7in olu\u015fturulan paketler di\u011fer paketler taraf\u0131ndan kullan\u0131labilir fakat terminal komutu, http server ba\u015flatma gibi i\u015fleri y\u00f6neten paketler kendi ba\u015f\u0131na \u00e7al\u0131\u015f\u0131r. Proje yap\u0131s\u0131nda bu \u00f6ncelikle bu iki t\u00fcr\u00fc ay\u0131rmak faydal\u0131 olacakt\u0131r. Birbiriyle alakas\u0131z paketlerin birbirinden ba\u011f\u0131ms\u0131z olmas\u0131 gerekir. github.com/peterbourgon/foo/ circle.yml Dockerfile cmd/ foosrv/ main.go foocli/ main.go pkg/ fs/ fs.go fs_test.go mock.go mock_test.go merge/ merge.go merge_test.go api/ api.go api_test.go https://github.com/perkeep/perkeep Interface \u00b6 Tek metod i\u00e7eren interface isimleri genellikle method ismine -er eklenerek tan\u0131mlan\u0131r. \u00d6rne\u011fin Logger, Formatter. // Scanner is implemented by any value that has a Scan method, which scans // the input for the representation of a value and stores the result in the // receiver, which must be a pointer to be useful. The Scan method is called // for any argument to Scan, Scanf, or Scanln that implements it. type Scanner interface { Scan ( state ScanState , verb rune ) error } // Scanln is similar to Scan, but stops scanning at a newline and // after the final item there must be a newline or EOF. func Scanln ( a ... interface {}) ( n int , err error ) { return Fscanln ( os . Stdin , a ... ) } Fonksiyon \u00b6 Read , Write , Close , Flush , String vb. fonksiyonlar\u0131n \u00e7ok belirgin ve dil i\u00e7inde yayg\u0131n kullan\u0131mlar\u0131 vard\u0131r. Karma\u015f\u0131kl\u0131\u011f\u0131 \u00f6nlemek ad\u0131na kendi fonksiyonlar\u0131m\u0131za bu isimleri, ayn\u0131 i\u015fi, ayn\u0131 anlamda yapm\u0131yorsa, kullanmamam\u0131z gerekir. Eri\u015fim \u00b6 GO paketindeki yaln\u0131zca ba\u015f harfi b\u00fcy\u00fck yaz\u0131lm\u0131\u015f tiplere/de\u011fi\u015fkenlere/fonksiyonlara eri\u015filebilir. Bu y\u00f6ntem sayesinde paket i\u00e7in API belirleyebiliriz. GO paket i\u00e7indeki veri tipleri i\u00e7in do\u011frudan getter ve setter tan\u0131mlamaz fakat paket i\u00e7indeki bir veriye eri\u015fim i\u00e7in kendimiz getter/setter tan\u0131mlayabiliriz. Getter/setterler metodlar\u0131n isimlerinin Get veya Set ile ba\u015flamas\u0131na gerek yoktur. \u00d6rne\u011fin List ad\u0131ndaki bir tipin len alan\u0131na GetLen() veya GetLength() \u015fekinde de\u011fil Len() \u015feklinde eri\u015filmesi uygundur. // List represents a doubly linked list. // The zero value for List is an empty list ready to use. type List struct { root Element // sentinel list element, only &root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element } // Len returns the number of elements of list l. // The complexity is O(1). func ( l * List ) Len () int { return l . len } Error Handling \u00b6 GOda hata kontrolleri de normal yaz\u0131l\u0131m ak\u0131\u015f\u0131n\u0131n bir par\u00e7as\u0131d\u0131r. Bu y\u00fczden t\u00fcm hatalar d\u00fczg\u00fcnce kontrol edilmelidir. Hatalar _ de\u011fi\u015fkenine atan\u0131p g\u00f6rmezden gelinmemelidir. E\u011fer bir fonksiyon hata d\u00f6n\u00fcyorsa bu hata kontrol edilmeli ve fonksiyonun ba\u015far\u0131l\u0131 \u015fekilde \u00e7al\u0131\u015ft\u0131\u011f\u0131na emin olunmal\u0131d\u0131r. \u00c7ok nadir durumlar haricinde panic hata kontrol\u00fc i\u00e7in kullan\u0131lmamal\u0131d\u0131r. E\u011fer yazd\u0131\u011f\u0131m\u0131z fonksiyon i\u00e7inde bir hata olu\u015fabilecekse, bu hata d\u00f6n\u00fc\u015f de\u011feri olarak tan\u0131mlanmal\u0131d\u0131r. Indent Errors \u00b6 Normal kodlar minimum indentation ile yaz\u0131lmal\u0131d\u0131r. Normal \u00e7al\u0131\u015fma ak\u0131\u015f\u0131n\u0131n d\u0131\u015f\u0131ndaki durumlar(hatalar) kodun ba\u015f\u0131nda if ile kontrol edilip; fonksiyondan erkenden d\u00f6n\u00fclmelidir. Bu, yaz\u0131l\u0131mc\u0131n\u0131n fonksiyonun ak\u0131\u015f\u0131n\u0131 kavramas\u0131n\u0131 \u00f6nemli \u00f6l\u00e7\u00fcde art\u0131racakt\u0131r. if err != nil { // error handling } else { // normal code } if err != nil { // error handling return // or continue, etc. } // normal code D\u00f6n\u00fc\u015f de\u011feri kullan\u0131lacaksa bu if d\u0131\u015f\u0131nda yap\u0131lmal\u0131d\u0131r. if x , err := f (); err != nil { // error handling return } else { // use x } x , err := f () if err != nil { // error handling return } // use x Testing \u00b6 Test yazmak, geli\u015ftirme s\u00fcrecinin bir par\u00e7as\u0131 olmal\u0131d\u0131r. Testlerde piskolojik olarak minimum %80 total coverage ve tercihen %100 happy-path coverage hedeflenmelidir. D\u00fczg\u00fcn testi yaz\u0131lmam\u0131\u015f her kod silinip yeniden testleri ile birlikte yaz\u0131labilir. Monkey-patchingden m\u00fcmk\u00fcn oldu\u011funca ka\u00e7\u0131n\u0131lmal\u0131; 3. parti ba\u011f\u0131ml\u0131l\u0131klar\u0131 mocklamak i\u00e7in \u00f6nce temel y\u00f6ntemlere ba\u015fvurulmal\u0131d\u0131r.","title":"Best Practices"},{"location":"tr/best-practices/#best-practices","text":"A language that doesn\u2019t affect the way you think about programming is not worth knowing.\u200a\u2014\u200aAlan Perlis","title":"Best Practices"},{"location":"tr/best-practices/#genel-prensipler","text":"Keep it simple Don\u2019t Repeat Yourself You ain't gonna need it","title":"Genel Prensipler"},{"location":"tr/best-practices/#avoid-nesting","text":"\u0130yi GO kodu dilin kendi kodlar\u0131 gibidir. Standart olarak bu yaz\u0131m tercih edilmelidir. // Reset clears the state of the Writer z such that it is equivalent to its // initial state from NewWriterLevel or NewWriterLevelDict, but instead writing // to w. func ( z * Writer ) Reset ( w io . Writer ) { z . w = w // z.level and z.dict left unchanged. if z . compressor != nil { z . compressor . Reset ( w ) } if z . digest != nil { z . digest . Reset () } z . err = nil z . scratch = [ 4 ] byte {} z . wroteHeader = false } https://go-proverbs.github.io/","title":"Avoid Nesting"},{"location":"tr/best-practices/#kodlama","text":"","title":"Kodlama"},{"location":"tr/best-practices/#composition","text":"","title":"Composition"},{"location":"tr/best-practices/#fragile-base-class-problemi","text":"Fragile base class problemi nesne y\u00f6nelimli programlama sistemlerindeki temel bir mimari problemidir. Bu mimarilerde ana s\u0131n\u0131flar k\u0131r\u0131lgan kabul edilir. Bunun sebebi \u00fcst s\u0131n\u0131ftaki bir de\u011fi\u015fikli\u011fin alt s\u0131n\u0131flara da yans\u0131mas\u0131 ve alt s\u0131n\u0131flarda i\u015flev bozuklu\u011funa sebep olabilmesidir. Yaz\u0131l\u0131mc\u0131 bu t\u00fcr mimarilerde ana s\u0131n\u0131f\u0131n metodlar\u0131n\u0131 izole edemez ve bu nedenle ana s\u0131n\u0131fta yap\u0131lan de\u011fi\u015fikliklerin g\u00fcvenli olup olmad\u0131\u011f\u0131n\u0131ndan emin olamaz. Bu t\u00fcr dillerde kal\u0131t\u0131m yerine kompozisyon tercih edilmelidir. Kompleks ve hiyerar\u015fik yap\u0131lar kodun esnekli\u011fini kaybettirir. https://en.wikipedia.org/wiki/Composition_over_inheritance Kompozisyon y\u00f6nteminde ise bir s\u0131n\u0131f\u0131n di\u011ferinin t\u00fcm \u00f6zelliklerini miras almak yerine parametre olarak belli \u00f6zellikleri se\u00e7ilebilir. GO dilininin yaz\u0131l\u0131mc\u0131lar\u0131 kompozisyona itmesi en g\u00fc\u00e7l\u00fc \u00f6zelliklerinden birisidir.","title":"Fragile Base Class Problemi"},{"location":"tr/best-practices/#loose-coupling","text":"Yaz\u0131l\u0131m d\u00fcnyas\u0131nda, coupling iki birimin birbirine ne kadar ba\u011f\u0131ml\u0131 oldu\u011funun \u00f6l\u00e7\u00fcs\u00fcd\u00fcr. Par\u00e7alar\u0131n\u0131n birbirine s\u0131k\u0131 s\u0131k\u0131ya ba\u011fl\u0131 oldu\u011fu programlarda de\u011fi\u015fiklik yapmak \u00e7ok zordur. Bu duruma shotgun surgery efekti de denir. Shotgun surgery terimi, projenin bir k\u0131sm\u0131nda yap\u0131lan de\u011fi\u015fikli\u011fin di\u011fer k\u0131s\u0131mlar\u0131nda s\u0131ral\u0131 halde ufak de\u011fi\u015fikliklere yol a\u00e7mas\u0131d\u0131r. \u00d6rnek vermek gerekirse: type Booking struct { ID int Status string } type DB struct {} func ( d DB ) Booking ( ID int ) * Booking {} type Client struct {} func Cancel ( ID int ) error { db := DB {} if booking := db . Booking ( ID ); booking . Status == \"active\" { return errors . New ( \"booking does not exists\" ) } return nil } func Get ( ID int ) error { db := DB {} if booking := db . Booking ( ID ); booking . Status == \"active\" { return errors . New ( \"booking does not exists\" ) } return nil } Yukar\u0131daki kodda Bookinge ait methodlarda tek bir kontrol var. O da bookingin aktif olmas\u0131. Her metoda bu kontrol\u00fc ekleyerek code smell olu\u015fturduk. \u015eimdi \"active\" kontrol\u00fc de\u011fi\u015firse Bookinge ait t\u00fcm metodlarda de\u011fi\u015fiklik yapmak gerekecek. Bu s\u0131k\u0131nt\u0131y\u0131 gidermek i\u00e7in ilk ad\u0131m, kontrol k\u0131sm\u0131n\u0131 ayr\u0131 bir fonksiyonda tan\u0131mlayabiliriz. func validateBooking ( db * DB , ID int ) bool { if booking := db . Booking ( ID ); booking . Status == \"active\" { return true } return false } func Cancel ( ID int ) error { db := DB {} if isActive := validateBooking ( & db , ID ); isActive { return errors . New ( \"booking does not exists\" ) } return nil } func Get ( ID int ) error { db := DB {} if isActive := validateBooking ( & db , ID ); isActive { return errors . New ( \"booking does not exists\" ) } return nil } Do\u011frulamada bir de\u011fi\u015fiklik oldu\u011funda art\u0131k sadece validateBooking fonksiyonun de\u011fi\u015ftirilmesi yeterli.","title":"Loose Coupling"},{"location":"tr/best-practices/#single-responsibility","text":"Yukar\u0131daki kod par\u00e7as\u0131nda hala d\u00fczeltilmesi gereken k\u0131s\u0131mlar var. validateBooking fonksiyonu DB tipini do\u011frudan kullan\u0131yor. Bu hem tight coupling olu\u015fmas\u0131na hem de i\u015fi sadece bookinglerin durumunu kontrol etmek olan fonksiyonun veritaban\u0131na da eri\u015ferek birden fazla i\u015f yapmas\u0131na sebep oluyor. // booking.go type Booking struct { ID int Status string } func ( b Booking ) Validate () bool { if b . Status == \"active\" { return true } return false } // db.go type DB struct {} func ( d DB ) Get ( ID int ) * Booking { return nil } // client.go type Client struct {} func Cancel ( ID int ) error { db := DB {} booking := db . Get ( ID ) if booking . Validate () { return errors . New ( \"booking does not exists\" ) } return nil } func Get ( ID int ) error { db := DB {} booking := db . Get ( ID ) if booking . Validate () { return errors . New ( \"booking does not exists\" ) } return nil }","title":"Single Responsibility"},{"location":"tr/best-practices/#liskov-substitution","text":"Nesne y\u00f6nelimli dillerde liskov substitution prensibi; miras alan s\u0131n\u0131f\u0131n, \u00fcst s\u0131n\u0131f ile yer de\u011fi\u015ftirdi\u011fi zaman, ayn\u0131 davran\u0131\u015f\u0131 sergilemesi gerekti\u011fini s\u00f6yler. GOda bu tarz soyut hiyerar\u015filer tan\u0131mlanamaz fakat substitution GO interfacelerinin \u00e7al\u0131\u015fma mant\u0131\u011f\u0131na \u00e7ok benzer.","title":"Liskov Substitution"},{"location":"tr/best-practices/#interface","text":"Nesne y\u00f6nelimli programlamada \u00f6\u011frenilen y\u00f6ntemler GOya ta\u015f\u0131nmamal\u0131d\u0131r. Di\u011fer dillerden gelen yaz\u0131l\u0131mc\u0131lar interfaceleri genellikle a\u015fa\u011f\u0131daki \u015fekilde tan\u0131mlar. package rockband type Player interface { Play () } type BandMemeber struct {} func ( b BandMemeber ) Play (){ } package stage func Perform ( p Player ) { p . Play () } Bu tarz kullan\u0131mda Interface tan\u0131mlan\u0131r Interfacei kullanmak i\u00e7in tip tan\u0131mlan\u0131r Tan\u0131mlanan tiplerin interfacei implement eden metodlar\u0131 yaz\u0131l\u0131r Bu GO dilinde net bir \u015fekilde yanl\u0131\u015ft\u0131r \u00e7\u00fcnk\u00fc; interfacei uygulayacak ba\u015fka tipler olu\u015fmadan yani net bir nedenimiz olmadan tan\u0131mlad\u0131k. Daha ideali, \u00f6nce tipleri tan\u0131mlamak ve kullanmak. \u0130htiya\u00e7 duyulan yerde interfacelere ba\u015fvurmak olacakt\u0131r. package rockband type BandMemeber struct {} func ( b BandMemeber ) Play (){ } package stage type Player interface { Play () } func Perform ( p Player ) { p . Play () } Be conservative in what you send, be liberal in what you accept. Jon Postel Postel yasas\u0131n\u0131 GOya uyarlamak gerekirse. Fonksiyonlar parametre olarak interface almal\u0131, struct(belirli bir veri tipi) d\u00f6nmelidir. A great rule of thumb for Go is accept interfaces, return structs. Jack Lindamood Bununla birlikte fonksiyonlar\u0131n parametrelerinin de tamamen soyut olmamas\u0131nda fayda vard\u0131r. the empty interface says nothing Rob Pike Postel yasas\u0131n\u0131n \u00f6nemini test yazarken a\u00e7\u0131k \u015fekilde g\u00f6rebiliriz. Yukar\u0131daki fonksiyondaki Perform parametresinin belirli bir tip yerine interface olmas\u0131, bizi test yazarken ger\u00e7ek bir player objesi olu\u015fturmaktan kurtar\u0131r","title":"Interface"},{"location":"tr/best-practices/#open-closed","text":"Software entities should be open for extension, but closed for modification. Bertrand Meyer package main import \"fmt\" type Cat struct { Name string } func ( c Cat ) Legs () int { return 4 } func ( c Cat ) PrintLegs () { fmt . Printf ( \"I have %d legs\\n\" , c . Legs ()) } type OctoCat struct { Cat } func ( o OctoCat ) Legs () int { return 5 } func main () { var octo OctoCat fmt . Println ( octo . Legs ()) // 5 octo . PrintLegs () // I have 4 legs } // source: https://dave.cheney.net/2016/08/20/solid-go-design Yukar\u0131daki \u00f6rnekte Cat tipi ve bu tipe ait ayak say\u0131s\u0131n\u0131 g\u00f6steren Legs metodu var. OctoCat tipine bu tipi g\u00f6md\u00fck ve Legs fonksiyonunu tan\u0131mlad\u0131k. Bu durumda OctoCat Legs metodundan 5 say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcyor ama PrintLegs metodu yine Legs metodunu kullanmas\u0131na ra\u011fmen 4 d\u00f6nd\u00fcr\u00fcyor. Bunun sebebi PrintLegs metodunun Cat tipi i\u00e7in tan\u0131mlanm\u0131\u015f olmas\u0131 ve receiver olarak Cati almas\u0131.","title":"Open-Closed  "},{"location":"tr/best-practices/#interface-segregation","text":"Clients should not be forced to depend on methods they do not use. Robert C. Martin Interface segregation, pek \u00e7ok davran\u0131\u015f i\u00e7eren b\u00fcy\u00fck veri yap\u0131lar\u0131 olu\u015fturmamam\u0131z\u0131 ve veri tipinin davran\u0131\u015f\u0131n\u0131 izole etmemizi s\u00f6yler. GO dilinde kompozisyon ve k\u00fc\u00e7\u00fck interface kullan\u0131mlar\u0131 benimsenir.","title":"Interface Segregation"},{"location":"tr/best-practices/#dependency-inversion","text":"High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. Robert C. Martin Bu prensibin GOda uygulamas\u0131n\u0131 paket seviyesinde g\u00f6rebiliriz. __ \u00d6nceki prensipler uyguland\u0131\u011f\u0131nda elimizde ama\u00e7lar\u0131 d\u00fczg\u00fcnce tan\u0131mlanm\u0131\u015f kod paketleri olacakt\u0131r. B\u00f6yle bir yap\u0131da kod i\u00e7indeki ba\u011f\u0131ml\u0131l\u0131klar\u0131n interfaceler ile tan\u0131mlanm\u0131\u015f olmas\u0131 ve bu interfacelerin sadece tan\u0131mlad\u0131klar\u0131 fonksiyonlarla alakal\u0131 olmas\u0131 gerekir. GOda importlar acyclic olmal\u0131d\u0131r. Yani A paketi B paketini import ediyorsa, B paketi A'y\u0131 import etmemelidir. __Bu ba\u011flamda Go projelerinin geni\u015f ve d\u00fcz \u015fekilde tasarlanmal\u0131d\u0131r. \u0130\u00e7 i\u00e7e paketler tan\u0131mlamaktan ka\u00e7\u0131n\u0131lmal\u0131d\u0131r. E\u011fer bir paketteki fonksiyon ba\u015fka bir paket olmadan d\u00fczg\u00fcn \u00e7al\u0131\u015fam\u0131yorsa; bu, projenin paket seviyesinde iyi \u015fekilde d\u00fczenlenmedi\u011fini g\u00f6sterir. Dependency inversion prensibi, projedeki as\u0131l i\u015flerin \u00fcst paketlerde, soyutlama/interface i\u015flerinin alt paketlere yapmaya te\u015fvik eder.","title":"Dependency Inversion"},{"location":"tr/best-practices/#closure","text":"GO'nun sa\u011flad\u0131\u011f\u0131 interfaceler ve closurelar sayesinde \u00e7ok estetik ve kullan\u0131\u015fl\u0131 APIler yazabiliriz. Closure kendi g\u00f6vdesi d\u0131\u015f\u0131ndaki de\u011fi\u015fkenlere eri\u015fen fonksiyonlard\u0131r. Closure bir de\u011fi\u015fkene atan\u0131p istenildi\u011fi zaman \u00e7a\u011fr\u0131labilir veya ba\u015fka bir fonksiyona parametre olarak verilebilir. HTTP server olu\u015ftururken bu teknik s\u0131kl\u0131kla kullan\u0131l\u0131r. A\u015fa\u011f\u0131daki \u00f6rnekte home fonksiyonunu timed ile sarmalay\u0131p http.HandleFunc metoduna parametre olarak verdik. Bu da home/ end-pointine her istek geldi\u011finde, bu iste\u011fin i\u015flenme s\u00fcresini hesaplamam\u0131z\u0131 sa\u011flad\u0131. func main () { http . HandleFunc ( \"/hello\" , timed ( home )) http . ListenAndServe ( \":3000\" , nil ) } func timed ( f func ( http . ResponseWriter , * http . Request )) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { start := time . Now () f ( w , r ) end := time . Now () fmt . Println ( \"The request took\" , end . Sub ( start )) } } func home ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintln ( w , \"Home\" ) } GO kaynak kodlar\u0131nda da Closurelara bolca yer verilmi\u015ftir. {% embed url=\"https://github.com/golang/go/blob/4e215554aa0e76e534327b9e6721971b9e82c113/src/sort/sort.go#L307\" %}","title":"Closure"},{"location":"tr/best-practices/#concurrency","text":"Goroutineler her ne kadar boyutlar\u0131 k\u00fc\u00e7\u00fck ve \u00e7ok kullan\u0131\u015fl\u0131 yap\u0131lar olsa da ba\u011f\u0131ms\u0131z olmalar\u0131 kontrol edilmesi g\u00fc\u00e7 hatalara ve kod i\u00e7inde veri ak\u0131\u015f\u0131n\u0131n karma\u015f\u0131kla\u015fmas\u0131na yol a\u00e7makta. Bu y\u00fczden goroutinelerin \u00e7al\u0131\u015fma rutini API i\u00e7erisinde ve m\u00fcmk\u00fcn oldu\u011funca dar bir alanda tutulmal\u0131d\u0131r. Projede goroutine kullan\u0131lmaya karar verildi\u011finde race-conditionlar\u0131n \u00f6n\u00fcne ge\u00e7mek i\u00e7in \u00f6ncelikle kod senkron olarak tan\u0131mlanmal\u0131d\u0131r. Sonras\u0131nda, veri tipleri e\u015fzamanl\u0131 eri\u015fmeye kar\u015f\u0131 korunmal\u0131d\u0131r. Son olarak da korunan tipler goroutineler ile kullan\u0131lmal\u0131d\u0131r. make(chan struct{}) , sync.WaitGroup , context.Context and select yap\u0131lar\u0131 goroutineler s\u00f6z konusu oldu\u011funda s\u0131k\u00e7a kullan\u0131lmal\u0131 ve goroutinelerin \u00e7al\u0131\u015fma s\u00fcreci kontrol edilmelidir. \u0130deal \u00e7al\u0131\u015fma s\u00fcrecinde, goroutineler istenildi\u011fi zaman durdurulabilmeli. Ayr\u0131ca t\u00fcm sonu\u00e7lar gelene kadar goroutinelerin beklenmelidir. Ayn\u0131 WaitGroup ile farkl\u0131 tipte goroutineleri say\u0131lmamal\u0131d\u0131r. type Parent struct { wgFoo sync . WaitGroup wgBar sync . WaitGroup } func ( p * Parent ) foo () { defer p . wgFoo . Done () } func ( p * Parent ) bar () { defer p . wgBar . Done () } func ( p * Parent ) Go () { p . wgFoo . Add ( 1 ) go p . foo () p . wgBar . Add ( 1 ) go . bar () } Concurrency is a way of structuring your program to make it easy to understand and scaleable. Parallelism is simply the execution of goroutines in parallel.","title":"Concurrency"},{"location":"tr/best-practices/#channels","text":"Channel kullan\u0131c\u0131s\u0131 channeli keyfi kapatamamal\u0131d\u0131r. Daha \u00f6nce kapat\u0131lm\u0131\u015f bir channeli kapatmaya \u00e7al\u0131\u015fmak panic olu\u015fturacakt\u0131r. Channeller consumer ve producer olarak modellenmelidir. GO channellerin y\u00f6nlerini belirlememize olanak tan\u0131r. Bir i\u015fi da\u011f\u0131tmak i\u00e7in channelleri gerekti\u011finde s\u0131ral\u0131 halde i\u015flemek i\u00e7in mutexleri kullanmal\u0131y\u0131z. __","title":"Channels"},{"location":"tr/best-practices/#yorumlama","text":"GO dilinde yorum sat\u0131rlar\u0131, yazd\u0131\u011f\u0131m\u0131z kodlar kadar \u00f6nemlidir. godoc arac\u0131 kaynak kodlardaki paketlerin d\u00f6k\u00fcmanlar\u0131 toplay\u0131p i\u015fler. Paketlerin, tiplerin, fonksiyonlar\u0131n ba\u015f\u0131na yaz\u0131lan yorum sat\u0131rlar\u0131, tan\u0131mlamalar\u0131 ile birlikte i\u015flenip o birim i\u015fin d\u00f6k\u00fcman olu\u015fturur. Yazd\u0131\u011f\u0131m\u0131z yorumlar\u0131n stili ve kalitesi godoc arac\u0131n\u0131n olu\u015fturaca\u011f\u0131 d\u00f6k\u00fcman\u0131 da etkiler. E\u011fer paket basitse a\u00e7\u0131klamas\u0131 k\u0131sa olabilir. // Package draw provides image composition functions. // package draw \u00c7ok yayg\u0131n kullan\u0131lacak bir kodu detayl\u0131ca a\u00e7\u0131klamam\u0131z gerekir. // The cap built-in function returns the capacity of v, according to its type: // Array: the number of elements in v (same as len(v)). // Pointer to array: the number of elements in *v (same as len(v)). // Slice: the maximum length the slice can reach when resliced; // if v is nil, cap(v) is zero. // Channel: the channel buffer capacity, in units of elements; // if v is nil, cap(v) is zero. // For some arguments, such as a simple array expression, the result can be a // constant. See the Go language specification's \"Length and capacity\" section for // details. func cap ( v Type ) int","title":"Yorumlama"},{"location":"tr/best-practices/#dokuman","text":"Bir projenin anla\u015f\u0131l\u0131r ve s\u00fcrd\u00fcr\u00fclebilir olmas\u0131 i\u00e7in d\u00f6k\u00fcman \u00e7ok \u00f6nemlidir. D\u00f6k\u00fcmanlar\u0131n da t\u0131pk\u0131 iyi dizayn edilmi\u015f kodlar gibi, amac\u0131na uygun yaz\u0131lmas\u0131 gerekir. Ayn\u0131 zamanda d\u00f6k\u00fcmanlar\u0131n kolay yaz\u0131l\u0131p; d\u00fczenlenebilir olmas\u0131 gerekir. GO dilinde d\u00f6k\u00fcmanlar\u0131n kodla bir arada olmas\u0131 ve kodla birlikte geli\u015ftirilmesi uygun g\u00f6r\u00fcl\u00fcr. Bir go paketinde public olan her kod sat\u0131r\u0131 i\u00e7in mutlaka d\u00f6k\u00fcman yaz\u0131lmal\u0131d\u0131r. Paket i\u00e7inde kullan\u0131lan kodlar i\u00e7in de yazmak zaruri olmasa da projenin sa\u011fl\u0131\u011f\u0131 a\u00e7\u0131s\u0131ndan olduk\u00e7a faydal\u0131 olacakt\u0131r. E\u011fer go paketi birden fazla dosyadan olu\u015fuyorsa d\u00f6k\u00fcman doc.go ad\u0131ndaki ayr\u0131 bir dosyada tutulmal\u0131d\u0131r. D\u00f6k\u00fcman sat\u0131rlar\u0131 tam c\u00fcmleler halinde yaz\u0131lmal\u0131d\u0131r. \u0130lk c\u00fcmlenin ilk kelimesi paketin/tipin/fonksiyonun ismiyle ba\u015flamal\u0131d\u0131r. {% hint style=\"danger\" %} D\u00f6k\u00fcmanlar\u0131n i\u00e7eri\u011fi kodun nas\u0131l yaz\u0131ld\u0131\u011f\u0131, neleri kulland\u0131\u011f\u0131 ve nas\u0131l kulland\u0131\u011f\u0131 olmamal\u0131d\u0131r. Ayr\u0131ca kullan\u0131lmayan kodlar yorum sat\u0131r\u0131 olarak b\u0131rak\u0131lmamal\u0131d\u0131r. {% endhint %} // Ping the target server with a GET request func Ping ( url string , ch chan <- * Stat , waitGroup * sync . WaitGroup , logger * Log , sem chan bool ) { // ping start time start := time . Now () // make a get request to url resp , err := http . Get ( url ) if err != nil { log . Fatal ( err ) } // close the body regardless defer resp . Body . Close () // ping end time end := time . Now () // create a stat struct to hold the ping information stat := & Stat { start , end , url , resp . StatusCode , \"GET\" , resp . ContentLength } logger . AddStat ( * stat ) // extra := &Stat{} // send stat to channel ch <- stat // close semaphore sem <- true // wait for semaphore to be closed defer func () { <- sem }() // notify waitgroup waitGroup . Done () } {% hint style=\"success\" %} D\u00f6k\u00fcmanlar\u0131n i\u00e7eri\u011fi kodun neden yaz\u0131ld\u0131\u011f\u0131, i\u00e7eri\u011fi ve nas\u0131l kullan\u0131ld\u0131\u011f\u0131 olmal\u0131d\u0131r. {% endhint %} {% tabs %} {% tab title=\"ring_full\" %} // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Package ring implements operations on circular lists. package ring // A Ring is an element of a circular list, or ring. // Rings do not have a beginning or end; a pointer to any ring element // serves as reference to the entire ring. Empty rings are represented // as nil Ring pointers. The zero value for a Ring is a one-element // ring with a nil Value. // type Ring struct { next , prev * Ring Value interface {} // for use by client; untouched by this library } func ( r * Ring ) init () * Ring { r . next = r r . prev = r return r } // Next returns the next ring element. r must not be empty. func ( r * Ring ) Next () * Ring { if r . next == nil { return r . init () } return r . next } {% endtab %} {% tab title=\"ring_license\" %} // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. {% endtab %} {% tab title=\"ring_package_desc\" %} // Package ring implements operations on circular lists. package ring {% endtab %} {% tab title=\"ring_type_desc\" %} // A Ring is an element of a circular list, or ring. // Rings do not have a beginning or end; a pointer to any ring element // serves as reference to the entire ring. Empty rings are represented // as nil Ring pointers. The zero value for a Ring is a one-element // ring with a nil Value. // type Ring struct { next , prev * Ring Value interface {} // for use by client; untouched by this library } {% endtab %} {% tab title=\"ring_method_desc\" %} // Next returns the next ring element. r must not be empty. func ( r * Ring ) Next () * Ring { if r . next == nil { return r . init () } return r . next } {% endtab %} {% endtabs %} {% embed url=\"https://github.com/golang/go/blob/master/src/container/ring/ring.go\" %}","title":"D\u00f6k\u00fcman"},{"location":"tr/best-practices/#isimlendirme","text":"","title":"\u0130simlendirme"},{"location":"tr/best-practices/#paket","text":"Paketlerin isimleri belirlenirken paketin i\u00e7eri\u011fini an\u0131msatan isimler belirlenmelidir. Paket isimleri k\u0131sa, net, a\u00e7\u0131klay\u0131c\u0131, k\u00fc\u00e7\u00fck karakterlerle yaz\u0131lm\u0131\u015f tek bir kelime olmal\u0131d\u0131r. snake_case veya camelCase isimlere ihtiya\u00e7 yoktur. Paketlerin i\u00e7eri\u011finindeki isim \u00e7ak\u0131\u015fmalar\u0131 hakk\u0131nda endi\u015fe edilmemelidir. Paket isimleri, sadece paketler i\u00e7in belirlenen \u00f6n tan\u0131ml\u0131 isimdir ve proje genelinde tekil olmas\u0131na gerek yoktur. \u00c7ak\u0131\u015fma durumunda paketler farkl\u0131 bir isimle import edilebilirler.","title":"Paket"},{"location":"tr/best-practices/#kod-organizasyonu","text":"GO projelerinde network, veritaban\u0131 gibi i\u015fler i\u00e7in olu\u015fturulan paketler di\u011fer paketler taraf\u0131ndan kullan\u0131labilir fakat terminal komutu, http server ba\u015flatma gibi i\u015fleri y\u00f6neten paketler kendi ba\u015f\u0131na \u00e7al\u0131\u015f\u0131r. Proje yap\u0131s\u0131nda bu \u00f6ncelikle bu iki t\u00fcr\u00fc ay\u0131rmak faydal\u0131 olacakt\u0131r. Birbiriyle alakas\u0131z paketlerin birbirinden ba\u011f\u0131ms\u0131z olmas\u0131 gerekir. github.com/peterbourgon/foo/ circle.yml Dockerfile cmd/ foosrv/ main.go foocli/ main.go pkg/ fs/ fs.go fs_test.go mock.go mock_test.go merge/ merge.go merge_test.go api/ api.go api_test.go https://github.com/perkeep/perkeep","title":"Kod Organizasyonu"},{"location":"tr/best-practices/#interface_1","text":"Tek metod i\u00e7eren interface isimleri genellikle method ismine -er eklenerek tan\u0131mlan\u0131r. \u00d6rne\u011fin Logger, Formatter. // Scanner is implemented by any value that has a Scan method, which scans // the input for the representation of a value and stores the result in the // receiver, which must be a pointer to be useful. The Scan method is called // for any argument to Scan, Scanf, or Scanln that implements it. type Scanner interface { Scan ( state ScanState , verb rune ) error } // Scanln is similar to Scan, but stops scanning at a newline and // after the final item there must be a newline or EOF. func Scanln ( a ... interface {}) ( n int , err error ) { return Fscanln ( os . Stdin , a ... ) }","title":"Interface"},{"location":"tr/best-practices/#fonksiyon","text":"Read , Write , Close , Flush , String vb. fonksiyonlar\u0131n \u00e7ok belirgin ve dil i\u00e7inde yayg\u0131n kullan\u0131mlar\u0131 vard\u0131r. Karma\u015f\u0131kl\u0131\u011f\u0131 \u00f6nlemek ad\u0131na kendi fonksiyonlar\u0131m\u0131za bu isimleri, ayn\u0131 i\u015fi, ayn\u0131 anlamda yapm\u0131yorsa, kullanmamam\u0131z gerekir.","title":"Fonksiyon"},{"location":"tr/best-practices/#erisim","text":"GO paketindeki yaln\u0131zca ba\u015f harfi b\u00fcy\u00fck yaz\u0131lm\u0131\u015f tiplere/de\u011fi\u015fkenlere/fonksiyonlara eri\u015filebilir. Bu y\u00f6ntem sayesinde paket i\u00e7in API belirleyebiliriz. GO paket i\u00e7indeki veri tipleri i\u00e7in do\u011frudan getter ve setter tan\u0131mlamaz fakat paket i\u00e7indeki bir veriye eri\u015fim i\u00e7in kendimiz getter/setter tan\u0131mlayabiliriz. Getter/setterler metodlar\u0131n isimlerinin Get veya Set ile ba\u015flamas\u0131na gerek yoktur. \u00d6rne\u011fin List ad\u0131ndaki bir tipin len alan\u0131na GetLen() veya GetLength() \u015fekinde de\u011fil Len() \u015feklinde eri\u015filmesi uygundur. // List represents a doubly linked list. // The zero value for List is an empty list ready to use. type List struct { root Element // sentinel list element, only &root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element } // Len returns the number of elements of list l. // The complexity is O(1). func ( l * List ) Len () int { return l . len }","title":"Eri\u015fim"},{"location":"tr/best-practices/#error-handling","text":"GOda hata kontrolleri de normal yaz\u0131l\u0131m ak\u0131\u015f\u0131n\u0131n bir par\u00e7as\u0131d\u0131r. Bu y\u00fczden t\u00fcm hatalar d\u00fczg\u00fcnce kontrol edilmelidir. Hatalar _ de\u011fi\u015fkenine atan\u0131p g\u00f6rmezden gelinmemelidir. E\u011fer bir fonksiyon hata d\u00f6n\u00fcyorsa bu hata kontrol edilmeli ve fonksiyonun ba\u015far\u0131l\u0131 \u015fekilde \u00e7al\u0131\u015ft\u0131\u011f\u0131na emin olunmal\u0131d\u0131r. \u00c7ok nadir durumlar haricinde panic hata kontrol\u00fc i\u00e7in kullan\u0131lmamal\u0131d\u0131r. E\u011fer yazd\u0131\u011f\u0131m\u0131z fonksiyon i\u00e7inde bir hata olu\u015fabilecekse, bu hata d\u00f6n\u00fc\u015f de\u011feri olarak tan\u0131mlanmal\u0131d\u0131r.","title":"Error Handling"},{"location":"tr/best-practices/#indent-errors","text":"Normal kodlar minimum indentation ile yaz\u0131lmal\u0131d\u0131r. Normal \u00e7al\u0131\u015fma ak\u0131\u015f\u0131n\u0131n d\u0131\u015f\u0131ndaki durumlar(hatalar) kodun ba\u015f\u0131nda if ile kontrol edilip; fonksiyondan erkenden d\u00f6n\u00fclmelidir. Bu, yaz\u0131l\u0131mc\u0131n\u0131n fonksiyonun ak\u0131\u015f\u0131n\u0131 kavramas\u0131n\u0131 \u00f6nemli \u00f6l\u00e7\u00fcde art\u0131racakt\u0131r. if err != nil { // error handling } else { // normal code } if err != nil { // error handling return // or continue, etc. } // normal code D\u00f6n\u00fc\u015f de\u011feri kullan\u0131lacaksa bu if d\u0131\u015f\u0131nda yap\u0131lmal\u0131d\u0131r. if x , err := f (); err != nil { // error handling return } else { // use x } x , err := f () if err != nil { // error handling return } // use x","title":"Indent Errors"},{"location":"tr/best-practices/#testing","text":"Test yazmak, geli\u015ftirme s\u00fcrecinin bir par\u00e7as\u0131 olmal\u0131d\u0131r. Testlerde piskolojik olarak minimum %80 total coverage ve tercihen %100 happy-path coverage hedeflenmelidir. D\u00fczg\u00fcn testi yaz\u0131lmam\u0131\u015f her kod silinip yeniden testleri ile birlikte yaz\u0131labilir. Monkey-patchingden m\u00fcmk\u00fcn oldu\u011funca ka\u00e7\u0131n\u0131lmal\u0131; 3. parti ba\u011f\u0131ml\u0131l\u0131klar\u0131 mocklamak i\u00e7in \u00f6nce temel y\u00f6ntemlere ba\u015fvurulmal\u0131d\u0131r.","title":"Testing"},{"location":"tr/concurrency/","text":"Concurrency \u00b6 English | T\u00fcrk\u00e7e Bilgisayar biliminde concurrency(e\u015fzamanl\u0131l\u0131k), bir programdaki i\u015f birimlerinin veya algoritmalar\u0131n sonucu etkilemeyecek \u015fekilde s\u0131ras\u0131z bir bi\u00e7imde \u00e7al\u0131\u015ft\u0131r\u0131labilmesidir. \u0130\u015f par\u00e7alar\u0131n\u0131 birbirinden ba\u011f\u0131ms\u0131z \u00e7al\u0131\u015ft\u0131rabilmemiz, s\u00fcre\u00e7leri farkl\u0131 \u00e7ekirdeklerde y\u00fcr\u00fcterek, i\u015flemciyi maksimum verimde kullanmam\u0131z\u0131 sa\u011flar. GO dilinde concurrency goroutineler ile sa\u011flan\u0131r. Goroutines \u00b6 GO routineleri bir kuyrukta \u00e7al\u0131\u015ft\u0131r\u0131lmay\u0131 bekleyen boyutlar\u0131 k\u00fc\u00e7\u00fck threadler olarak d\u00fc\u015f\u00fcn\u00fclebilir. Bir fonksiyonu goroutine olarak \u00e7al\u0131\u015ft\u0131rmak i\u00e7in \u00e7a\u011f\u0131r\u0131rken ba\u015f\u0131na go yazmam\u0131z yeterli. A\u015fa\u011f\u0131daki uygulamada Work fonksiyonu her \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, \u00e7al\u0131\u015fmas\u0131 bitene kadar uygulamay\u0131 blokluyor. func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { Work ( \"work work work work work work...\" ) Work ( \"zxcasfv\" ) } Bloklayan k\u0131s\u0131mlar\u0131 goroutine olarak \u00e7al\u0131\u015ft\u0131ral\u0131m. func main () { go Work ( \"work work work work work work...\" ) go Work ( \"zxcasfv\" ) } Program\u0131 \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda ekrana hi\u00e7bir \u015fey yazd\u0131rmadan sonlanacak. main fonksiyonu, Work fonksiyonu hen\u00fcz ekrana bir \u015feyler yazacak kadar \u00e7al\u0131\u015fmadan, bitiyor ve program kapan\u0131yor. Program bitmeden \u00f6nce biraz bekleterek Work fonksiyonunun \u00e7\u0131kt\u0131s\u0131n\u0131 alabiliriz. package main import ( \"fmt\" \"time\" ) func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { go Work ( \"work work work work work work...\" ) go Work ( \"zxcasfv\" ) time . Sleep ( time . Second * 3 ) } waitGroup \u00b6 Uygulaman\u0131n bir an\u0131nda baz\u0131 goroutinelerin bitmesini beklememiz gerekebilir. WaitGroup ile ka\u00e7 tane gorouitine bekleyece\u011fimizi \u00f6ncesindem belirtip bu goroutinelerin i\u015flerini bitirmelerini bekleyebiliriz. Goroutinelerin burada tek yapmas\u0131 gereken, i\u015fi bitti\u011finde WaitGroup'un Done() methodunu \u00e7al\u0131\u015ft\u0131rmas\u0131. func Work ( msg string , wg * sync . WaitGroup ) { time . Sleep ( time . Second * 2 ) fmt . Println ( msg ) wg . Done () } func main () { nWorkers := 5 wg := & sync . WaitGroup {} wg . Add ( nWorkers ) for i := 0 ; i < nWorkers ; i ++ { go Work ( \"work\" , wg ) } wg . Wait () } Kanalllar (Channels) \u00b6 Kanallar goroutinelerin birbirleri ile haberle\u015fmesini sa\u011flar. Yukar\u0131daki \u00f6rnekte go ile \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131z fonksiyonlardan d\u00f6n\u00fc\u015f de\u011feri alam\u0131yoruz. Kanallar\u0131 kullanarak bir goroutiniin, ana fonksiyonla veya ba\u015fka bir goroutine ile haberle\u015fmesini sa\u011flayabiliriz. Kanallar make(chan veritipi, buffer) \u015feklinde olu\u015fturulabilir. func Work ( msg string , ch chan string ) { time . Sleep ( time . Second * 2 ) ch <- msg } func main () { channel := make ( chan string ) go Work ( \"work-1\" , channel ) go Work ( \"work-2\" , channel ) for i := 0 ; i < 2 ; i ++ { msg := <- channel fmt . Println ( msg ) } } Mutex \u00b6 Mutex, goroutineler taraf\u0131ndan ortak kullan\u0131lan bir de\u011fi\u015fkenin de\u011ferininin, race-condition olu\u015fmadan de\u011fi\u015ftirilebilmesini sa\u011flayan yap\u0131d\u0131r. Wikipedia Tan\u0131m\u0131 In computer science, mutual exclusion is a property of concurrency control, which is instituted for the purpose of preventing race conditions. It is the requirement that one thread of execution never enters its critical section at the same time that another concurrent thread of execution enters its own critical section, which refers to an interval of time during which a thread of execution accesses a shared resource, such as shared memory. A\u015fa\u011f\u0131daki \u00f6rnekte, kullan\u0131c\u0131 t\u0131klamalar\u0131n\u0131 saymak i\u00e7in Counter yap\u0131s\u0131n\u0131 kullan\u0131yoruz. type Counter struct { Value int } func ( c * Counter ) Inc () { c . Value ++ } func Click ( c * Counter , wg * sync . WaitGroup ) { c . Inc () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) counter := & Counter {} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter . Value ) } \u0130lk bak\u0131\u015fta programda yanl\u0131\u015f bir \u015fey g\u00f6z\u00fckm\u00fcyor. Fakat program\u0131 --race parametresi ile derleyip \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda; bize programda race-condition oldu\u011funu s\u00f6yl\u00fcyor. Bu program \u00e7ok \u00e7ekirdekli bir bilgisayarda \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda, Click fonksiyonu farkl\u0131 \u00e7ekirdeklerde ayn\u0131 anda \u00e7al\u0131\u015ft\u0131r\u0131labiliyor. Bu nedenle program yeni c.Value de\u011ferini yanl\u0131\u015f g\u00fcncelliyor. Bu hatay\u0131 main fonksiyonu i\u00e7inde bir Mutex olu\u015fturup; mx.Lock ve mx.Unlock metodlar\u0131n\u0131 Value de\u011ferini de\u011fi\u015ftirdi\u011fimiz yerde kullanarak giderebiliriz. func Click ( c * Counter , wg * sync . WaitGroup , mx * sync . Mutex ) { mx . Lock () c . Inc () mx . Unlock () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) mx := & sync . Mutex {} counter := & Counter {} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg , mx ) } wg . Wait () fmt . Println ( counter . Value ) } Mutexlerin struct i\u00e7erisinde tan\u0131mlanmas\u0131 da yayg\u0131n bir kullan\u0131md\u0131r. Bu \u00f6rnekte, Mutexi, Counter i\u00e7inde tan\u0131mlay\u0131p c.Lock ve c.Unlock metodlar\u0131 ile yine problemi \u00e7\u00f6zebilirdik. type Counter struct { Value int * sync . Mutex } func ( c * Counter ) Inc () { c . Value ++ } func Click ( c * Counter , wg * sync . WaitGroup ) { c . Lock () c . Inc () c . Unlock () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) counter := & Counter { Mutex : & sync . Mutex {}} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter . Value ) } Select \u00b6 Kanallara veri g\u00f6ndermek veya kanallardan veri beklemek uygulamay\u0131 bloklar. Select ayn\u0131 anda birka\u00e7 tane kanal\u0131 beklememize olanak sa\u011flar. A\u015fa\u011f\u0131daki \u00f6rnekte 2 goroutine chan1 ve chan2 kanallar\u0131na s\u00fcrekli veri g\u00f6nderiyor. \u0130ki kanaldan da gelen t\u00fcm verileri sonsuz bir d\u00f6ng\u00fc i\u00e7indeki select yap\u0131s\u0131 ile alabiliriz. Herhangi bir kanaldan mesaj geldi\u011finde select o kanal\u0131 bekleyen case e girecek ve i\u00e7inde tan\u0131mlanan i\u015flemler bittikten sonra d\u00f6ng\u00fc, kanal bekleme i\u015flemini tekrarlayacakt\u0131r. func Work ( ch1 chan string , ch2 chan string ) { // Send data to ch1 every second go func () { for { time . Sleep ( 1 * time . Second ) ch1 <- \"work-1\" } }() // Send data to ch2 every 1.5 seconds go func () { for { time . Sleep ( 1.5 * time . Second ) ch2 <- \"work-2\" } }() } func main () { ch1 := make ( chan string ) ch2 := make ( chan string ) go Work ( ch1 , ch2 ) for { select { case msg1 := <- ch1 : fmt . Println ( msg1 ) case msg2 := <- ch2 : fmt . Println ( msg2 ) } } } Zaman A\u015f\u0131m\u0131 \u00b6 Yukar\u0131daki gibi bir program 2 kanaldan da hi\u00e7 veri gelmezse kilitlenecektir. Sonsuz d\u00f6ng\u00fc i\u00e7erisinde, bitece\u011fine emin oldu\u011fumuz ba\u015fka bir kanal\u0131 daha dinleyerek k\u0131rabiliriz. Go, bu t\u00fcr durumlar i\u00e7in \u00f6nceden tan\u0131mlanm\u0131\u015f yap\u0131lara sahiptir. Time mod\u00fcl\u00fcndeki time.After fonksiyonu bellirledi\u011fimiz bir s\u00fcreden sonra kanala sinyal g\u00f6nderir. func main () { ch1 := make ( chan string ) ch2 := make ( chan string ) go Work ( ch1 , ch2 ) for { select { case msg1 := <- ch1 : fmt . Println ( msg1 ) case msg2 := <- ch2 : fmt . Println ( msg2 ) case <- time . After ( time . Second ): fmt . Println ( \"\ud83c\udfb5 Brave Sir Robin ran away \ud83c\udfb5\" ) fmt . Println ( \"\ud83c\udfb5 Bravely ran away away \ud83c\udfb5\" ) return } } Context \u00b6 \"Context, bir i\u015f iptal edildi\u011finde veya zaman a\u015f\u0131m\u0131na u\u011frad\u0131\u011f\u0131nda ilgili birimleri bilgilendirmek i\u00e7in kullan\u0131l\u0131r.\" Context, en az di\u011fer e\u015fzamanl\u0131l\u0131k yap\u0131lar\u0131 kadar \u00f6nem arz eder. go Func() \u015feklinde bir arkaplan i\u015fi ba\u015ftatt\u0131\u011f\u0131m\u0131zda, bize goroutine durumunu kontrol edebilece\u011fimiz bir de\u011fer d\u00f6n\u00fclmez. Sonraki durumlar\u0131n\u0131 \u00f6nemsemeden bir s\u00fcr\u00fc goroutine olu\u015fturmak; belirgin hata vermeden uygulaman\u0131n performans\u0131n\u0131 \u00f6nemli \u00f6l\u00e7\u00fcde etkileyebilir. Bazen bir arkaplan g\u00f6revi i\u00e7erisinde, \u00e7ok fazla kayna\u011fa ihtiya\u00e7 duyan ba\u015fka arkaplan g\u00f6revleri olu\u015fturmam\u0131z gerekir. Bu g\u00f6revleri olu\u015fturan goroutine bitse bile devam etmesi gerekmeyen di\u011fer yava\u015f goroutineler \u00e7al\u0131\u015fmaya devam eder ve kaynaklar\u0131m\u0131z bo\u015fa harcan\u0131r. Context bize bu gibi durumlarda yard\u0131mc\u0131 olur. Context bir sinyali t\u00fcm arkaplan g\u00f6revlerine yaymam\u0131z\u0131 sa\u011flar. Context hiyerar\u015fileri olu\u015fturabiliriz. Ana context iptal edildi\u011finde; ba\u011fl\u0131 t\u00fcm contextler de iptal edilir. Context Kullan\u0131lmadan Context Kullan\u0131larak Uygulan\u0131\u015f \u00b6 GO t\u00fcm bu i\u015flemleri context paketi i\u00e7erisinde sunar. Paket i\u00e7erisinde, t\u00fcm contextleri tan\u0131mlayan, 4 adet metoda sahip context.Context aray\u00fcz\u00fc bulunur. type Context interface { Deadline () ( deadline time . Time , ok bool ) Done () <- chan struct {} Err () error Value ( key interface {}) interface {} } Deadline() contexte ba\u011fl\u0131 t\u00fcm i\u015flerin bitmesi gereken s\u00fcreyi d\u00f6nd\u00fcr\u00fcr. Bu metodu kullanarak; kalan s\u00fcrede bitiremeyece\u011fimiz bir i\u015fi hi\u00e7 ba\u015flatmayabiliriz. Done() t\u00fcm i\u015fler tamamland\u0131\u011f\u0131nda veya context iptal edildi\u011finde sinyal g\u00f6nderen bir kanal d\u00f6nd\u00fcr\u00fcr. Err() contextin neden bitti\u011fini a\u00e7\u0131klayan bir hata d\u00f6nd\u00fcr\u00fcr. Bu hata Canceled veya DeadlineExceeded olabilir. Value bir anahtar ile context i\u00e7erisinde payla\u015ft\u0131r\u0131lan bir de\u011feri almam\u0131z\u0131 sa\u011flar. Ana contextin verisi t\u00fcm hiyerar\u015fi i\u00e7erisinde pay\u015fa\u015ft\u0131r\u0131ld\u0131\u011f\u0131 i\u00e7in; girilen anahtar t\u00fcm contextlerde ayn\u0131 de\u011feri d\u00f6necektir. Uyar\u0131 Anahtar ve de\u011ferlerin tip kontrol\u00fc olmad\u0131\u011f\u0131 i\u00e7in, bu mekanizmay\u0131 kullanarak g\u00f6revler ve hiyerar\u015filer \u00fczerinde veri payla\u015f\u0131m\u0131 yapmak k\u00f6t\u00fc bir fikirdir . Context paketi bu aray\u00fcz\u00fc farkl\u0131 ama\u00e7lar i\u00e7in olu\u015fturan fonksiyonlar sunar. context.Background() En temel contexti d\u00f6nd\u00fcr\u00fcr. D\u00f6nen context hi\u00e7 bir iptal mekanizmas i\u00e7ermez. T\u00fcm di\u011fer contextler Background contexi kullan\u0131larak olu\u015fturulur. context.TODO() temelde context.Background() ile ayn\u0131d\u0131r. Hen\u00fcz hangi t\u00fcr contexti kullanaca\u011f\u0131m\u0131zdan emin olmad\u0131\u011f\u0131m\u0131z yerlerde, yer tutmas\u0131 i\u00e7in bu contexti kullan\u0131r\u0131z. Paket ayn\u0131 zamanda bu contextleri sarmalay\u0131p; iptal mekanizmas\u0131 ekleyen fonksiyonlar bar\u0131nd\u0131r\u0131r. Bu fonksiyonlar\u0131n tamam\u0131 ilk parametre olarak ana contexti al\u0131r. D\u00f6n\u00fc\u015f de\u011feri olarak yeni bir context ve bir fonksiyon d\u00f6nd\u00fcr\u00fcr. Olu\u015fan contextin kriteri sa\u011fland\u0131\u011f\u0131nda veya bize verdi\u011fi fonksiyonu \u00e7a\u011f\u0131rd\u0131\u011f\u0131m\u0131zda, contextin Done() kanal\u0131na bir sinyal g\u00f6nderilir. context.WithCancel(parent) contexti uygulaman\u0131n bir an\u0131nda kendimiz durdurmak istedi\u011fimizde kullan\u0131labilir. Bu fonksiyondan d\u00f6nen contextin ayr\u0131ca \u00e7al\u0131\u015fan bir iptal olma veya zaman a\u015f\u0131m\u0131 durumu yoktur. A\u015fa\u011f\u0131daki \u00f6rnekte olu\u015fturdu\u011fumuz Background contextini context.WithCancel ile sarmalad\u0131k. Ard\u0131ndan bu contexti parametre alan 2 adet SendRequest g\u00f6revi ve 1 saniye sonra cancel fonksiyonunu \u00e7a\u011f\u0131ran bir g\u00f6rev olu\u015fturduk. Dikkat edece\u011finiz \u00fczere, t\u00fcm g\u00f6revler ilk parametre olarak ald\u0131\u011f\u0131 ve birbiriyle payla\u015ft\u0131\u011f\u0131 contextin <- ctx.Done() kanal\u0131n\u0131 bekliyor. cancel fonksiyonu tetiklendi\u011finde ctx.Done() kanal\u0131na sinyal g\u00f6ndererek t\u00fcm g\u00f6revlere contextin bitti\u011fini bildirecek. // SearchDB 2 saniye sonra normal bir \u015fekilde sonlan\u0131r func SearchDB ( ctx context . Context ){ fmt . Println ( \"Searching Database\" ) select { case <- ctx . Done (): fmt . Println ( \"Search Cancelled\" ) case <- time . After ( time . Second * 2 ): fmt . Println ( \"Search Finished\" ) } } // SendRequest 2 saniye sonra normal bir \u015fekilde sonlan\u0131r func SendRequest ( ctx context . Context ){ fmt . Println ( \"Processing Request\" ) go SearchDB ( ctx ) go SearchDB ( ctx ) select { case <- ctx . Done (): fmt . Println ( \"Request Cancelled\" ) case <- time . After ( time . Second * 2 ): fmt . Println ( \"Request Finished\" ) } } func main () { ctx := context . Background () cancellingCtx , cancel := context . WithCancel ( ctx ) go SendRequest ( cancellingCtx ) go SendRequest ( cancellingCtx ) // T\u00fcm requestleri ve database aramalar\u0131n\u0131 1 saniye sonra iptal edece\u011fiz. go time . AfterFunc ( time . Second , cancel ) select { case <- cancellingCtx . Done (): fmt . Println ( \"Cancelled by Context\" ) case <- time . After ( time . Second * 3 ): fmt . Println ( \"Finished normally\" ) } // Context iptal edildikten sonra goroutinelerin ekrana // bir \u015feyler yazabilmesi i\u00e7in biraz bekliyoruz. <- time . After ( time . Second * 3 ) } context.WithTimeout(parent, duration) contextin belirli bir s\u00fcre i\u00e7inde tamamlanmas\u0131n\u0131 istedi\u011fimiz durumlarda kullan\u0131labilir. Haz\u0131rda elimizde olan contextlere yeni zaman s\u0131n\u0131rlar\u0131 ekleyebiliriz. Bu \u00f6rnek i\u00e7in; SendRequest fonksiyonuna timeout ekleyerek veritaban\u0131ndan 2 saniye i\u00e7erisinde veri gelmezse g\u00f6revi iptal edebiliriz. // SendRequest 5 saniye sonra normal bir \u015fekilde biter // Veritaban\u0131 i\u015fini 2 saniye i\u00e7erisinde tamamlanmazsa iptal eder func SendRequest ( ctx context . Context ){ fmt . Println ( \"Processing Request\" ) // Bu context t\u00fcm veritaban\u0131 i\u015flemleri 2 saniye i\u00e7erisinde // tamamlanmazsa iptal edecek dbCtx , _ := context . WithTimeout ( ctx , time . Second * 2 ) go SearchDB ( dbCtx ) go SearchDB ( dbCtx ) select { case <- ctx . Done (): fmt . Println ( \"Request Cancelled\" ) case <- dbCtx . Done (): fmt . Println ( \"Search Timeout -\" , dbCtx . Err ()) // Search Timeout - context deadline exceeded case <- time . After ( time . Second * 5 ): fmt . Println ( \"Request Finished\" ) } } context.WithDeadline(parent, time) contextin belli bir saatte tamamlanmas\u0131n\u0131 istedi\u011fimiz durumlarda kullan\u0131labilir. \u00d6rnek Uygulama \u00b6 Bir gurup i\u015f\u00e7i demir ve k\u00f6m\u00fcr bar\u0131nd\u0131ran maden yataklar\u0131nda maden aray\u0131p, kaz\u0131p bu madenleri i\u015flemektedir. A\u015fa\u011f\u0131daki uygulamada go dilinin sa\u011flad\u0131\u011f\u0131 concurrency ara\u00e7lar\u0131 ile i\u015f\u00e7ilerin e\u015f zamanl\u0131 olarak nas\u0131l \u00e7al\u0131\u015ft\u0131r\u0131labilece\u011fini g\u00f6rebiliriz. package main import ( \"fmt\" \"strconv\" \"sync\" \"time\" ) // Vein madenleri bar\u0131nd\u0131r\u0131r type Vein struct { Ores [] string } // Reveal bir sonraki madeni a\u00e7\u0131\u011fa \u00e7\u0131kar\u0131r func ( vein * Vein ) Reveal () ( ore string ) { if len ( vein . Ores ) == 0 { return } ore = vein . Ores [ 0 ] vein . Ores = vein . Ores [ 1 :] return ore } // Worker madenleri bulur, kazar ve i\u015fler type Worker struct { name string } // Find maden yata\u011f\u0131nda arama yapar ve buldu\u011fu madeni kaz\u0131c\u0131lara g\u00f6nderir func ( w * Worker ) Find ( vein * Vein , ch chan <- string ) { ore := vein . Reveal () if ore != \"\" { fmt . Println ( w . name , \"found\" , ore ) time . Sleep ( time . Second * 2 ) ch <- ore } } // Mine madeni \u00e7\u0131kart\u0131r ve i\u015fleme kanal\u0131na g\u00f6nderir func ( w * Worker ) Mine ( finder <- chan string , smelter chan <- string ) { for ore := range finder { fmt . Println ( w . name , \"mining\" , ore ) time . Sleep ( time . Second * 1 ) smelter <- ore } } // Smelt madenleri eritir veya i\u015fler func ( w * Worker ) Smelt ( coal_miner , iron_miner <- chan string , wg * sync . WaitGroup ) { for { select { case coal_ore := <- coal_miner : time . Sleep ( time . Second * 1 ) fmt . Println ( w . name , \"processed\" , coal_ore ) case iron_ore := <- iron_miner : time . Sleep ( time . Second * 2 ) fmt . Println ( w . name , \"smelted\" , iron_ore ) } wg . Done () } } func main () { wg := & sync . WaitGroup {} // 100 demir bar\u0131nd\u0131ran bir maden olu\u015ftur n_iron_ores := 100 iron_vein := & Vein { make ([] string , n_iron_ores )} for i := range iron_vein . Ores { iron_vein . Ores [ i ] = \"iron-ore-\" + strconv . Itoa ( i ) } // 50 k\u00f6m\u00fcr bar\u0131nd\u0131ran bir maden olu\u015ftur n_coal_ores := 50 coal_vein := & Vein { make ([] string , n_coal_ores )} for i := range coal_vein . Ores { coal_vein . Ores [ i ] = \"coal-ore-\" + strconv . Itoa ( i ) } // \u0130\u015f\u00e7iler aras\u0131nda maden iletim kanallar\u0131 olu\u015ftur finder_to_miner := make ( chan string ) coal_miner_to_smelter := make ( chan string ) iron_miner_to_smelter := make ( chan string ) // Maden arama i\u015f\u00e7ileri olu\u015ftur n_finders := 6 finders := make ([] * Worker , n_finders ) for i := range finders { finders [ i ] = & Worker { name : \"finder-\" + strconv . Itoa ( i ), } } // Maden kaz\u0131c\u0131lar\u0131 olu\u015ftur n_miners := 50 miners := make ([] * Worker , n_miners ) for i := range miners { miners [ i ] = & Worker { name : \"miner-\" + strconv . Itoa ( i ), } } // Maden i\u015fleyicileri olu\u015ftur n_smelters := 10 smelters := make ([] * Worker , n_smelters ) for i := range smelters { smelters [ i ] = & Worker { name : \"smelter-\" + strconv . Itoa ( i ), } } // Maden aramac\u0131lar\u0131n yar\u0131s\u0131n\u0131 demir, di\u011fer yar\u0131s\u0131n\u0131 k\u00f6m\u00fcr madenine g\u00f6nder for i := 0 ; i < n_iron_ores + n_coal_ores ; i ++ { wg . Add ( 1 ) finder_idx := i % len ( finders ) go finders [ finder_idx ]. Find ( coal_vein , finder_to_miner ) go finders [ finder_idx ]. Find ( iron_vein , finder_to_miner ) } // Kaz\u0131c\u0131lar\u0131n yar\u0131s\u0131n\u0131 demir, di\u011fer yar\u0131s\u0131n\u0131 k\u00f6m\u00fcr madeninde \u00e7al\u0131\u015ft\u0131r for i , miner := range miners { if i % 2 == 0 { go miner . Mine ( finder_to_miner , iron_miner_to_smelter ) } else { go miner . Mine ( finder_to_miner , coal_miner_to_smelter ) } } // Maden i\u015fleyen i\u015f\u00e7ileri \u00e7al\u0131\u015ft\u0131r for _ , smelter := range smelters { go smelter . Smelt ( coal_miner_to_smelter , iron_miner_to_smelter , wg ) } // B\u00fct\u00fcn madenlerin bulunmas\u0131n\u0131, kaz\u0131lmas\u0131n\u0131 ve i\u015flenmesini bekle wg . Wait () }","title":"Concurrency"},{"location":"tr/concurrency/#concurrency","text":"English | T\u00fcrk\u00e7e Bilgisayar biliminde concurrency(e\u015fzamanl\u0131l\u0131k), bir programdaki i\u015f birimlerinin veya algoritmalar\u0131n sonucu etkilemeyecek \u015fekilde s\u0131ras\u0131z bir bi\u00e7imde \u00e7al\u0131\u015ft\u0131r\u0131labilmesidir. \u0130\u015f par\u00e7alar\u0131n\u0131 birbirinden ba\u011f\u0131ms\u0131z \u00e7al\u0131\u015ft\u0131rabilmemiz, s\u00fcre\u00e7leri farkl\u0131 \u00e7ekirdeklerde y\u00fcr\u00fcterek, i\u015flemciyi maksimum verimde kullanmam\u0131z\u0131 sa\u011flar. GO dilinde concurrency goroutineler ile sa\u011flan\u0131r.","title":"Concurrency"},{"location":"tr/concurrency/#goroutines","text":"GO routineleri bir kuyrukta \u00e7al\u0131\u015ft\u0131r\u0131lmay\u0131 bekleyen boyutlar\u0131 k\u00fc\u00e7\u00fck threadler olarak d\u00fc\u015f\u00fcn\u00fclebilir. Bir fonksiyonu goroutine olarak \u00e7al\u0131\u015ft\u0131rmak i\u00e7in \u00e7a\u011f\u0131r\u0131rken ba\u015f\u0131na go yazmam\u0131z yeterli. A\u015fa\u011f\u0131daki uygulamada Work fonksiyonu her \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, \u00e7al\u0131\u015fmas\u0131 bitene kadar uygulamay\u0131 blokluyor. func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { Work ( \"work work work work work work...\" ) Work ( \"zxcasfv\" ) } Bloklayan k\u0131s\u0131mlar\u0131 goroutine olarak \u00e7al\u0131\u015ft\u0131ral\u0131m. func main () { go Work ( \"work work work work work work...\" ) go Work ( \"zxcasfv\" ) } Program\u0131 \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda ekrana hi\u00e7bir \u015fey yazd\u0131rmadan sonlanacak. main fonksiyonu, Work fonksiyonu hen\u00fcz ekrana bir \u015feyler yazacak kadar \u00e7al\u0131\u015fmadan, bitiyor ve program kapan\u0131yor. Program bitmeden \u00f6nce biraz bekleterek Work fonksiyonunun \u00e7\u0131kt\u0131s\u0131n\u0131 alabiliriz. package main import ( \"fmt\" \"time\" ) func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { go Work ( \"work work work work work work...\" ) go Work ( \"zxcasfv\" ) time . Sleep ( time . Second * 3 ) }","title":"Goroutines"},{"location":"tr/concurrency/#waitgroup","text":"Uygulaman\u0131n bir an\u0131nda baz\u0131 goroutinelerin bitmesini beklememiz gerekebilir. WaitGroup ile ka\u00e7 tane gorouitine bekleyece\u011fimizi \u00f6ncesindem belirtip bu goroutinelerin i\u015flerini bitirmelerini bekleyebiliriz. Goroutinelerin burada tek yapmas\u0131 gereken, i\u015fi bitti\u011finde WaitGroup'un Done() methodunu \u00e7al\u0131\u015ft\u0131rmas\u0131. func Work ( msg string , wg * sync . WaitGroup ) { time . Sleep ( time . Second * 2 ) fmt . Println ( msg ) wg . Done () } func main () { nWorkers := 5 wg := & sync . WaitGroup {} wg . Add ( nWorkers ) for i := 0 ; i < nWorkers ; i ++ { go Work ( \"work\" , wg ) } wg . Wait () }","title":"waitGroup"},{"location":"tr/concurrency/#kanalllar-channels","text":"Kanallar goroutinelerin birbirleri ile haberle\u015fmesini sa\u011flar. Yukar\u0131daki \u00f6rnekte go ile \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131z fonksiyonlardan d\u00f6n\u00fc\u015f de\u011feri alam\u0131yoruz. Kanallar\u0131 kullanarak bir goroutiniin, ana fonksiyonla veya ba\u015fka bir goroutine ile haberle\u015fmesini sa\u011flayabiliriz. Kanallar make(chan veritipi, buffer) \u015feklinde olu\u015fturulabilir. func Work ( msg string , ch chan string ) { time . Sleep ( time . Second * 2 ) ch <- msg } func main () { channel := make ( chan string ) go Work ( \"work-1\" , channel ) go Work ( \"work-2\" , channel ) for i := 0 ; i < 2 ; i ++ { msg := <- channel fmt . Println ( msg ) } }","title":"Kanalllar (Channels)"},{"location":"tr/concurrency/#mutex","text":"Mutex, goroutineler taraf\u0131ndan ortak kullan\u0131lan bir de\u011fi\u015fkenin de\u011ferininin, race-condition olu\u015fmadan de\u011fi\u015ftirilebilmesini sa\u011flayan yap\u0131d\u0131r. Wikipedia Tan\u0131m\u0131 In computer science, mutual exclusion is a property of concurrency control, which is instituted for the purpose of preventing race conditions. It is the requirement that one thread of execution never enters its critical section at the same time that another concurrent thread of execution enters its own critical section, which refers to an interval of time during which a thread of execution accesses a shared resource, such as shared memory. A\u015fa\u011f\u0131daki \u00f6rnekte, kullan\u0131c\u0131 t\u0131klamalar\u0131n\u0131 saymak i\u00e7in Counter yap\u0131s\u0131n\u0131 kullan\u0131yoruz. type Counter struct { Value int } func ( c * Counter ) Inc () { c . Value ++ } func Click ( c * Counter , wg * sync . WaitGroup ) { c . Inc () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) counter := & Counter {} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter . Value ) } \u0130lk bak\u0131\u015fta programda yanl\u0131\u015f bir \u015fey g\u00f6z\u00fckm\u00fcyor. Fakat program\u0131 --race parametresi ile derleyip \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda; bize programda race-condition oldu\u011funu s\u00f6yl\u00fcyor. Bu program \u00e7ok \u00e7ekirdekli bir bilgisayarda \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda, Click fonksiyonu farkl\u0131 \u00e7ekirdeklerde ayn\u0131 anda \u00e7al\u0131\u015ft\u0131r\u0131labiliyor. Bu nedenle program yeni c.Value de\u011ferini yanl\u0131\u015f g\u00fcncelliyor. Bu hatay\u0131 main fonksiyonu i\u00e7inde bir Mutex olu\u015fturup; mx.Lock ve mx.Unlock metodlar\u0131n\u0131 Value de\u011ferini de\u011fi\u015ftirdi\u011fimiz yerde kullanarak giderebiliriz. func Click ( c * Counter , wg * sync . WaitGroup , mx * sync . Mutex ) { mx . Lock () c . Inc () mx . Unlock () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) mx := & sync . Mutex {} counter := & Counter {} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg , mx ) } wg . Wait () fmt . Println ( counter . Value ) } Mutexlerin struct i\u00e7erisinde tan\u0131mlanmas\u0131 da yayg\u0131n bir kullan\u0131md\u0131r. Bu \u00f6rnekte, Mutexi, Counter i\u00e7inde tan\u0131mlay\u0131p c.Lock ve c.Unlock metodlar\u0131 ile yine problemi \u00e7\u00f6zebilirdik. type Counter struct { Value int * sync . Mutex } func ( c * Counter ) Inc () { c . Value ++ } func Click ( c * Counter , wg * sync . WaitGroup ) { c . Lock () c . Inc () c . Unlock () wg . Done () } func main () { nUsers := 500 wg := & sync . WaitGroup {} wg . Add ( nUsers ) counter := & Counter { Mutex : & sync . Mutex {}} for i := 0 ; i < nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter . Value ) }","title":"Mutex"},{"location":"tr/concurrency/#select","text":"Kanallara veri g\u00f6ndermek veya kanallardan veri beklemek uygulamay\u0131 bloklar. Select ayn\u0131 anda birka\u00e7 tane kanal\u0131 beklememize olanak sa\u011flar. A\u015fa\u011f\u0131daki \u00f6rnekte 2 goroutine chan1 ve chan2 kanallar\u0131na s\u00fcrekli veri g\u00f6nderiyor. \u0130ki kanaldan da gelen t\u00fcm verileri sonsuz bir d\u00f6ng\u00fc i\u00e7indeki select yap\u0131s\u0131 ile alabiliriz. Herhangi bir kanaldan mesaj geldi\u011finde select o kanal\u0131 bekleyen case e girecek ve i\u00e7inde tan\u0131mlanan i\u015flemler bittikten sonra d\u00f6ng\u00fc, kanal bekleme i\u015flemini tekrarlayacakt\u0131r. func Work ( ch1 chan string , ch2 chan string ) { // Send data to ch1 every second go func () { for { time . Sleep ( 1 * time . Second ) ch1 <- \"work-1\" } }() // Send data to ch2 every 1.5 seconds go func () { for { time . Sleep ( 1.5 * time . Second ) ch2 <- \"work-2\" } }() } func main () { ch1 := make ( chan string ) ch2 := make ( chan string ) go Work ( ch1 , ch2 ) for { select { case msg1 := <- ch1 : fmt . Println ( msg1 ) case msg2 := <- ch2 : fmt . Println ( msg2 ) } } }","title":"Select"},{"location":"tr/concurrency/#zaman-asm","text":"Yukar\u0131daki gibi bir program 2 kanaldan da hi\u00e7 veri gelmezse kilitlenecektir. Sonsuz d\u00f6ng\u00fc i\u00e7erisinde, bitece\u011fine emin oldu\u011fumuz ba\u015fka bir kanal\u0131 daha dinleyerek k\u0131rabiliriz. Go, bu t\u00fcr durumlar i\u00e7in \u00f6nceden tan\u0131mlanm\u0131\u015f yap\u0131lara sahiptir. Time mod\u00fcl\u00fcndeki time.After fonksiyonu bellirledi\u011fimiz bir s\u00fcreden sonra kanala sinyal g\u00f6nderir. func main () { ch1 := make ( chan string ) ch2 := make ( chan string ) go Work ( ch1 , ch2 ) for { select { case msg1 := <- ch1 : fmt . Println ( msg1 ) case msg2 := <- ch2 : fmt . Println ( msg2 ) case <- time . After ( time . Second ): fmt . Println ( \"\ud83c\udfb5 Brave Sir Robin ran away \ud83c\udfb5\" ) fmt . Println ( \"\ud83c\udfb5 Bravely ran away away \ud83c\udfb5\" ) return } }","title":"Zaman A\u015f\u0131m\u0131"},{"location":"tr/concurrency/#context","text":"\"Context, bir i\u015f iptal edildi\u011finde veya zaman a\u015f\u0131m\u0131na u\u011frad\u0131\u011f\u0131nda ilgili birimleri bilgilendirmek i\u00e7in kullan\u0131l\u0131r.\" Context, en az di\u011fer e\u015fzamanl\u0131l\u0131k yap\u0131lar\u0131 kadar \u00f6nem arz eder. go Func() \u015feklinde bir arkaplan i\u015fi ba\u015ftatt\u0131\u011f\u0131m\u0131zda, bize goroutine durumunu kontrol edebilece\u011fimiz bir de\u011fer d\u00f6n\u00fclmez. Sonraki durumlar\u0131n\u0131 \u00f6nemsemeden bir s\u00fcr\u00fc goroutine olu\u015fturmak; belirgin hata vermeden uygulaman\u0131n performans\u0131n\u0131 \u00f6nemli \u00f6l\u00e7\u00fcde etkileyebilir. Bazen bir arkaplan g\u00f6revi i\u00e7erisinde, \u00e7ok fazla kayna\u011fa ihtiya\u00e7 duyan ba\u015fka arkaplan g\u00f6revleri olu\u015fturmam\u0131z gerekir. Bu g\u00f6revleri olu\u015fturan goroutine bitse bile devam etmesi gerekmeyen di\u011fer yava\u015f goroutineler \u00e7al\u0131\u015fmaya devam eder ve kaynaklar\u0131m\u0131z bo\u015fa harcan\u0131r. Context bize bu gibi durumlarda yard\u0131mc\u0131 olur. Context bir sinyali t\u00fcm arkaplan g\u00f6revlerine yaymam\u0131z\u0131 sa\u011flar. Context hiyerar\u015fileri olu\u015fturabiliriz. Ana context iptal edildi\u011finde; ba\u011fl\u0131 t\u00fcm contextler de iptal edilir. Context Kullan\u0131lmadan Context Kullan\u0131larak","title":"Context"},{"location":"tr/concurrency/#uygulans","text":"GO t\u00fcm bu i\u015flemleri context paketi i\u00e7erisinde sunar. Paket i\u00e7erisinde, t\u00fcm contextleri tan\u0131mlayan, 4 adet metoda sahip context.Context aray\u00fcz\u00fc bulunur. type Context interface { Deadline () ( deadline time . Time , ok bool ) Done () <- chan struct {} Err () error Value ( key interface {}) interface {} } Deadline() contexte ba\u011fl\u0131 t\u00fcm i\u015flerin bitmesi gereken s\u00fcreyi d\u00f6nd\u00fcr\u00fcr. Bu metodu kullanarak; kalan s\u00fcrede bitiremeyece\u011fimiz bir i\u015fi hi\u00e7 ba\u015flatmayabiliriz. Done() t\u00fcm i\u015fler tamamland\u0131\u011f\u0131nda veya context iptal edildi\u011finde sinyal g\u00f6nderen bir kanal d\u00f6nd\u00fcr\u00fcr. Err() contextin neden bitti\u011fini a\u00e7\u0131klayan bir hata d\u00f6nd\u00fcr\u00fcr. Bu hata Canceled veya DeadlineExceeded olabilir. Value bir anahtar ile context i\u00e7erisinde payla\u015ft\u0131r\u0131lan bir de\u011feri almam\u0131z\u0131 sa\u011flar. Ana contextin verisi t\u00fcm hiyerar\u015fi i\u00e7erisinde pay\u015fa\u015ft\u0131r\u0131ld\u0131\u011f\u0131 i\u00e7in; girilen anahtar t\u00fcm contextlerde ayn\u0131 de\u011feri d\u00f6necektir. Uyar\u0131 Anahtar ve de\u011ferlerin tip kontrol\u00fc olmad\u0131\u011f\u0131 i\u00e7in, bu mekanizmay\u0131 kullanarak g\u00f6revler ve hiyerar\u015filer \u00fczerinde veri payla\u015f\u0131m\u0131 yapmak k\u00f6t\u00fc bir fikirdir . Context paketi bu aray\u00fcz\u00fc farkl\u0131 ama\u00e7lar i\u00e7in olu\u015fturan fonksiyonlar sunar. context.Background() En temel contexti d\u00f6nd\u00fcr\u00fcr. D\u00f6nen context hi\u00e7 bir iptal mekanizmas i\u00e7ermez. T\u00fcm di\u011fer contextler Background contexi kullan\u0131larak olu\u015fturulur. context.TODO() temelde context.Background() ile ayn\u0131d\u0131r. Hen\u00fcz hangi t\u00fcr contexti kullanaca\u011f\u0131m\u0131zdan emin olmad\u0131\u011f\u0131m\u0131z yerlerde, yer tutmas\u0131 i\u00e7in bu contexti kullan\u0131r\u0131z. Paket ayn\u0131 zamanda bu contextleri sarmalay\u0131p; iptal mekanizmas\u0131 ekleyen fonksiyonlar bar\u0131nd\u0131r\u0131r. Bu fonksiyonlar\u0131n tamam\u0131 ilk parametre olarak ana contexti al\u0131r. D\u00f6n\u00fc\u015f de\u011feri olarak yeni bir context ve bir fonksiyon d\u00f6nd\u00fcr\u00fcr. Olu\u015fan contextin kriteri sa\u011fland\u0131\u011f\u0131nda veya bize verdi\u011fi fonksiyonu \u00e7a\u011f\u0131rd\u0131\u011f\u0131m\u0131zda, contextin Done() kanal\u0131na bir sinyal g\u00f6nderilir. context.WithCancel(parent) contexti uygulaman\u0131n bir an\u0131nda kendimiz durdurmak istedi\u011fimizde kullan\u0131labilir. Bu fonksiyondan d\u00f6nen contextin ayr\u0131ca \u00e7al\u0131\u015fan bir iptal olma veya zaman a\u015f\u0131m\u0131 durumu yoktur. A\u015fa\u011f\u0131daki \u00f6rnekte olu\u015fturdu\u011fumuz Background contextini context.WithCancel ile sarmalad\u0131k. Ard\u0131ndan bu contexti parametre alan 2 adet SendRequest g\u00f6revi ve 1 saniye sonra cancel fonksiyonunu \u00e7a\u011f\u0131ran bir g\u00f6rev olu\u015fturduk. Dikkat edece\u011finiz \u00fczere, t\u00fcm g\u00f6revler ilk parametre olarak ald\u0131\u011f\u0131 ve birbiriyle payla\u015ft\u0131\u011f\u0131 contextin <- ctx.Done() kanal\u0131n\u0131 bekliyor. cancel fonksiyonu tetiklendi\u011finde ctx.Done() kanal\u0131na sinyal g\u00f6ndererek t\u00fcm g\u00f6revlere contextin bitti\u011fini bildirecek. // SearchDB 2 saniye sonra normal bir \u015fekilde sonlan\u0131r func SearchDB ( ctx context . Context ){ fmt . Println ( \"Searching Database\" ) select { case <- ctx . Done (): fmt . Println ( \"Search Cancelled\" ) case <- time . After ( time . Second * 2 ): fmt . Println ( \"Search Finished\" ) } } // SendRequest 2 saniye sonra normal bir \u015fekilde sonlan\u0131r func SendRequest ( ctx context . Context ){ fmt . Println ( \"Processing Request\" ) go SearchDB ( ctx ) go SearchDB ( ctx ) select { case <- ctx . Done (): fmt . Println ( \"Request Cancelled\" ) case <- time . After ( time . Second * 2 ): fmt . Println ( \"Request Finished\" ) } } func main () { ctx := context . Background () cancellingCtx , cancel := context . WithCancel ( ctx ) go SendRequest ( cancellingCtx ) go SendRequest ( cancellingCtx ) // T\u00fcm requestleri ve database aramalar\u0131n\u0131 1 saniye sonra iptal edece\u011fiz. go time . AfterFunc ( time . Second , cancel ) select { case <- cancellingCtx . Done (): fmt . Println ( \"Cancelled by Context\" ) case <- time . After ( time . Second * 3 ): fmt . Println ( \"Finished normally\" ) } // Context iptal edildikten sonra goroutinelerin ekrana // bir \u015feyler yazabilmesi i\u00e7in biraz bekliyoruz. <- time . After ( time . Second * 3 ) } context.WithTimeout(parent, duration) contextin belirli bir s\u00fcre i\u00e7inde tamamlanmas\u0131n\u0131 istedi\u011fimiz durumlarda kullan\u0131labilir. Haz\u0131rda elimizde olan contextlere yeni zaman s\u0131n\u0131rlar\u0131 ekleyebiliriz. Bu \u00f6rnek i\u00e7in; SendRequest fonksiyonuna timeout ekleyerek veritaban\u0131ndan 2 saniye i\u00e7erisinde veri gelmezse g\u00f6revi iptal edebiliriz. // SendRequest 5 saniye sonra normal bir \u015fekilde biter // Veritaban\u0131 i\u015fini 2 saniye i\u00e7erisinde tamamlanmazsa iptal eder func SendRequest ( ctx context . Context ){ fmt . Println ( \"Processing Request\" ) // Bu context t\u00fcm veritaban\u0131 i\u015flemleri 2 saniye i\u00e7erisinde // tamamlanmazsa iptal edecek dbCtx , _ := context . WithTimeout ( ctx , time . Second * 2 ) go SearchDB ( dbCtx ) go SearchDB ( dbCtx ) select { case <- ctx . Done (): fmt . Println ( \"Request Cancelled\" ) case <- dbCtx . Done (): fmt . Println ( \"Search Timeout -\" , dbCtx . Err ()) // Search Timeout - context deadline exceeded case <- time . After ( time . Second * 5 ): fmt . Println ( \"Request Finished\" ) } } context.WithDeadline(parent, time) contextin belli bir saatte tamamlanmas\u0131n\u0131 istedi\u011fimiz durumlarda kullan\u0131labilir.","title":"Uygulan\u0131\u015f"},{"location":"tr/concurrency/#ornek-uygulama","text":"Bir gurup i\u015f\u00e7i demir ve k\u00f6m\u00fcr bar\u0131nd\u0131ran maden yataklar\u0131nda maden aray\u0131p, kaz\u0131p bu madenleri i\u015flemektedir. A\u015fa\u011f\u0131daki uygulamada go dilinin sa\u011flad\u0131\u011f\u0131 concurrency ara\u00e7lar\u0131 ile i\u015f\u00e7ilerin e\u015f zamanl\u0131 olarak nas\u0131l \u00e7al\u0131\u015ft\u0131r\u0131labilece\u011fini g\u00f6rebiliriz. package main import ( \"fmt\" \"strconv\" \"sync\" \"time\" ) // Vein madenleri bar\u0131nd\u0131r\u0131r type Vein struct { Ores [] string } // Reveal bir sonraki madeni a\u00e7\u0131\u011fa \u00e7\u0131kar\u0131r func ( vein * Vein ) Reveal () ( ore string ) { if len ( vein . Ores ) == 0 { return } ore = vein . Ores [ 0 ] vein . Ores = vein . Ores [ 1 :] return ore } // Worker madenleri bulur, kazar ve i\u015fler type Worker struct { name string } // Find maden yata\u011f\u0131nda arama yapar ve buldu\u011fu madeni kaz\u0131c\u0131lara g\u00f6nderir func ( w * Worker ) Find ( vein * Vein , ch chan <- string ) { ore := vein . Reveal () if ore != \"\" { fmt . Println ( w . name , \"found\" , ore ) time . Sleep ( time . Second * 2 ) ch <- ore } } // Mine madeni \u00e7\u0131kart\u0131r ve i\u015fleme kanal\u0131na g\u00f6nderir func ( w * Worker ) Mine ( finder <- chan string , smelter chan <- string ) { for ore := range finder { fmt . Println ( w . name , \"mining\" , ore ) time . Sleep ( time . Second * 1 ) smelter <- ore } } // Smelt madenleri eritir veya i\u015fler func ( w * Worker ) Smelt ( coal_miner , iron_miner <- chan string , wg * sync . WaitGroup ) { for { select { case coal_ore := <- coal_miner : time . Sleep ( time . Second * 1 ) fmt . Println ( w . name , \"processed\" , coal_ore ) case iron_ore := <- iron_miner : time . Sleep ( time . Second * 2 ) fmt . Println ( w . name , \"smelted\" , iron_ore ) } wg . Done () } } func main () { wg := & sync . WaitGroup {} // 100 demir bar\u0131nd\u0131ran bir maden olu\u015ftur n_iron_ores := 100 iron_vein := & Vein { make ([] string , n_iron_ores )} for i := range iron_vein . Ores { iron_vein . Ores [ i ] = \"iron-ore-\" + strconv . Itoa ( i ) } // 50 k\u00f6m\u00fcr bar\u0131nd\u0131ran bir maden olu\u015ftur n_coal_ores := 50 coal_vein := & Vein { make ([] string , n_coal_ores )} for i := range coal_vein . Ores { coal_vein . Ores [ i ] = \"coal-ore-\" + strconv . Itoa ( i ) } // \u0130\u015f\u00e7iler aras\u0131nda maden iletim kanallar\u0131 olu\u015ftur finder_to_miner := make ( chan string ) coal_miner_to_smelter := make ( chan string ) iron_miner_to_smelter := make ( chan string ) // Maden arama i\u015f\u00e7ileri olu\u015ftur n_finders := 6 finders := make ([] * Worker , n_finders ) for i := range finders { finders [ i ] = & Worker { name : \"finder-\" + strconv . Itoa ( i ), } } // Maden kaz\u0131c\u0131lar\u0131 olu\u015ftur n_miners := 50 miners := make ([] * Worker , n_miners ) for i := range miners { miners [ i ] = & Worker { name : \"miner-\" + strconv . Itoa ( i ), } } // Maden i\u015fleyicileri olu\u015ftur n_smelters := 10 smelters := make ([] * Worker , n_smelters ) for i := range smelters { smelters [ i ] = & Worker { name : \"smelter-\" + strconv . Itoa ( i ), } } // Maden aramac\u0131lar\u0131n yar\u0131s\u0131n\u0131 demir, di\u011fer yar\u0131s\u0131n\u0131 k\u00f6m\u00fcr madenine g\u00f6nder for i := 0 ; i < n_iron_ores + n_coal_ores ; i ++ { wg . Add ( 1 ) finder_idx := i % len ( finders ) go finders [ finder_idx ]. Find ( coal_vein , finder_to_miner ) go finders [ finder_idx ]. Find ( iron_vein , finder_to_miner ) } // Kaz\u0131c\u0131lar\u0131n yar\u0131s\u0131n\u0131 demir, di\u011fer yar\u0131s\u0131n\u0131 k\u00f6m\u00fcr madeninde \u00e7al\u0131\u015ft\u0131r for i , miner := range miners { if i % 2 == 0 { go miner . Mine ( finder_to_miner , iron_miner_to_smelter ) } else { go miner . Mine ( finder_to_miner , coal_miner_to_smelter ) } } // Maden i\u015fleyen i\u015f\u00e7ileri \u00e7al\u0131\u015ft\u0131r for _ , smelter := range smelters { go smelter . Smelt ( coal_miner_to_smelter , iron_miner_to_smelter , wg ) } // B\u00fct\u00fcn madenlerin bulunmas\u0131n\u0131, kaz\u0131lmas\u0131n\u0131 ve i\u015flenmesini bekle wg . Wait () }","title":"\u00d6rnek Uygulama"},{"location":"tr/data-structures/","text":"Veri Yap\u0131lar\u0131 \u00b6 English | T\u00fcrk\u00e7e Bu sayfa go diline ait veri yap\u0131lar\u0131 ve bu yap\u0131lar\u0131n genel programlamada uygulanan y\u00f6ntemlerle kullan\u0131m\u0131 anlat\u0131lmaktad\u0131r. Array \u00b6 Arrayler ayn\u0131 tipteki verileri bir arada muhafaza etmemizi sa\u011flayan yap\u0131lard\u0131r. \u00d6rne\u011fin; 4, 5, 19 ve 25'ten olu\u015fan veri b\u00fct\u00fcn\u00fc arrayi tan\u0131mlar. Go farkl\u0131 tipteki verilerden array olu\u015fturmam\u0131za izin vermez. Tan\u0131mlama \u00b6 Arrayler temel olarak [Boyut]Tip bi\u00e7iminde tan\u0131mlan\u0131r. Arrayleri olu\u015fturman\u0131n \u00e7e\u015fitli yollar\u0131n\u0131 a\u015fa\u011f\u0131da g\u00f6rebiliriz. string tipinde 3 birim tutabilen array. var fruits [ 3 ] string B\u00f6yle tan\u0131mland\u0131\u011f\u0131nda arraydeki her bir alan, veri tipinin \u00f6n tan\u0131ml\u0131 de\u011feri ile doldurulur. Bu \u00f6rne\u011fi baz al\u0131rsak [\"\", \"\", \"\"] olarak tan\u0131mlanacakt\u0131r. Bu de\u011ferleri bulunduklar\u0131 indexler \u00fczerinden eri\u015ferek de\u011fi\u015ftirebiliriz. fruits [ 0 ] = \"\ud83c\udf4c\" fruits [ 1 ] = \"\ud83c\udf4f\" fruits // [\ud83c\udf4c \ud83c\udf4f ] Array i\u00e7in tan\u0131mlanan\u0131n d\u0131\u015f\u0131ndaki bir veri tipini kullan\u0131rsak hata ile kar\u015f\u0131la\u015f\u0131r\u0131z. arr [ 2 ] = 1 cannot use 1 ( type int ) as type string in assignment Ayn\u0131 arrayi daha k\u0131sa bir yol ile de tan\u0131mlayabiliriz. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" } fruits // [\ud83c\udf4c \ud83c\udf4f ] Bu tan\u0131mlamada ilk 2 eleman\u0131n\u0131 do\u011frudan tan\u0131mlad\u0131\u011f\u0131m\u0131z 3 birim uzunlu\u011fundaki bir arrayi arr de\u011fi\u015fkenine atad\u0131k. E\u011fer arrayi de\u011ferleri ile birlikte olu\u015fturulacaksak ... ifadesini kullan\u0131larak, boyut hesaplama k\u0131sm\u0131 compilera b\u0131rak\u0131labiliriz. fruits := [ ... ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf49] D\u00f6ng\u00fc ile kullanma Arrayler for d\u00f6ng\u00fcs\u00fc ile temel olarak 2 \u015fekilde kullan\u0131labilir. \u0130ndex ile eri\u015ferek. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } for index := range fruits { fruit := fruits [ index ] fmt . Println ( fruit ) } Do\u011frudan de\u011fere eri\u015ferek. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } for _ , fruit := range fruits { fmt . Println ( fruit ) } Slice \u00b6 Slicelar kullan\u0131m bak\u0131m\u0131ndan arraylere \u00e7ok benzer. Slicelar\u0131n fark\u0131, boyutlar\u0131n\u0131n dinamik olmas\u0131. Slice tan\u0131mlarken yine arraydeki gibi []Tip yap\u0131s\u0131n\u0131 kullan\u0131yoruz fakat k\u00f6\u015feli parantezlerin i\u00e7ini bo\u015f b\u0131rak\u0131yoruz. // nil slice tan\u0131mlama var slc [] int // nill slice'a de\u011fer atama slc = [] int { 12 , 24 , 39 } // do\u011frudan tan\u0131mlama slc := [] int { 12 , 24 , 39 } make \u00b6 Slicelar\u0131 tan\u0131mlamak i\u00e7in `make` fonksiyonunu da kullanabiliriz. make fonksiyonunun ilk parametresi olu\u015fturulacak slice\u0131n boyutunu belirler. make fonksiyonuna slice tipini ve tutulacak eleman say\u0131s\u0131n\u0131 vererek yeni bir slice olu\u015fturabiliriz. B\u00f6yle tan\u0131mland\u0131\u011f\u0131nda, bellekten \u00e7al\u0131\u015fma zaman\u0131nda slice\u0131n tutaca\u011fi elemanlar\u0131n boyutu ve eleman say\u0131s\u0131 kadar alan ayr\u0131l\u0131r. // define by size n_items = 3 slc := make ([] int , n_items ) \u00c7al\u0131\u015fma zaman\u0131nda bellekten alan almak maliyetli olabilir. E\u011fer slice\u0131n boyutu hakk\u0131nda bir tahminimiz varsa 3. bir parametre olarak slice kapasitesini verebiliriz. // definition by size and capacity n_items = 3 capacity := 5 slc := make ([] int , n_items , capacity ) Slice \u0130\u015flemleri \u00b6 Slice olu\u015fturulurken kapasitesi kadar, tutaca\u011f\u0131 veri tipinin \u00f6n tan\u0131ml\u0131 de\u011feri ile doldurulur. Fakat, yaln\u0131zca uzunlu\u011fu kadar k\u0131sm\u0131na eri\u015filebilir. Bir slice\u0131n boyutunu art\u0131rmak istiyorsak bunun i\u00e7in append ve copy fonksiyonlar\u0131n\u0131 kullanabiliriz. mutate \u00b6 Bir slice\u0131 yeniden boyutland\u0131r\u0131p ba\u015fka bir de\u011fi\u015fkene atad\u0131\u011f\u0131m\u0131zda, yeni slicedaki de\u011fi\u015fiklikler orjinal slice\u0131 da etkileyecektir. fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := fruits [: 2 ] apples [ 0 ] = \"\ud83c\udf4f\" apples [ 1 ] = \"\ud83c\udf4f\" apples // [\ud83c\udf4f \ud83c\udf4f] fruits // [\ud83c\udf4f \ud83c\udf4f \ud83c\udf47 \ud83c\udf52 \ud83c\udf49] copy \u00b6 copy bir slice\u0131 ayn\u0131 veya daha b\u00fcy\u00fck kapasiteye sahip bir di\u011fer slicea kopyalamam\u0131z\u0131 sa\u011flar ve ka\u00e7 adet eleman\u0131n kopyaland\u0131\u011f\u0131n\u0131 d\u00f6nd\u00fcr\u00fcr. bucket := make ([] string , 5 ) fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } n_copied := copy ( bucket , fruits ) n_copied // 5 bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49] Bir slice kopyalan\u0131rken, elemanlar hedef slicedaki ayn\u0131 indexdeki elemanlar\u0131n yerini al\u0131r. fruits := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4e\" , \"\" , \"\ud83c\udf4f\" } copy ( fruits , apples ) fruits // [\ud83c\udf4e \ud83c\udf4f] filter \u00b6 Slice elemanlar\u0131n\u0131 belirli bir kritere g\u00f6re filtreleyebiliriz. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" , \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } apple_criteria := \"\ud83c\udf4e\" apples := [] string {} for _ , fruit := range fruits { if fruit == apple_criteria { apples = append ( apples , fruit ) } } apples // [\ud83c\udf4e \ud83c\udf4e] append \u00b6 append fonksiyonu, ilk parametre olarak boyutunu art\u0131raca\u011f\u0131m\u0131z slice\u0131 ve devam\u0131nda ekleyece\u011fimiz elemanlar\u0131 al\u0131r ve bize t\u00fcm elemanlar\u0131 i\u00e7eren yeni bir slice d\u00f6nd\u00fcr\u00fcr. Bu nedenle, d\u00f6n\u00fc\u015f de\u011ferini bir de\u011fi\u015fkende(genellikle eski slice de\u011fi\u015fkeninde) tutmak gerekir. bucket := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } green_apple := \"\ud83c\udf4f\" bucket = append ( bucket , green_apple ) bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf4f] pop \u00b6 A\u015fa\u011f\u0131daki \u00f6rnekte slice\u0131n son eleman\u0131n\u0131 \u00e7\u0131kar\u0131p bir de\u011fi\u015fkene atad\u0131k. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } item , fruits := fruits [ len ( fruits ) - 1 ], fruits [: len ( fruits ) - 1 ] item // \ud83c\udf49 fruits // [\ud83c\udf4f \ud83c\udf4e] push front (unshift) \u00b6 Bu \u00f6rnekte yeni bir eleman\u0131 slice\u0131n ba\u015f\u0131na koyduk. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" fruits = append ([] string { banana }, fruits ... ) fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf4e \ud83c\udf49] pop front (shift) \u00b6 Bu \u00f6rnekte de slice\u0131n ilk eleman\u0131n\u0131 \u00e7\u0131kar\u0131p bir de\u011fi\u015fkene atad\u0131k. fruits := [] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana , fruits := fruits [ 0 ], fruits [ 1 :] banana // \ud83c\udf4c fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf49] insert \u00b6 Slice\u0131n herhangi bir k\u0131sm\u0131na yeni bir eleman eklemek istiyorsak; bu y\u00f6ntemleri kullanabiliriz. fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" insert_index := 2 fruits = append ( fruits [: insert_index ], append ([] string { banana }, fruits [ insert_index :] ... ) ... , ) fruits // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf4c \ud83c\udf52 \ud83c\udf49] append([]string{banana}, fruits[insert_index:]...) ifadesi ba\u015fl\u0131 ba\u015f\u0131na bir slice olu\u015fturup, fruits[insert_index:] slice\u0131n\u0131n elemanlar\u0131n\u0131 bu slicea kopyal\u0131yor. Bu elemanlar daha sonra fruits slice\u0131na tekrar kopyalan\u0131yor. Yeni bir slice olu\u015fturulmas\u0131n\u0131n ve 2. kez kopyalama i\u015fleminin \u00f6n\u00fcne ge\u00e7ilebilir. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" insert_index := 2 fruits = append ( fruits , \"\" ) copy ( fruits [ insert_index + 1 :], fruits [ insert_index :]) fruits [ insert_index ] = banana fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49] expand \u00b6 Bir slice\u0131, di\u011feri birle\u015ftirmek istersek a\u015fa\u011f\u0131daki y\u00f6ntemleri kullanabiliriz. bucket := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } bucket = append ( bucket , apples ... ) bucket // [\ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf4f \ud83c\udf4e] A\u015fa\u011f\u0131daki \u00f6rnekte 7. sat\u0131rda apples ile belirledi\u011fimiz indexten sonraki elemanlar\u0131 birle\u015ftirdik. Sonras\u0131nda belirledi\u011fimiz indexe kadar olan bucket elemanlar\u0131na, bu slice elemanlar\u0131n\u0131 ekledik. bucket := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } expand_index := 2 bucket = append ( bucket [: expand_index ] append ( apples , bucket [ expand_index :] ... ) ... , ) bucket // [\ud83c\udf47 \ud83c\udf52 \ud83c\udf4f \ud83c\udf4e \ud83c\udf49] cut \u00b6 Slicedaki belli bir aral\u0131\u011f\u0131 \u00e7\u0131karmak istiyorsak a\u015fa\u011f\u0131daki y\u00f6ntemi kullanabiliriz. Bu y\u00f6ntem Sliceda belirledi\u011fimiz ba\u015flang\u0131\u00e7 indexine kadar olan elemanlar ile biti\u015f indexinden sonraki elemanlar\u0131 ekleyecek. B\u00f6ylece aradaki elemanlar\u0131 bo\u015fa \u00e7\u0131kartm\u0131\u015f olaca\u011f\u0131z. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } cut_start_index , cut_end_index := 4 , 6 edibles = append ( edibles [: cut_start_index ], edibles [ cut_end_index :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54] cut (memory safe) \u00b6 Bellek adresi tutan slicelar \u00fczerinde i\u015flem yapmak memory-leak olu\u015fturabilir. A\u015fa\u011f\u0131daki \u00f6rneklerde yapt\u0131\u011f\u0131m\u0131z i\u015flemlere ek olarak, i\u015flemimden sonra bo\u015fta kalan alanlar\u0131 nil de\u011ferleri ile doldurduk. B\u00f6ylece, garbage-collector bu alanlar\u0131n art\u0131k kullan\u0131lmayaca\u011f\u0131n\u0131 anlayabilir ve onlar\u0131 sisteme geri kazand\u0131rabilir. apple , grapes , cherry , wmelon := \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" pepper , egplnt , corn , potato := \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" edibles := [] * string { & apple , & grapes , & cherry , & wmelon , & pepper , & egplnt , & corn , & potato } cut_start_index , cut_end_index := 4 , 6 copy ( edibles [ cut_start_index :], edibles [ cut_end_index :]) cleanup_index := len ( edibles ) - cut_end_index + cut_start_index for free_index , free_end := cleanup_index , len ( edibles ); free_index < free_end ; free_index ++ { edibles [ free_index ] = nil } edibles = edibles [: cleanup_index ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54] delete \u00b6 Slicedaki bir eleman\u0131 indexini kullanarak silmek istiyorsak, a\u015fa\u011f\u0131daki y\u00f6ntemi kullanabiliriz. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } index_of_cherry := 2 edibles = append ( edibles [: index_of_cherry ], edibles [ index_of_cherry + 1 :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] S\u0131ralamay\u0131 Dikkate Almadan Silme \u00b6 Silme i\u015flemini array s\u0131ralamas\u0131n\u0131 g\u00f6z ard\u0131 ederek de yapabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte, silmek istedi\u011fimiz eleman ile slicedaki en son eleman\u0131n yerini de\u011fi\u015ftirdik. Ard\u0131ndan slice\u0131n boyutunu 1 azaltt\u0131k. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } index_of_cherry := 2 edibles [ index_of_cherry ] = edibles [ len ( edibles ) - 1 ] edibles = edibles [: len ( edibles ) - 1 ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83e\udd54 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d] Map \u00b6 En s\u0131k kullan\u0131lan veri tiplerinden birisi de maplerdir. map unique anahtarlar\u0131, de\u011ferlerle e\u015fle\u015ftirebilen sonras\u0131nda bu anahtarla e\u015fle\u015ftirilen de\u011fere eri\u015filmesini sa\u011flayan yap\u0131lard\u0131r. Tan\u0131mlama \u00b6 Mapler map[AnahtarTipi]De\u011ferTipi veya make(map[AnahtarTipi]De\u011ferTipi) \u015feklinde tan\u0131mlanabilir. var mymap = map [ string ] string {} mymap = make ( map [ string ] string ) De\u011fer Atama \u00b6 monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"1979\" : \"Life of Brian\" , } monty_python_films_by_year [ \"1983\" ] = \"The Meaning of Life\" Atad\u0131\u011f\u0131m\u0131z de\u011ferlere, yine ayn\u0131 keyi kullanarak eri\u015febiliriz. film_name := monty_python_films_by_year [ \"1983\" ] film_name // The Meaning of Life Mapin bir eleman\u0131na eri\u015firken, eleman\u0131n mapde kay\u0131tl\u0131 olup olmad\u0131\u011f\u0131n\u0131 g\u00f6steren ek bir de\u011fere daha eri\u015febiliriz. film_name , registered := monty_python_films_by_year [ \"2019\" ] if ! registered { fmt . Println ( \"Monty python did not relase a film at 2019\" ) } else { fmt . Println ( film_name ) } D\u00f6ng\u00fc ile kullanma \u00b6 Map elemanlar\u0131na temelde 2 yolla eri\u015filebilir. For d\u00f6ng\u00fcs\u00fcnde tek de\u011fi\u015fken kullan\u0131p, keyler \u00fczerinden eri\u015ferek. monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"1979\" : \"Life of Brian\" , \"1983\" : \"The Meaning of Life\" , } for year := range monty_python_films_by_year { film_name := monty_python_films_by_year [ year ] fmt . Println ( film_name , \"was released at\" , year ) } D\u00f6ng\u00fcde 2 de\u011fi\u015fken kullan\u0131p, hem anahtar hem de de\u011fere eri\u015ferek. for year , film_name := range monty_python_films_by_year { fmt . Println ( film_name , \"was released at\" , year ) } /* Monty Python and the Holy Grail was released at 1971 Life of Brian was released at 1979 The Meaning of Life was released at 1983 */ delete \u00b6 Mapdeki bir eleman\u0131 silmek i\u00e7in delete fonksiyonunu kullanabiliriz. monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"2016\" : \"Batman v Superman\" , } delete ( monty_python_films_by_year , \"2016\" ) _ , registered := monty_python_films_by_year [ \"2016\" ] registered // false len ( monty_python_films_by_year ) // 1 struct \u00b6 Structlar kullan\u0131c\u0131 taraf\u0131ndan tan\u0131mlanan ve farkl\u0131 t\u00fcrdeki verileri isimleri ile tutabilen veri yap\u0131lar\u0131d\u0131r. Tan\u0131mlama \u00b6 Structlar a\u015fa\u011f\u0131daki yap\u0131da tan\u0131mlanabilir. type StructName struct { field fieldType } Struct\u0131n ayn\u0131 tipteki alanlar\u0131n\u0131 tek sat\u0131rda tan\u0131mlayabiliriz. type Film struct { name , director string imdb float32 release_year int } var new_film = Film {} new_film // {\"\" \"\" 0 0} Struct alanlar\u0131na ek olarak etiket de verebiliriz. type Film struct { Name string `json:\"film_name\"` Director string `json:\"director_name\"` Imdb float32 `json:\"imdb_score\"` ReleaseYear int `json:\"year_of_release\"` } Etiketler tip d\u00f6n\u00fc\u015f\u00fcm\u00fc ile \u00e7ok\u00e7a u\u011fra\u015fan ORMler ve serialization k\u00fct\u00fcphaneleri aras\u0131nda pop\u00fclerdir. Bu etiketlere reflect mod\u00fcl\u00fc ile eri\u015filebilir. f := Film {} t := reflect . TypeOf ( f ) for _ , f := range [] string { \"Name\" , \"Director\" , \"Imdb\" , \"ReleaseYear\" } { field , found := t . FieldByName ( f ) if ! found { continue } fmt . Println ( field . Tag . Get ( \"json\" )) } /* film_name director_name imdb_score year_of_release */ De\u011fer Atama \u00b6 Bir struct, parametreleri s\u0131ras\u0131yla verilerek olu\u015fturulabilir. new_film := Film { \"Mad Max: Fury Road\" , \"George Miller\" , 8.1 , 2015 } new_film // {Mad Max: Fury Road George Miller 8.1 2015} Benzer bi\u00e7imde, parametreleri ve alacaklar\u0131 de\u011ferleri : ayrac\u0131 ile belirterek de olu\u015fturulabilir. new_film := Film { Name : \"Ran\" , Director : \"Akira Kurosawa\" , Imdb : 8.2 , ReleaseYear : 1985 , } new_film // {Ran Akira Kurosawa 8.2 1985} Struct olu\u015ftururken baz\u0131 alanlar bo\u015f b\u0131rak\u0131l\u0131rsa; bu alanlar o veri tipinin bo\u015f de\u011ferleri ile tan\u0131mlan\u0131r. new_film := Film { name : \"Batman v Superman\" , director : \"Zack Snyder\" , release_year : 2016 , } new_film // {Batman v Superman Zack Snyder 0 2016} Anonymous struct \u00b6 Baz\u0131 \u00f6zel durumlarda structlar\u0131 fonksiyon g\u00f6vdesi i\u00e7erisinde tan\u0131mlamam\u0131z gerekebilir. Bunu a\u015fa\u011f\u0131daki y\u00f6ntemle yapabiliriz. provider_config := struct { name string baseUrl string apiKey string }{ name : \"mapbox\" , baseUrl : \"https://api.mapbox.com/geocoding/v5/\" , apiKey : \"123asds123\" , } provider_config // {mapbox https://api.mapbox.com/geocoding/v5/ 123asds123} Anonymous fields \u00b6 Alan isimlerini belirtilmeden de struct tan\u0131mlanabilir. Bu tarz bir tan\u0131mlamada belirtilen veri tiplerinin birbirinden farkl\u0131 olmas\u0131 gerekir. type Item struct { string // code int // quantity float32 // price } item := Item { \"child-seat-1\" , 5 , 20.1 , } item // {child-seat 5 20.1} Promoted fields \u00b6 Bir struct ba\u015fka bir struct i\u00e7erisinde alan ismi verilmeden kullan\u0131labilir. Bu durumda i\u00e7erideki structa kendi ismiyle eri\u015filir. A\u015fa\u011f\u0131daki \u00f6rne\u011fi baz al\u0131rsak Page i\u00e7erisindeki Content e page.Content \u015feklinde eri\u015filebilir. type Content struct { body string size int } type Page struct { nextUrl string previousURL string Content } content := Content { body : \"<h1>Hi</h1>\" , size : 11 , } page := Page { nextUrl : \"http://.../3\" , previousURL : \"http://.../1\" , Content : content , } page // {http://.../3 http://.../1 {<h1>Hi</h1> 11}} page . Content // {<h1>Hi</h1> 11} Fonksiyonlar \u00b6 Genel olarak GO'da fonksiyonlar a\u015fa\u011f\u0131daki yap\u0131da tan\u0131mlan\u0131r. func fonksiyon_ad\u0131 ( [ parametre listesi ] ) [ d\u00f6n\u00fc\u015f de\u011ferlerinin tipleri ] { fonksiyon g\u00f6vdesi } func sigmoid ( value float64 ) float64 { return 1.0 / ( 1.0 + math . Exp ( - value )) } sigmoid ( 0.5 ) // 0.62246 Parametreler \u00b6 GO fonksiyonlar\u0131na parametre olarak girilen de\u011fi\u015fkenler kopyalan\u0131r. Bu nedenle parametreler \u00fczerinde yap\u0131lan de\u011fi\u015fiklikler de\u011fi\u015fkenlerin fonksiyon d\u0131\u015f\u0131ndaki durumlar\u0131n\u0131 etkilemez. type Wallet struct { userID int balance float64 deposit float64 } func withdraw ( wallet Wallet , amount float64 ) { wallet . balance -= amount } Yukar\u0131daki kodda basit\u00e7e bir c\u00fczdan yap\u0131s\u0131 ve bu c\u00fczdandan para \u00e7ekebilen withdraw fonksiyonu tan\u0131mlad\u0131k. A\u015fa\u011f\u0131daki sat\u0131rlarda da bir adet c\u00fczdan olu\u015fturup bu fonksiyon ile kulland\u0131k. wallet := Wallet { userID : 1 , balance : 30000.12 , deposit : 40000.01 , } item_price := 10023.0 withdraw ( wallet , item_price ) wallet . balance // 3000.12 G\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere c\u00fczdandaki para de\u011fi\u015fmedi. Bu tarz kazalar\u0131 2 yolla \u00f6nleyebiliriz. Y\u00f6ntem, c\u00fczdandaki son para durumunu d\u00f6nd\u00fcr\u00fcp, c\u00fczdan\u0131 sonradan g\u00fcncelleyebiliriz. func withdraw ( wallet Wallet , amount float64 ) float64 { new_balance := wallet . balance - amount return new_balance } wallet . balance = withdraw ( wallet , item_price ) wallet . balance // 19977.12 Bu de\u011fi\u015fim, i\u015fi c\u00fczdandan para \u00e7ekmek olan withdraw fonksiyonunun kullan\u0131m amac\u0131n\u0131 de\u011fi\u015ftirmi\u015f oluyor. Y\u00f6ntem, c\u00fczdan de\u011fi\u015fkeni yerine, c\u00fczdan\u0131n adresini parametre olarak verebiliriz. func withdraw ( wallet * Wallet , amount float64 ) { wallet . balance -= amount } withdraw ( & wallet , item_price ) wallet . balance // 19977.12 Bu y\u00f6ntemin dezavantaj\u0131 da farkl\u0131 concurrency safe olmamas\u0131d\u0131r. Farkl\u0131 threadler ile c\u00fczdandan para \u00e7ekmek istedi\u011fimizde, bakiye durumunu takip etmek zor olacakt\u0131r. Dinamik parametreler \u00b6 GO fonksiyonlar\u0131nda dinamik parametreler tan\u0131mlanabilir. Bu t\u00fcrdeki parametreleri tan\u0131mlamak i\u00e7in parametre tipinin \u00f6n\u00fcne ... i\u015fareti yaz\u0131l\u0131r. func ReLU ( nums ... float64 ) [] float64 { new_nums := make ([] float64 , len ( nums )) for idx , value := range nums { if value > 0 { new_nums [ idx ] = value } else { new_nums [ idx ] = 0. } } return new_nums } nums := [] float64 { 1. , 0.2 , 0. , 0. , - 0.1 , 0.1 } nums = ReLU ( nums ... ) nums // [1 0.2 0 0 0 0.1] D\u00f6n\u00fc\u015f De\u011ferleri \u00b6 Birden fazla de\u011fer d\u00f6nd\u00fcrme \u00b6 GO fonksiyonlar\u0131nda birden fazla de\u011fer d\u00f6nd\u00fcr\u00fclebilir. D\u00f6n\u00fclecek de\u011ferleri () aras\u0131nda s\u0131ras\u0131yla tan\u0131mlamak gerekmektedir. func swap ( first_arg , second_arg string ) ( string , string ) { return second_arg , first_arg } var language1 , language2 string = \"Python\" , \"GO\" language1 , language2 = swap ( language1 , language2 ) language1 , language2 // GO Python D\u00f6n\u00fc\u015f de\u011ferlerini isimlendirme \u00b6 Fonksiyonlar\u0131n d\u00f6n\u00fc\u015f de\u011ferlerine isim verip, de\u011ferleri bu de\u011fi\u015fkenler ile belirleyebiliriz. \u0130simlendirilmi\u015f d\u00f6n\u00fc\u015f de\u011ferleri veri tipinin bo\u015f de\u011ferini alaca\u011f\u0131 i\u00e7in, fonksiyonun \u00f6n tan\u0131ml\u0131 d\u00f6n\u00fc\u015f de\u011ferleri olarak da kullan\u0131labilirler. type Record struct { id int data string } type DB struct { records [] Record locked bool } func BulkCreate ( records [] Record , db * DB ) ( n_created int , err error ) { if db . locked { err = errors . New ( \"DB is locked\" ) } else { db . records = append ( db . records , records ... ) n_created = len ( records ) } return n_created , err } db := & DB { records : [] Record {}, locked : true , } data := [] Record {} for i := 0 ; i < 100 ; i ++ { rec := Record { id : i , data : \"test\" , } data = append ( data , rec ) } n_created , err := BulkCreate ( data , db ) if err != nil { fmt . Println ( err ) } Anonim Fonksiyon \u00b6 GO'da fonksiyonlar da veri yap\u0131lar\u0131d\u0131r ve di\u011fer fonksiyonlar\u0131n i\u00e7erisinde tan\u0131mlanabilirler. Anonim fonksiyonlar\u0131, projenin k\u0131s\u0131tl\u0131 bir b\u00f6l\u00fcm\u00fcnde, spesifik bir i\u015fi halletmek i\u00e7in kullanabiliriz. A\u015fa\u011f\u0131daki kod \u00f6rne\u011finde, projenin ba\u015fka yerinde bu i\u015fleme ihtiya\u00e7 duymayaca\u011f\u0131m\u0131z\u0131 varsayarak, bir slice\u0131 belirlenen boyutta par\u00e7alayan bir anonim fonksiyon kulland\u0131k. records := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } batchSize := 3 batchedRecords := func ( data [] int , batchSize int ) [][] int { var batches [][] int for batchSize < len ( data ) { data , batches = data [ batchSize :], append ( batches , data [ 0 : batchSize : batchSize ]) } batches = append ( batches , data ) return batches }( records , batchSize ) batchedRecords // [[0 1 2] [3 4 5] [6 7 8] [9]] Bu t\u00fcrdeki fonksiyonlar\u0131 bir de\u011fi\u015fkene atay\u0131p bir ka\u00e7 kez de kullanabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte spesifik bir APIden ayr\u0131 ayr\u0131 g\u00f6nderilen \u00fclke kodu ve telefon numaralar\u0131n\u0131 de\u011fi\u015fken olarak tan\u0131mlad\u0131\u011f\u0131m\u0131z fonksiyonla birle\u015ftirdik. type Vendor struct { name string countryCode string phone string } vendor := Vendor { name : \"Volswagen Group\" , countryCode : \"1\" , phone : \"403120120\" , } formatPhoneNumbers := func ( contact Vendor ) string { return \"+\" + contact . countryCode + contact . phone } formatPhoneNumbers ( vendor ) // +1403120120 Metodlar \u00b6 GO dilinde di\u011fer nesne y\u00f6nelimli programlama dilleri gibi classlar ve kal\u0131t\u0131m yoktur. Fakat fonksiyonlara receiver denilen ek bir arg\u00fcman ekleyerek ile kendi olu\u015fturdu\u011fumuz tiplere fonksiyonlar\u0131 ba\u011flayabiliriz. B\u00f6ylece GO dilinde de nesne y\u00f6nelimli programlamaya benzer bir deneyim yakalanabilir. type Connection struct { host string port int timeOut int isClosed bool } func ( conn * Connection ) Close () { conn . isClosed = true fmt . Println ( \"Connection\" , conn . host + \":\" + strconv . Itoa ( conn . port ), \"closed.\" ) } Yukar\u0131daki yap\u0131da Close fonksiyonuna normal bir fonksiyona ek olarak (conn *Connection) k\u0131sm\u0131n\u0131 ekledik. B\u00f6ylece a\u015fa\u011f\u0131daki \u00f6rnekte g\u00f6r\u00fcld\u00fc\u011f\u00fc gibi c.Close() \u015feklinde Connection tipi \u00fczerinden fonksiyona eri\u015febildik. c := Connection { host : \"0.0.0.0\" , port : 8080 , timeOut : 1 , isClosed : false , } c . Close () // Connection 0.0.0.0:8080 closed. Pointer receiver | Value receiver \u00b6 Fonksiyon parametrelerinde oldu\u011fu gibi receiverlerde de yap\u0131n\u0131n de\u011feri ile mi yoksa memory adresi ile mi kullan\u0131laca\u011f\u0131na karar verilmelidir. Receiverlar\u0131 struct d\u0131\u015f\u0131ndaki tipler i\u00e7in de kullanabiliriz. type Iterable [] int func ( iterable * Iterable ) Append ( items ... int ) { * iterable = append ( * iterable , items ... ) } arr := Iterable { 1 , 2 } arr . Append ( 4 , 5 , 6 ) arr // [1 2 4 5 6] Error \u00b6 GOda kendi hata tiplerimizi olu\u015fturabiliriz. Bunun i\u00e7in olu\u015fturdu\u011fumuz tipin sadece Error methoduna sahip olmas\u0131 yeterlidir. Tan\u0131mlama \u00b6 A\u015fa\u011f\u0131daki \u00f6rnekte HTTP kodunu ve hata nedenini belirten HTTPError ad\u0131nda yeni bir hata tan\u0131mlad\u0131k. type HTTPError struct { Status int Reason string } func ( e HTTPError ) Error () string { return fmt . Sprintf ( \"%v: %v\" , e . Status , e . Reason ) } func MakeRequest () error { return HTTPError { Status : 400 , Reason : \"Bad Request\" , } } Kullan\u0131m \u00b6 Fonksiyon \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda d\u00f6n\u00fclen hata de\u011ferinin nil olup olmad\u0131\u011f\u0131 kontrol edilerek buna g\u00f6re \u00f6nlemler al\u0131nabilir. err := MakeRequest () if err != nil { fmt . Println ( err ) } Interface \u00b6 Interfaceler bir objenin sahip olabilece\u011fi methodlar\u0131 belirten yap\u0131lard\u0131r. Bu nedenle interfaceler objelerin davran\u0131\u015f\u0131n\u0131 ifade eder. \u00d6rne\u011fin; bir dosyandan veri okunabilir veya dosyaya veri yaz\u0131labilir. Bir interface okuma ve yazma methodlar\u0131n\u0131 bar\u0131nd\u0131r\u0131yorsa ve dosya objesi bu methodlara sahipse dosyan\u0131n bu interfacei implement etti\u011fi s\u00f6ylenebilir. Interfacelerin as\u0131l amac\u0131 methodlar\u0131, ald\u0131klar\u0131 parametreleri ve d\u00f6n\u00fc\u015f de\u011ferlerini genel bir \u015fekilde tan\u0131mlayarak; ayn\u0131 davran\u0131\u015f\u0131 g\u00f6steren, fakat farkl\u0131 i\u015flerde kullan\u0131lan yap\u0131lar i\u00e7in ortak bir protokol olu\u015fturmakt\u0131r. Tan\u0131mlama \u00b6 GO dilinde interfaceler objelerle kapal\u0131 halde uygulan\u0131r. Ba\u015fka bir deyi\u015fle; bir tipin bir interfacei kulland\u0131\u011f\u0131n\u0131 belirtmek i\u00e7in, di\u011fer \u00e7o\u011fu nesne y\u00f6nelimli dillerde oldu\u011fu gibi, class File implements IO gibi deyimler kullanmam\u0131z gerekmez. GO ayn\u0131 metodlar\u0131 payla\u015fan interface ve tipler aras\u0131ndaki ili\u015fkiyi kendisi kurar. type IOInterface interface { Read () [] byte Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } type Socket struct { ip string port int buffer [] byte } func ( sock * Socket ) Read () [] byte { return sock . buffer } func ( sock * Socket ) Write ( stream [] byte ) int { sock . buffer = append ( sock . buffer , stream ... ) return len ( stream ) } file := File { name : \"test\" , } sock := Socket { ip : \"0.0.0.0\" , port : 21 , } data := [] byte ( \"data\" ) file . Write ( data ) sock . Write ( file . Read ()) string ( sock . Read () // \"data\" Yukar\u0131daki uygulamada Read ve Write metodlar\u0131n\u0131 tan\u0131mlayan IOInterface interfaceini ve bu methodlara sahip File ve Socket tiplerini tan\u0131mlad\u0131k. Kullan\u0131m \u00b6 A\u015fa\u011f\u0131daki \u00f6rnekte Log methodu IOInterface interfaceini parametre olarak ald\u0131\u011f\u0131 i\u00e7in hangi veri tipinden geldi\u011fini \u00f6nemsemeden veriyi okuyup, i\u015fini yapabilir. type Logger struct { } func ( log * Logger ) Log ( io IOInterface ) { for _ , data := range io . Read () { fmt . Print ( string ( data )) } fmt . Println () } file := & File { name : \"test\" , } sock := & Socket { ip : \"0.0.0.0\" , port : 21 , } logger := Logger {} data := [] byte ( \"data\" ) file . Write ( data ) sock . Write ( file . Read ()) logger . Log ( file ) // \"data\" logger . Log ( sock ) // \"data\" Birden Fazla interface kullanma \u00b6 GO tipleri birden fazla interfacei implement edebilir. Bunun i\u00e7in interfacein belirtti\u011fi metodlara sahip olmalar\u0131 yeterlidir. type Reader interface { Read () [] byte } type Writer interface { Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } var file Reader = & File { name : \"test\" , content : [] byte ( \"data\" ), } var sock Writer = & Socket { ip : \"0.0.0.0\" , port : 21 , } sock . Write ( file . Read ()) sock . buffer // sock.buffer undefined (type Writer has no field or method buffer Tip d\u00f6n\u00fc\u015f\u00fcm\u00fc \u00b6 s := sock .( * Socket ) string ( s . buffer ) // \"data\" D\u00f6n\u00fc\u015ft\u00fcrd\u00fc\u011f\u00fcm\u00fcz tipin o interfacei do\u011fru bir \u015fekilde implement edip etmedi\u011fini d\u00f6n\u00fc\u015f\u00fcm s\u0131ras\u0131nda alaca\u011f\u0131m\u0131z ek bir parametre ile kontrol edebiliriz. type Serializer interface { Serialize () } s , ok := sock .( Serializer ) s , ok // nil, false Bo\u015f interface \u00b6 Interfaceler de di\u011fer veri yap\u0131lar\u0131 gibi tiplerdir ve ayn\u0131 \u015fekilde kullan\u0131labilir. GO projelerinde bo\u015f interface; interface{} \u015feklinde tan\u0131mlan\u0131r. Hi\u00e7bir metodu olmad\u0131\u011f\u0131 i\u00e7in bo\u015f interfacein gereksinimleri b\u00fct\u00fcn tipler taraf\u0131ndan kar\u015f\u0131lan\u0131r. bo\u015f interfacein bu \u00f6zelli\u011fi, dinamik parametreler ve de\u011ferler tan\u0131mlamam\u0131za olanak tan\u0131r. type Booking struct { Provider string CustomerID string ExtraProviderParams interface {} } booking1 := Booking { Provider : \"ACL\" , CustomerID : \"customer-01a\" , ExtraProviderParams : map [ string ] interface {}{ \"Passengers\" : 4 , \"PaymentTime\" : \"after-booking\" , }, } booking2 := Booking { Provider : \"DCM\" , CustomerID : \"customer-03f\" , ExtraProviderParams : [] interface {}{ 4 , \"after-booking\" , }, } booking1 // {ACL customer-01a map[Passengers:4 PaymentTime:after-booking]} booking2 // {DCM customer-01a [4 after-booking]} Tip Kontrol\u00fc \u00b6 Interface tipleri switch yap\u0131s\u0131 ile kontrol edilebilir. A\u015fa\u011f\u0131daki \u00f6rnekte Stringify fonksiyonu interface{} tipinde parametre olarak alarak farkl\u0131 veri tiplerini fonksiyonda kullanmam\u0131za olanak sa\u011fl\u0131yor. Bu fonksiyonda int string ve float gelen de\u011ferleri tiplerine g\u00f6re kontrol edip belirledi\u011fimiz \u015fekilde stringe \u00e7evirece\u011fiz. func Stringify ( value interface {}) ( string , error ) { switch value .( type ) { case string : return value .( string ), nil case float32 , float64 : return fmt . Sprintf ( \"%.2f\" , value ), nil case int : return fmt . Sprintf ( \"%d\" , value ), nil default : return \"\" , errors . New ( \"Invalid type\" ) } } Stringify ( 12 ) // \"12\" Stringify ( 12.52312313 ) // \"12.52\" Stringify ( \"test\" ) // \"test\"","title":"Veri Yap\u0131lar\u0131"},{"location":"tr/data-structures/#veri-yaplar","text":"English | T\u00fcrk\u00e7e Bu sayfa go diline ait veri yap\u0131lar\u0131 ve bu yap\u0131lar\u0131n genel programlamada uygulanan y\u00f6ntemlerle kullan\u0131m\u0131 anlat\u0131lmaktad\u0131r.","title":"Veri Yap\u0131lar\u0131"},{"location":"tr/data-structures/#array","text":"Arrayler ayn\u0131 tipteki verileri bir arada muhafaza etmemizi sa\u011flayan yap\u0131lard\u0131r. \u00d6rne\u011fin; 4, 5, 19 ve 25'ten olu\u015fan veri b\u00fct\u00fcn\u00fc arrayi tan\u0131mlar. Go farkl\u0131 tipteki verilerden array olu\u015fturmam\u0131za izin vermez.","title":"Array"},{"location":"tr/data-structures/#tanmlama","text":"Arrayler temel olarak [Boyut]Tip bi\u00e7iminde tan\u0131mlan\u0131r. Arrayleri olu\u015fturman\u0131n \u00e7e\u015fitli yollar\u0131n\u0131 a\u015fa\u011f\u0131da g\u00f6rebiliriz. string tipinde 3 birim tutabilen array. var fruits [ 3 ] string B\u00f6yle tan\u0131mland\u0131\u011f\u0131nda arraydeki her bir alan, veri tipinin \u00f6n tan\u0131ml\u0131 de\u011feri ile doldurulur. Bu \u00f6rne\u011fi baz al\u0131rsak [\"\", \"\", \"\"] olarak tan\u0131mlanacakt\u0131r. Bu de\u011ferleri bulunduklar\u0131 indexler \u00fczerinden eri\u015ferek de\u011fi\u015ftirebiliriz. fruits [ 0 ] = \"\ud83c\udf4c\" fruits [ 1 ] = \"\ud83c\udf4f\" fruits // [\ud83c\udf4c \ud83c\udf4f ] Array i\u00e7in tan\u0131mlanan\u0131n d\u0131\u015f\u0131ndaki bir veri tipini kullan\u0131rsak hata ile kar\u015f\u0131la\u015f\u0131r\u0131z. arr [ 2 ] = 1 cannot use 1 ( type int ) as type string in assignment Ayn\u0131 arrayi daha k\u0131sa bir yol ile de tan\u0131mlayabiliriz. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" } fruits // [\ud83c\udf4c \ud83c\udf4f ] Bu tan\u0131mlamada ilk 2 eleman\u0131n\u0131 do\u011frudan tan\u0131mlad\u0131\u011f\u0131m\u0131z 3 birim uzunlu\u011fundaki bir arrayi arr de\u011fi\u015fkenine atad\u0131k. E\u011fer arrayi de\u011ferleri ile birlikte olu\u015fturulacaksak ... ifadesini kullan\u0131larak, boyut hesaplama k\u0131sm\u0131 compilera b\u0131rak\u0131labiliriz. fruits := [ ... ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf49] D\u00f6ng\u00fc ile kullanma Arrayler for d\u00f6ng\u00fcs\u00fc ile temel olarak 2 \u015fekilde kullan\u0131labilir. \u0130ndex ile eri\u015ferek. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } for index := range fruits { fruit := fruits [ index ] fmt . Println ( fruit ) } Do\u011frudan de\u011fere eri\u015ferek. fruits := [ 3 ] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf49\" } for _ , fruit := range fruits { fmt . Println ( fruit ) }","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#slice","text":"Slicelar kullan\u0131m bak\u0131m\u0131ndan arraylere \u00e7ok benzer. Slicelar\u0131n fark\u0131, boyutlar\u0131n\u0131n dinamik olmas\u0131. Slice tan\u0131mlarken yine arraydeki gibi []Tip yap\u0131s\u0131n\u0131 kullan\u0131yoruz fakat k\u00f6\u015feli parantezlerin i\u00e7ini bo\u015f b\u0131rak\u0131yoruz. // nil slice tan\u0131mlama var slc [] int // nill slice'a de\u011fer atama slc = [] int { 12 , 24 , 39 } // do\u011frudan tan\u0131mlama slc := [] int { 12 , 24 , 39 }","title":"Slice"},{"location":"tr/data-structures/#make","text":"Slicelar\u0131 tan\u0131mlamak i\u00e7in `make` fonksiyonunu da kullanabiliriz. make fonksiyonunun ilk parametresi olu\u015fturulacak slice\u0131n boyutunu belirler. make fonksiyonuna slice tipini ve tutulacak eleman say\u0131s\u0131n\u0131 vererek yeni bir slice olu\u015fturabiliriz. B\u00f6yle tan\u0131mland\u0131\u011f\u0131nda, bellekten \u00e7al\u0131\u015fma zaman\u0131nda slice\u0131n tutaca\u011fi elemanlar\u0131n boyutu ve eleman say\u0131s\u0131 kadar alan ayr\u0131l\u0131r. // define by size n_items = 3 slc := make ([] int , n_items ) \u00c7al\u0131\u015fma zaman\u0131nda bellekten alan almak maliyetli olabilir. E\u011fer slice\u0131n boyutu hakk\u0131nda bir tahminimiz varsa 3. bir parametre olarak slice kapasitesini verebiliriz. // definition by size and capacity n_items = 3 capacity := 5 slc := make ([] int , n_items , capacity )","title":"make"},{"location":"tr/data-structures/#slice-islemleri","text":"Slice olu\u015fturulurken kapasitesi kadar, tutaca\u011f\u0131 veri tipinin \u00f6n tan\u0131ml\u0131 de\u011feri ile doldurulur. Fakat, yaln\u0131zca uzunlu\u011fu kadar k\u0131sm\u0131na eri\u015filebilir. Bir slice\u0131n boyutunu art\u0131rmak istiyorsak bunun i\u00e7in append ve copy fonksiyonlar\u0131n\u0131 kullanabiliriz.","title":"Slice \u0130\u015flemleri"},{"location":"tr/data-structures/#mutate","text":"Bir slice\u0131 yeniden boyutland\u0131r\u0131p ba\u015fka bir de\u011fi\u015fkene atad\u0131\u011f\u0131m\u0131zda, yeni slicedaki de\u011fi\u015fiklikler orjinal slice\u0131 da etkileyecektir. fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := fruits [: 2 ] apples [ 0 ] = \"\ud83c\udf4f\" apples [ 1 ] = \"\ud83c\udf4f\" apples // [\ud83c\udf4f \ud83c\udf4f] fruits // [\ud83c\udf4f \ud83c\udf4f \ud83c\udf47 \ud83c\udf52 \ud83c\udf49]","title":"mutate"},{"location":"tr/data-structures/#copy","text":"copy bir slice\u0131 ayn\u0131 veya daha b\u00fcy\u00fck kapasiteye sahip bir di\u011fer slicea kopyalamam\u0131z\u0131 sa\u011flar ve ka\u00e7 adet eleman\u0131n kopyaland\u0131\u011f\u0131n\u0131 d\u00f6nd\u00fcr\u00fcr. bucket := make ([] string , 5 ) fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } n_copied := copy ( bucket , fruits ) n_copied // 5 bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49] Bir slice kopyalan\u0131rken, elemanlar hedef slicedaki ayn\u0131 indexdeki elemanlar\u0131n yerini al\u0131r. fruits := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4e\" , \"\" , \"\ud83c\udf4f\" } copy ( fruits , apples ) fruits // [\ud83c\udf4e \ud83c\udf4f]","title":"copy"},{"location":"tr/data-structures/#filter","text":"Slice elemanlar\u0131n\u0131 belirli bir kritere g\u00f6re filtreleyebiliriz. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" , \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } apple_criteria := \"\ud83c\udf4e\" apples := [] string {} for _ , fruit := range fruits { if fruit == apple_criteria { apples = append ( apples , fruit ) } } apples // [\ud83c\udf4e \ud83c\udf4e]","title":"filter"},{"location":"tr/data-structures/#append","text":"append fonksiyonu, ilk parametre olarak boyutunu art\u0131raca\u011f\u0131m\u0131z slice\u0131 ve devam\u0131nda ekleyece\u011fimiz elemanlar\u0131 al\u0131r ve bize t\u00fcm elemanlar\u0131 i\u00e7eren yeni bir slice d\u00f6nd\u00fcr\u00fcr. Bu nedenle, d\u00f6n\u00fc\u015f de\u011ferini bir de\u011fi\u015fkende(genellikle eski slice de\u011fi\u015fkeninde) tutmak gerekir. bucket := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } green_apple := \"\ud83c\udf4f\" bucket = append ( bucket , green_apple ) bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf4f]","title":"append"},{"location":"tr/data-structures/#pop","text":"A\u015fa\u011f\u0131daki \u00f6rnekte slice\u0131n son eleman\u0131n\u0131 \u00e7\u0131kar\u0131p bir de\u011fi\u015fkene atad\u0131k. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } item , fruits := fruits [ len ( fruits ) - 1 ], fruits [: len ( fruits ) - 1 ] item // \ud83c\udf49 fruits // [\ud83c\udf4f \ud83c\udf4e]","title":"pop"},{"location":"tr/data-structures/#push-front-unshift","text":"Bu \u00f6rnekte yeni bir eleman\u0131 slice\u0131n ba\u015f\u0131na koyduk. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" fruits = append ([] string { banana }, fruits ... ) fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"push front (unshift)"},{"location":"tr/data-structures/#pop-front-shift","text":"Bu \u00f6rnekte de slice\u0131n ilk eleman\u0131n\u0131 \u00e7\u0131kar\u0131p bir de\u011fi\u015fkene atad\u0131k. fruits := [] string { \"\ud83c\udf4c\" , \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana , fruits := fruits [ 0 ], fruits [ 1 :] banana // \ud83c\udf4c fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"pop front (shift)"},{"location":"tr/data-structures/#insert","text":"Slice\u0131n herhangi bir k\u0131sm\u0131na yeni bir eleman eklemek istiyorsak; bu y\u00f6ntemleri kullanabiliriz. fruits := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" insert_index := 2 fruits = append ( fruits [: insert_index ], append ([] string { banana }, fruits [ insert_index :] ... ) ... , ) fruits // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf4c \ud83c\udf52 \ud83c\udf49] append([]string{banana}, fruits[insert_index:]...) ifadesi ba\u015fl\u0131 ba\u015f\u0131na bir slice olu\u015fturup, fruits[insert_index:] slice\u0131n\u0131n elemanlar\u0131n\u0131 bu slicea kopyal\u0131yor. Bu elemanlar daha sonra fruits slice\u0131na tekrar kopyalan\u0131yor. Yeni bir slice olu\u015fturulmas\u0131n\u0131n ve 2. kez kopyalama i\u015fleminin \u00f6n\u00fcne ge\u00e7ilebilir. fruits := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" , \"\ud83c\udf49\" } banana := \"\ud83c\udf4c\" insert_index := 2 fruits = append ( fruits , \"\" ) copy ( fruits [ insert_index + 1 :], fruits [ insert_index :]) fruits [ insert_index ] = banana fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49]","title":"insert"},{"location":"tr/data-structures/#expand","text":"Bir slice\u0131, di\u011feri birle\u015ftirmek istersek a\u015fa\u011f\u0131daki y\u00f6ntemleri kullanabiliriz. bucket := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } bucket = append ( bucket , apples ... ) bucket // [\ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf4f \ud83c\udf4e] A\u015fa\u011f\u0131daki \u00f6rnekte 7. sat\u0131rda apples ile belirledi\u011fimiz indexten sonraki elemanlar\u0131 birle\u015ftirdik. Sonras\u0131nda belirledi\u011fimiz indexe kadar olan bucket elemanlar\u0131na, bu slice elemanlar\u0131n\u0131 ekledik. bucket := [] string { \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" } apples := [] string { \"\ud83c\udf4f\" , \"\ud83c\udf4e\" } expand_index := 2 bucket = append ( bucket [: expand_index ] append ( apples , bucket [ expand_index :] ... ) ... , ) bucket // [\ud83c\udf47 \ud83c\udf52 \ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"expand"},{"location":"tr/data-structures/#cut","text":"Slicedaki belli bir aral\u0131\u011f\u0131 \u00e7\u0131karmak istiyorsak a\u015fa\u011f\u0131daki y\u00f6ntemi kullanabiliriz. Bu y\u00f6ntem Sliceda belirledi\u011fimiz ba\u015flang\u0131\u00e7 indexine kadar olan elemanlar ile biti\u015f indexinden sonraki elemanlar\u0131 ekleyecek. B\u00f6ylece aradaki elemanlar\u0131 bo\u015fa \u00e7\u0131kartm\u0131\u015f olaca\u011f\u0131z. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } cut_start_index , cut_end_index := 4 , 6 edibles = append ( edibles [: cut_start_index ], edibles [ cut_end_index :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54]","title":"cut"},{"location":"tr/data-structures/#cut-memory-safe","text":"Bellek adresi tutan slicelar \u00fczerinde i\u015flem yapmak memory-leak olu\u015fturabilir. A\u015fa\u011f\u0131daki \u00f6rneklerde yapt\u0131\u011f\u0131m\u0131z i\u015flemlere ek olarak, i\u015flemimden sonra bo\u015fta kalan alanlar\u0131 nil de\u011ferleri ile doldurduk. B\u00f6ylece, garbage-collector bu alanlar\u0131n art\u0131k kullan\u0131lmayaca\u011f\u0131n\u0131 anlayabilir ve onlar\u0131 sisteme geri kazand\u0131rabilir. apple , grapes , cherry , wmelon := \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" pepper , egplnt , corn , potato := \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" edibles := [] * string { & apple , & grapes , & cherry , & wmelon , & pepper , & egplnt , & corn , & potato } cut_start_index , cut_end_index := 4 , 6 copy ( edibles [ cut_start_index :], edibles [ cut_end_index :]) cleanup_index := len ( edibles ) - cut_end_index + cut_start_index for free_index , free_end := cleanup_index , len ( edibles ); free_index < free_end ; free_index ++ { edibles [ free_index ] = nil } edibles = edibles [: cleanup_index ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54]","title":"cut (memory safe)"},{"location":"tr/data-structures/#delete","text":"Slicedaki bir eleman\u0131 indexini kullanarak silmek istiyorsak, a\u015fa\u011f\u0131daki y\u00f6ntemi kullanabiliriz. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } index_of_cherry := 2 edibles = append ( edibles [: index_of_cherry ], edibles [ index_of_cherry + 1 :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54]","title":"delete"},{"location":"tr/data-structures/#sralamay-dikkate-almadan-silme","text":"Silme i\u015flemini array s\u0131ralamas\u0131n\u0131 g\u00f6z ard\u0131 ederek de yapabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte, silmek istedi\u011fimiz eleman ile slicedaki en son eleman\u0131n yerini de\u011fi\u015ftirdik. Ard\u0131ndan slice\u0131n boyutunu 1 azaltt\u0131k. edibles := [] string { \"\ud83c\udf4e\" , \"\ud83c\udf47\" , \"\ud83c\udf52\" , \"\ud83c\udf49\" , \"\ud83c\udf36\" , \"\ud83c\udf46\" , \"\ud83c\udf3d\" , \"\ud83e\udd54\" } index_of_cherry := 2 edibles [ index_of_cherry ] = edibles [ len ( edibles ) - 1 ] edibles = edibles [: len ( edibles ) - 1 ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83e\udd54 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d]","title":"S\u0131ralamay\u0131 Dikkate Almadan Silme"},{"location":"tr/data-structures/#map","text":"En s\u0131k kullan\u0131lan veri tiplerinden birisi de maplerdir. map unique anahtarlar\u0131, de\u011ferlerle e\u015fle\u015ftirebilen sonras\u0131nda bu anahtarla e\u015fle\u015ftirilen de\u011fere eri\u015filmesini sa\u011flayan yap\u0131lard\u0131r.","title":"Map"},{"location":"tr/data-structures/#tanmlama_1","text":"Mapler map[AnahtarTipi]De\u011ferTipi veya make(map[AnahtarTipi]De\u011ferTipi) \u015feklinde tan\u0131mlanabilir. var mymap = map [ string ] string {} mymap = make ( map [ string ] string )","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#deger-atama","text":"monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"1979\" : \"Life of Brian\" , } monty_python_films_by_year [ \"1983\" ] = \"The Meaning of Life\" Atad\u0131\u011f\u0131m\u0131z de\u011ferlere, yine ayn\u0131 keyi kullanarak eri\u015febiliriz. film_name := monty_python_films_by_year [ \"1983\" ] film_name // The Meaning of Life Mapin bir eleman\u0131na eri\u015firken, eleman\u0131n mapde kay\u0131tl\u0131 olup olmad\u0131\u011f\u0131n\u0131 g\u00f6steren ek bir de\u011fere daha eri\u015febiliriz. film_name , registered := monty_python_films_by_year [ \"2019\" ] if ! registered { fmt . Println ( \"Monty python did not relase a film at 2019\" ) } else { fmt . Println ( film_name ) }","title":"De\u011fer Atama"},{"location":"tr/data-structures/#dongu-ile-kullanma","text":"Map elemanlar\u0131na temelde 2 yolla eri\u015filebilir. For d\u00f6ng\u00fcs\u00fcnde tek de\u011fi\u015fken kullan\u0131p, keyler \u00fczerinden eri\u015ferek. monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"1979\" : \"Life of Brian\" , \"1983\" : \"The Meaning of Life\" , } for year := range monty_python_films_by_year { film_name := monty_python_films_by_year [ year ] fmt . Println ( film_name , \"was released at\" , year ) } D\u00f6ng\u00fcde 2 de\u011fi\u015fken kullan\u0131p, hem anahtar hem de de\u011fere eri\u015ferek. for year , film_name := range monty_python_films_by_year { fmt . Println ( film_name , \"was released at\" , year ) } /* Monty Python and the Holy Grail was released at 1971 Life of Brian was released at 1979 The Meaning of Life was released at 1983 */","title":"D\u00f6ng\u00fc ile kullanma"},{"location":"tr/data-structures/#delete_1","text":"Mapdeki bir eleman\u0131 silmek i\u00e7in delete fonksiyonunu kullanabiliriz. monty_python_films_by_year := map [ string ] string { \"1971\" : \"Monty Python and the Holy Grail\" , \"2016\" : \"Batman v Superman\" , } delete ( monty_python_films_by_year , \"2016\" ) _ , registered := monty_python_films_by_year [ \"2016\" ] registered // false len ( monty_python_films_by_year ) // 1","title":"delete"},{"location":"tr/data-structures/#struct","text":"Structlar kullan\u0131c\u0131 taraf\u0131ndan tan\u0131mlanan ve farkl\u0131 t\u00fcrdeki verileri isimleri ile tutabilen veri yap\u0131lar\u0131d\u0131r.","title":"struct"},{"location":"tr/data-structures/#tanmlama_2","text":"Structlar a\u015fa\u011f\u0131daki yap\u0131da tan\u0131mlanabilir. type StructName struct { field fieldType } Struct\u0131n ayn\u0131 tipteki alanlar\u0131n\u0131 tek sat\u0131rda tan\u0131mlayabiliriz. type Film struct { name , director string imdb float32 release_year int } var new_film = Film {} new_film // {\"\" \"\" 0 0} Struct alanlar\u0131na ek olarak etiket de verebiliriz. type Film struct { Name string `json:\"film_name\"` Director string `json:\"director_name\"` Imdb float32 `json:\"imdb_score\"` ReleaseYear int `json:\"year_of_release\"` } Etiketler tip d\u00f6n\u00fc\u015f\u00fcm\u00fc ile \u00e7ok\u00e7a u\u011fra\u015fan ORMler ve serialization k\u00fct\u00fcphaneleri aras\u0131nda pop\u00fclerdir. Bu etiketlere reflect mod\u00fcl\u00fc ile eri\u015filebilir. f := Film {} t := reflect . TypeOf ( f ) for _ , f := range [] string { \"Name\" , \"Director\" , \"Imdb\" , \"ReleaseYear\" } { field , found := t . FieldByName ( f ) if ! found { continue } fmt . Println ( field . Tag . Get ( \"json\" )) } /* film_name director_name imdb_score year_of_release */","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#deger-atama_1","text":"Bir struct, parametreleri s\u0131ras\u0131yla verilerek olu\u015fturulabilir. new_film := Film { \"Mad Max: Fury Road\" , \"George Miller\" , 8.1 , 2015 } new_film // {Mad Max: Fury Road George Miller 8.1 2015} Benzer bi\u00e7imde, parametreleri ve alacaklar\u0131 de\u011ferleri : ayrac\u0131 ile belirterek de olu\u015fturulabilir. new_film := Film { Name : \"Ran\" , Director : \"Akira Kurosawa\" , Imdb : 8.2 , ReleaseYear : 1985 , } new_film // {Ran Akira Kurosawa 8.2 1985} Struct olu\u015ftururken baz\u0131 alanlar bo\u015f b\u0131rak\u0131l\u0131rsa; bu alanlar o veri tipinin bo\u015f de\u011ferleri ile tan\u0131mlan\u0131r. new_film := Film { name : \"Batman v Superman\" , director : \"Zack Snyder\" , release_year : 2016 , } new_film // {Batman v Superman Zack Snyder 0 2016}","title":"De\u011fer Atama"},{"location":"tr/data-structures/#anonymous-struct","text":"Baz\u0131 \u00f6zel durumlarda structlar\u0131 fonksiyon g\u00f6vdesi i\u00e7erisinde tan\u0131mlamam\u0131z gerekebilir. Bunu a\u015fa\u011f\u0131daki y\u00f6ntemle yapabiliriz. provider_config := struct { name string baseUrl string apiKey string }{ name : \"mapbox\" , baseUrl : \"https://api.mapbox.com/geocoding/v5/\" , apiKey : \"123asds123\" , } provider_config // {mapbox https://api.mapbox.com/geocoding/v5/ 123asds123}","title":"Anonymous struct"},{"location":"tr/data-structures/#anonymous-fields","text":"Alan isimlerini belirtilmeden de struct tan\u0131mlanabilir. Bu tarz bir tan\u0131mlamada belirtilen veri tiplerinin birbirinden farkl\u0131 olmas\u0131 gerekir. type Item struct { string // code int // quantity float32 // price } item := Item { \"child-seat-1\" , 5 , 20.1 , } item // {child-seat 5 20.1}","title":"Anonymous fields"},{"location":"tr/data-structures/#promoted-fields","text":"Bir struct ba\u015fka bir struct i\u00e7erisinde alan ismi verilmeden kullan\u0131labilir. Bu durumda i\u00e7erideki structa kendi ismiyle eri\u015filir. A\u015fa\u011f\u0131daki \u00f6rne\u011fi baz al\u0131rsak Page i\u00e7erisindeki Content e page.Content \u015feklinde eri\u015filebilir. type Content struct { body string size int } type Page struct { nextUrl string previousURL string Content } content := Content { body : \"<h1>Hi</h1>\" , size : 11 , } page := Page { nextUrl : \"http://.../3\" , previousURL : \"http://.../1\" , Content : content , } page // {http://.../3 http://.../1 {<h1>Hi</h1> 11}} page . Content // {<h1>Hi</h1> 11}","title":"Promoted fields"},{"location":"tr/data-structures/#fonksiyonlar","text":"Genel olarak GO'da fonksiyonlar a\u015fa\u011f\u0131daki yap\u0131da tan\u0131mlan\u0131r. func fonksiyon_ad\u0131 ( [ parametre listesi ] ) [ d\u00f6n\u00fc\u015f de\u011ferlerinin tipleri ] { fonksiyon g\u00f6vdesi } func sigmoid ( value float64 ) float64 { return 1.0 / ( 1.0 + math . Exp ( - value )) } sigmoid ( 0.5 ) // 0.62246","title":"Fonksiyonlar"},{"location":"tr/data-structures/#parametreler","text":"GO fonksiyonlar\u0131na parametre olarak girilen de\u011fi\u015fkenler kopyalan\u0131r. Bu nedenle parametreler \u00fczerinde yap\u0131lan de\u011fi\u015fiklikler de\u011fi\u015fkenlerin fonksiyon d\u0131\u015f\u0131ndaki durumlar\u0131n\u0131 etkilemez. type Wallet struct { userID int balance float64 deposit float64 } func withdraw ( wallet Wallet , amount float64 ) { wallet . balance -= amount } Yukar\u0131daki kodda basit\u00e7e bir c\u00fczdan yap\u0131s\u0131 ve bu c\u00fczdandan para \u00e7ekebilen withdraw fonksiyonu tan\u0131mlad\u0131k. A\u015fa\u011f\u0131daki sat\u0131rlarda da bir adet c\u00fczdan olu\u015fturup bu fonksiyon ile kulland\u0131k. wallet := Wallet { userID : 1 , balance : 30000.12 , deposit : 40000.01 , } item_price := 10023.0 withdraw ( wallet , item_price ) wallet . balance // 3000.12 G\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere c\u00fczdandaki para de\u011fi\u015fmedi. Bu tarz kazalar\u0131 2 yolla \u00f6nleyebiliriz. Y\u00f6ntem, c\u00fczdandaki son para durumunu d\u00f6nd\u00fcr\u00fcp, c\u00fczdan\u0131 sonradan g\u00fcncelleyebiliriz. func withdraw ( wallet Wallet , amount float64 ) float64 { new_balance := wallet . balance - amount return new_balance } wallet . balance = withdraw ( wallet , item_price ) wallet . balance // 19977.12 Bu de\u011fi\u015fim, i\u015fi c\u00fczdandan para \u00e7ekmek olan withdraw fonksiyonunun kullan\u0131m amac\u0131n\u0131 de\u011fi\u015ftirmi\u015f oluyor. Y\u00f6ntem, c\u00fczdan de\u011fi\u015fkeni yerine, c\u00fczdan\u0131n adresini parametre olarak verebiliriz. func withdraw ( wallet * Wallet , amount float64 ) { wallet . balance -= amount } withdraw ( & wallet , item_price ) wallet . balance // 19977.12 Bu y\u00f6ntemin dezavantaj\u0131 da farkl\u0131 concurrency safe olmamas\u0131d\u0131r. Farkl\u0131 threadler ile c\u00fczdandan para \u00e7ekmek istedi\u011fimizde, bakiye durumunu takip etmek zor olacakt\u0131r.","title":"Parametreler"},{"location":"tr/data-structures/#dinamik-parametreler","text":"GO fonksiyonlar\u0131nda dinamik parametreler tan\u0131mlanabilir. Bu t\u00fcrdeki parametreleri tan\u0131mlamak i\u00e7in parametre tipinin \u00f6n\u00fcne ... i\u015fareti yaz\u0131l\u0131r. func ReLU ( nums ... float64 ) [] float64 { new_nums := make ([] float64 , len ( nums )) for idx , value := range nums { if value > 0 { new_nums [ idx ] = value } else { new_nums [ idx ] = 0. } } return new_nums } nums := [] float64 { 1. , 0.2 , 0. , 0. , - 0.1 , 0.1 } nums = ReLU ( nums ... ) nums // [1 0.2 0 0 0 0.1]","title":"Dinamik parametreler"},{"location":"tr/data-structures/#donus-degerleri","text":"","title":"D\u00f6n\u00fc\u015f De\u011ferleri"},{"location":"tr/data-structures/#birden-fazla-deger-dondurme","text":"GO fonksiyonlar\u0131nda birden fazla de\u011fer d\u00f6nd\u00fcr\u00fclebilir. D\u00f6n\u00fclecek de\u011ferleri () aras\u0131nda s\u0131ras\u0131yla tan\u0131mlamak gerekmektedir. func swap ( first_arg , second_arg string ) ( string , string ) { return second_arg , first_arg } var language1 , language2 string = \"Python\" , \"GO\" language1 , language2 = swap ( language1 , language2 ) language1 , language2 // GO Python","title":"Birden fazla de\u011fer d\u00f6nd\u00fcrme"},{"location":"tr/data-structures/#donus-degerlerini-isimlendirme","text":"Fonksiyonlar\u0131n d\u00f6n\u00fc\u015f de\u011ferlerine isim verip, de\u011ferleri bu de\u011fi\u015fkenler ile belirleyebiliriz. \u0130simlendirilmi\u015f d\u00f6n\u00fc\u015f de\u011ferleri veri tipinin bo\u015f de\u011ferini alaca\u011f\u0131 i\u00e7in, fonksiyonun \u00f6n tan\u0131ml\u0131 d\u00f6n\u00fc\u015f de\u011ferleri olarak da kullan\u0131labilirler. type Record struct { id int data string } type DB struct { records [] Record locked bool } func BulkCreate ( records [] Record , db * DB ) ( n_created int , err error ) { if db . locked { err = errors . New ( \"DB is locked\" ) } else { db . records = append ( db . records , records ... ) n_created = len ( records ) } return n_created , err } db := & DB { records : [] Record {}, locked : true , } data := [] Record {} for i := 0 ; i < 100 ; i ++ { rec := Record { id : i , data : \"test\" , } data = append ( data , rec ) } n_created , err := BulkCreate ( data , db ) if err != nil { fmt . Println ( err ) }","title":"D\u00f6n\u00fc\u015f de\u011ferlerini isimlendirme"},{"location":"tr/data-structures/#anonim-fonksiyon","text":"GO'da fonksiyonlar da veri yap\u0131lar\u0131d\u0131r ve di\u011fer fonksiyonlar\u0131n i\u00e7erisinde tan\u0131mlanabilirler. Anonim fonksiyonlar\u0131, projenin k\u0131s\u0131tl\u0131 bir b\u00f6l\u00fcm\u00fcnde, spesifik bir i\u015fi halletmek i\u00e7in kullanabiliriz. A\u015fa\u011f\u0131daki kod \u00f6rne\u011finde, projenin ba\u015fka yerinde bu i\u015fleme ihtiya\u00e7 duymayaca\u011f\u0131m\u0131z\u0131 varsayarak, bir slice\u0131 belirlenen boyutta par\u00e7alayan bir anonim fonksiyon kulland\u0131k. records := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } batchSize := 3 batchedRecords := func ( data [] int , batchSize int ) [][] int { var batches [][] int for batchSize < len ( data ) { data , batches = data [ batchSize :], append ( batches , data [ 0 : batchSize : batchSize ]) } batches = append ( batches , data ) return batches }( records , batchSize ) batchedRecords // [[0 1 2] [3 4 5] [6 7 8] [9]] Bu t\u00fcrdeki fonksiyonlar\u0131 bir de\u011fi\u015fkene atay\u0131p bir ka\u00e7 kez de kullanabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte spesifik bir APIden ayr\u0131 ayr\u0131 g\u00f6nderilen \u00fclke kodu ve telefon numaralar\u0131n\u0131 de\u011fi\u015fken olarak tan\u0131mlad\u0131\u011f\u0131m\u0131z fonksiyonla birle\u015ftirdik. type Vendor struct { name string countryCode string phone string } vendor := Vendor { name : \"Volswagen Group\" , countryCode : \"1\" , phone : \"403120120\" , } formatPhoneNumbers := func ( contact Vendor ) string { return \"+\" + contact . countryCode + contact . phone } formatPhoneNumbers ( vendor ) // +1403120120","title":"Anonim Fonksiyon"},{"location":"tr/data-structures/#metodlar","text":"GO dilinde di\u011fer nesne y\u00f6nelimli programlama dilleri gibi classlar ve kal\u0131t\u0131m yoktur. Fakat fonksiyonlara receiver denilen ek bir arg\u00fcman ekleyerek ile kendi olu\u015fturdu\u011fumuz tiplere fonksiyonlar\u0131 ba\u011flayabiliriz. B\u00f6ylece GO dilinde de nesne y\u00f6nelimli programlamaya benzer bir deneyim yakalanabilir. type Connection struct { host string port int timeOut int isClosed bool } func ( conn * Connection ) Close () { conn . isClosed = true fmt . Println ( \"Connection\" , conn . host + \":\" + strconv . Itoa ( conn . port ), \"closed.\" ) } Yukar\u0131daki yap\u0131da Close fonksiyonuna normal bir fonksiyona ek olarak (conn *Connection) k\u0131sm\u0131n\u0131 ekledik. B\u00f6ylece a\u015fa\u011f\u0131daki \u00f6rnekte g\u00f6r\u00fcld\u00fc\u011f\u00fc gibi c.Close() \u015feklinde Connection tipi \u00fczerinden fonksiyona eri\u015febildik. c := Connection { host : \"0.0.0.0\" , port : 8080 , timeOut : 1 , isClosed : false , } c . Close () // Connection 0.0.0.0:8080 closed.","title":"Metodlar"},{"location":"tr/data-structures/#pointer-receiver-value-receiver","text":"Fonksiyon parametrelerinde oldu\u011fu gibi receiverlerde de yap\u0131n\u0131n de\u011feri ile mi yoksa memory adresi ile mi kullan\u0131laca\u011f\u0131na karar verilmelidir. Receiverlar\u0131 struct d\u0131\u015f\u0131ndaki tipler i\u00e7in de kullanabiliriz. type Iterable [] int func ( iterable * Iterable ) Append ( items ... int ) { * iterable = append ( * iterable , items ... ) } arr := Iterable { 1 , 2 } arr . Append ( 4 , 5 , 6 ) arr // [1 2 4 5 6]","title":"Pointer receiver | Value receiver"},{"location":"tr/data-structures/#error","text":"GOda kendi hata tiplerimizi olu\u015fturabiliriz. Bunun i\u00e7in olu\u015fturdu\u011fumuz tipin sadece Error methoduna sahip olmas\u0131 yeterlidir.","title":"Error"},{"location":"tr/data-structures/#tanmlama_3","text":"A\u015fa\u011f\u0131daki \u00f6rnekte HTTP kodunu ve hata nedenini belirten HTTPError ad\u0131nda yeni bir hata tan\u0131mlad\u0131k. type HTTPError struct { Status int Reason string } func ( e HTTPError ) Error () string { return fmt . Sprintf ( \"%v: %v\" , e . Status , e . Reason ) } func MakeRequest () error { return HTTPError { Status : 400 , Reason : \"Bad Request\" , } }","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#kullanm","text":"Fonksiyon \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda d\u00f6n\u00fclen hata de\u011ferinin nil olup olmad\u0131\u011f\u0131 kontrol edilerek buna g\u00f6re \u00f6nlemler al\u0131nabilir. err := MakeRequest () if err != nil { fmt . Println ( err ) }","title":"Kullan\u0131m"},{"location":"tr/data-structures/#interface","text":"Interfaceler bir objenin sahip olabilece\u011fi methodlar\u0131 belirten yap\u0131lard\u0131r. Bu nedenle interfaceler objelerin davran\u0131\u015f\u0131n\u0131 ifade eder. \u00d6rne\u011fin; bir dosyandan veri okunabilir veya dosyaya veri yaz\u0131labilir. Bir interface okuma ve yazma methodlar\u0131n\u0131 bar\u0131nd\u0131r\u0131yorsa ve dosya objesi bu methodlara sahipse dosyan\u0131n bu interfacei implement etti\u011fi s\u00f6ylenebilir. Interfacelerin as\u0131l amac\u0131 methodlar\u0131, ald\u0131klar\u0131 parametreleri ve d\u00f6n\u00fc\u015f de\u011ferlerini genel bir \u015fekilde tan\u0131mlayarak; ayn\u0131 davran\u0131\u015f\u0131 g\u00f6steren, fakat farkl\u0131 i\u015flerde kullan\u0131lan yap\u0131lar i\u00e7in ortak bir protokol olu\u015fturmakt\u0131r.","title":"Interface"},{"location":"tr/data-structures/#tanmlama_4","text":"GO dilinde interfaceler objelerle kapal\u0131 halde uygulan\u0131r. Ba\u015fka bir deyi\u015fle; bir tipin bir interfacei kulland\u0131\u011f\u0131n\u0131 belirtmek i\u00e7in, di\u011fer \u00e7o\u011fu nesne y\u00f6nelimli dillerde oldu\u011fu gibi, class File implements IO gibi deyimler kullanmam\u0131z gerekmez. GO ayn\u0131 metodlar\u0131 payla\u015fan interface ve tipler aras\u0131ndaki ili\u015fkiyi kendisi kurar. type IOInterface interface { Read () [] byte Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } type Socket struct { ip string port int buffer [] byte } func ( sock * Socket ) Read () [] byte { return sock . buffer } func ( sock * Socket ) Write ( stream [] byte ) int { sock . buffer = append ( sock . buffer , stream ... ) return len ( stream ) } file := File { name : \"test\" , } sock := Socket { ip : \"0.0.0.0\" , port : 21 , } data := [] byte ( \"data\" ) file . Write ( data ) sock . Write ( file . Read ()) string ( sock . Read () // \"data\" Yukar\u0131daki uygulamada Read ve Write metodlar\u0131n\u0131 tan\u0131mlayan IOInterface interfaceini ve bu methodlara sahip File ve Socket tiplerini tan\u0131mlad\u0131k.","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#kullanm_1","text":"A\u015fa\u011f\u0131daki \u00f6rnekte Log methodu IOInterface interfaceini parametre olarak ald\u0131\u011f\u0131 i\u00e7in hangi veri tipinden geldi\u011fini \u00f6nemsemeden veriyi okuyup, i\u015fini yapabilir. type Logger struct { } func ( log * Logger ) Log ( io IOInterface ) { for _ , data := range io . Read () { fmt . Print ( string ( data )) } fmt . Println () } file := & File { name : \"test\" , } sock := & Socket { ip : \"0.0.0.0\" , port : 21 , } logger := Logger {} data := [] byte ( \"data\" ) file . Write ( data ) sock . Write ( file . Read ()) logger . Log ( file ) // \"data\" logger . Log ( sock ) // \"data\"","title":"Kullan\u0131m"},{"location":"tr/data-structures/#birden-fazla-interface-kullanma","text":"GO tipleri birden fazla interfacei implement edebilir. Bunun i\u00e7in interfacein belirtti\u011fi metodlara sahip olmalar\u0131 yeterlidir. type Reader interface { Read () [] byte } type Writer interface { Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } var file Reader = & File { name : \"test\" , content : [] byte ( \"data\" ), } var sock Writer = & Socket { ip : \"0.0.0.0\" , port : 21 , } sock . Write ( file . Read ()) sock . buffer // sock.buffer undefined (type Writer has no field or method buffer","title":"Birden Fazla interface kullanma"},{"location":"tr/data-structures/#tip-donusumu","text":"s := sock .( * Socket ) string ( s . buffer ) // \"data\" D\u00f6n\u00fc\u015ft\u00fcrd\u00fc\u011f\u00fcm\u00fcz tipin o interfacei do\u011fru bir \u015fekilde implement edip etmedi\u011fini d\u00f6n\u00fc\u015f\u00fcm s\u0131ras\u0131nda alaca\u011f\u0131m\u0131z ek bir parametre ile kontrol edebiliriz. type Serializer interface { Serialize () } s , ok := sock .( Serializer ) s , ok // nil, false","title":"Tip d\u00f6n\u00fc\u015f\u00fcm\u00fc"},{"location":"tr/data-structures/#bos-interface","text":"Interfaceler de di\u011fer veri yap\u0131lar\u0131 gibi tiplerdir ve ayn\u0131 \u015fekilde kullan\u0131labilir. GO projelerinde bo\u015f interface; interface{} \u015feklinde tan\u0131mlan\u0131r. Hi\u00e7bir metodu olmad\u0131\u011f\u0131 i\u00e7in bo\u015f interfacein gereksinimleri b\u00fct\u00fcn tipler taraf\u0131ndan kar\u015f\u0131lan\u0131r. bo\u015f interfacein bu \u00f6zelli\u011fi, dinamik parametreler ve de\u011ferler tan\u0131mlamam\u0131za olanak tan\u0131r. type Booking struct { Provider string CustomerID string ExtraProviderParams interface {} } booking1 := Booking { Provider : \"ACL\" , CustomerID : \"customer-01a\" , ExtraProviderParams : map [ string ] interface {}{ \"Passengers\" : 4 , \"PaymentTime\" : \"after-booking\" , }, } booking2 := Booking { Provider : \"DCM\" , CustomerID : \"customer-03f\" , ExtraProviderParams : [] interface {}{ 4 , \"after-booking\" , }, } booking1 // {ACL customer-01a map[Passengers:4 PaymentTime:after-booking]} booking2 // {DCM customer-01a [4 after-booking]}","title":"Bo\u015f interface"},{"location":"tr/data-structures/#tip-kontrolu","text":"Interface tipleri switch yap\u0131s\u0131 ile kontrol edilebilir. A\u015fa\u011f\u0131daki \u00f6rnekte Stringify fonksiyonu interface{} tipinde parametre olarak alarak farkl\u0131 veri tiplerini fonksiyonda kullanmam\u0131za olanak sa\u011fl\u0131yor. Bu fonksiyonda int string ve float gelen de\u011ferleri tiplerine g\u00f6re kontrol edip belirledi\u011fimiz \u015fekilde stringe \u00e7evirece\u011fiz. func Stringify ( value interface {}) ( string , error ) { switch value .( type ) { case string : return value .( string ), nil case float32 , float64 : return fmt . Sprintf ( \"%.2f\" , value ), nil case int : return fmt . Sprintf ( \"%d\" , value ), nil default : return \"\" , errors . New ( \"Invalid type\" ) } } Stringify ( 12 ) // \"12\" Stringify ( 12.52312313 ) // \"12.52\" Stringify ( \"test\" ) // \"test\"","title":"Tip Kontrol\u00fc"},{"location":"tr/unit-testing/","text":"Unit Testing \u00b6 Code without tests is broken as designed. Jacob Kaplan-Moss Giri\u015f \u00b6 Unit testing, projedeki fonksiyonel her bir birimin t\u00fcm davran\u0131\u015flar\u0131n\u0131n test edildi\u011fi yaz\u0131l\u0131m test y\u00f6ntemidir. Biraz daha a\u00e7mak gerekirse; bir birim, testi m\u00fcmk\u00fcn olan en k\u00fc\u00e7\u00fck yaz\u0131l\u0131m bile\u015fenidir ve \u00e7o\u011funlukla tek bir i\u015f, yapmakla g\u00f6revlidir. Unit testin amac\u0131, program\u0131n k\u00fc\u00e7\u00fck b\u00f6l\u00fcmlere ay\u0131r\u0131p, t\u00fcm b\u00f6l\u00fcmlerin beklenildi\u011fi gibi \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131ndan emin olmakt\u0131r. Unit testleri yaz\u0131lan bir projede: Projeye yeni eklenen kodun, istenildi\u011fi gibi \u00e7al\u0131\u015f\u0131p, \u00e7al\u0131\u015fmad\u0131\u011f\u0131n\u0131 kontrol edilebilir. Varolan kod d\u00fczenlendi\u011finde, projenin davran\u0131\u015f\u0131n\u0131n beklenmedik \u015fekilde de\u011fi\u015ftirmedi\u011finden emin olunur. Yaz\u0131l\u0131mc\u0131, projeye eklenecek karma\u015f\u0131k \u00f6zellikleri k\u00fc\u00e7\u00fck, anla\u015f\u0131l\u0131r par\u00e7alara b\u00f6lmesine dolay\u0131s\u0131yla i\u015fe yarar minimum fonksiyonelli\u011fe h\u0131zl\u0131ca eri\u015fip gereksiz optimizasyondan ka\u00e7\u0131nmas\u0131na yard\u0131mc\u0131 olur. Ekibe yeni kat\u0131lan yaz\u0131l\u0131mc\u0131lar, testleri d\u00f6k\u00fcman olarak kullanabilir. Testlerin bir projedeki b\u00fct\u00fcn hatalar\u0131 \u00e7\u00f6zmesi beklenmemelidir. Projelerde her zaman hata vard\u0131r. Bu hatalar, test edilmeyen bir durumdan, yanl\u0131\u015f test etmekten veya testlerin kontrol edemeyece\u011fi 3. parti k\u00fct\u00fcphanelerden, APIlerden, konfig\u00fcrasyon sorunlar\u0131nlar\u0131nda kaynakl\u0131 olabilir. Test etmek \u00b6 package main import \"fmt\" func main () { fmt . Println ( \"Hello, world\" ) } Yukar\u0131daki kodu test etmeden \u00f6nce yan etkilerden ar\u0131nd\u0131rmal\u0131y\u0131z. Buradaki side-effect Println fonksiyonu. package main import \"fmt\" func Hello () string { return \"Hello, world\" } func main () { fmt . Println ( Hello ()) } \u015eimdi Hello fonksiyonunu i\u00e7in test yazal\u0131m. func TestHello ( t * testing . T ) { got := Hello () want := \"Hello, world\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } Go testlerini \u00e7al\u0131\u015ft\u0131rmak i\u00e7in ek ara\u00e7lara veya frameworklere ihtiyac\u0131m\u0131z yok. Sadece go test komutu ile yazd\u0131\u011f\u0131m\u0131z testleri \u00e7al\u0131\u015ft\u0131rabiliriz. Test yazman\u0131n belirli kurallar \u00e7er\u00e7evesinde fonksiyonlar yazmaktan fark\u0131 yoktur. Bu fonksiyonlar\u0131n test olarak kabul edilmesi i\u00e7in: xxx_test.go gibi bir dosya i\u00e7inde olmas\u0131 Fonksiyon isminin Test ile ba\u015flamas\u0131 Fonksiyonun yaln\u0131zca t *testing.T parametresini almas\u0131 gerekir. Yeni \u00d6zellikler Eklemek \u00b6 Test ba\u015far\u0131l\u0131 bir \u015fekilde \u00e7al\u0131\u015ft\u0131\u011f\u0131na g\u00f6re art\u0131k uygulamaya yeni \u00f6zellikler ekleyebiliriz. \u015eimdi Hello fonksiyonu parametre olarak bir isim als\u0131n ve o ismi selamlas\u0131n. Bunun i\u00e7in \u00f6ncellikle kodun yeni halini test eden ve ba\u015far\u0131s\u0131z olan bir test yazaca\u011f\u0131z. func TestHello ( t * testing . T ) { got := Hello ( \"Mehmet\" ) want := \"Hello, Mehmet\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } Testi ge\u00e7irecek kadar kod yazal\u0131m. func Hello ( name string ) string { return \"Hello, Mehmet\" } Yukar\u0131daki \u00f6rnekte amac\u0131m\u0131z\u0131n d\u0131\u015f\u0131nda bir kod yazarak testin ge\u00e7mesini sa\u011flad\u0131k. Bu \u00f6rnek her ne kadar abes dursada, bu t\u00fcr durumlar daha b\u00fcy\u00fck \u00f6l\u00e7ekli i\u015flerde ba\u015f\u0131m\u0131za gelebilir ve fark edilmedi\u011finde anla\u015f\u0131lmas\u0131 zor buglar ortaya \u00e7\u0131kartabilir. Ekledi\u011fimiz \u00f6zelli\u011fin d\u00fczg\u00fcn \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan emin olmak i\u00e7in bir test daha ekleyelim. func TestHello ( t * testing . T ) { got := Hello ( \"Mehmet\" ) want := \"Hello, Mehmet\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } func TestHelloWithAnotherName ( t * testing . T ) { got := Hello ( \"Ahmet\" ) want := \"Hello, Ahmet\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } \u015eimdi de testi ge\u00e7ecek kodu yazal\u0131m. func Hello ( name string ) string { return \"Hello, \" + name } Bu a\u015famada elimizde testleri ile birlikte \u00e7al\u0131\u015fan yeni \u00f6zelli\u011fi commit edebiliriz. Bu a\u015famada, TDD ya\u015fam d\u00f6ng\u00fcs\u00fc gere\u011fi kod refactor edilmeye \u00e7al\u0131\u015f\u0131l\u0131r. \"Hello, \" her durumda sabit oldu\u011fu i\u00e7in globalde tan\u0131mlayabiliriz. const englishHelloPrefix = \"Hello, \" func Hello ( name string ) string { return englishHelloPrefix + name } Refactor yap\u0131ld\u0131ktan sonra mutlaka testler yeniden \u00e7al\u0131\u015ft\u0131r\u0131lmal\u0131 ve kod davran\u0131\u015f\u0131n\u0131n de\u011fi\u015fmedi\u011finden emin olunmal\u0131d\u0131r. \u015eimdi uygulamam\u0131za bir \u00f6zellik daha ekleyelim. Bu kez Hello fonksiyonuna bo\u015f isim verilince \u00f6n tan\u0131ml\u0131 mesajla selamlas\u0131n. Tabiki \u00f6nce testini yaz\u0131yoruz. Ayn\u0131 kod par\u00e7as\u0131 i\u00e7in yaz\u0131lan testleri tek fonksiyon alt\u0131nda toplayabiliriz. t.Run yap\u0131s\u0131 sayesinde verdi\u011fimiz farkl\u0131 test mesajlar\u0131 ile birlikte testleri bir araya getirebiliriz. func TestHello ( t * testing . T ) { t . Run ( \"Say hello to a specific name\" , func ( t * testing . T ) { got := Hello ( \"Mehmet\" ) want := \"Hello, Mehmet\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } }) t . Run ( \"Say 'Hello, Dude' when an empty string is provided\" , func ( t * testing . T ) { got := Hello ( \"\" ) want := \"Hello, Dude\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } }) } Refactoring sadece business logic i\u00e7eren kodlar i\u00e7in de\u011fildir. Test kodlar\u0131na da projede t\u0131pk\u0131 di\u011fer kodlar gibi yakla\u015f\u0131lmal\u0131d\u0131r. Bu a\u015famada testlerimizde tekrar eden k\u0131s\u0131mlar i\u00e7in bir fonksiyon yazabiliriz. func TestHello ( t * testing . T ) { assertCorrectMessage := func ( t * testing . T , got , want string ) { t . Helper () if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } t . Run ( \"Say hello to a specific name\" , func ( t * testing . T ) { got := Hello ( \"Mehmet\" ) want := \"Hello, Mehmet\" assertCorrectMessage ( t , got , want ) }) t . Run ( \"Say 'Hello, Dude' when an empty string is provided\" , func ( t * testing . T ) { got := Hello ( \"\" ) want := \"Hello, Dude\" assertCorrectMessage ( t , got , want ) }) } \u015eimdi elimizde d\u00fczg\u00fcn bir \u015fekilde yaz\u0131lm\u0131\u015f hata veren bir test var. Uygulamaya testi ge\u00e7mek i\u00e7in yeterli kodu yazal\u0131m. const englishHelloPrefix = \"Hello, \" func Hello ( name string ) string { if name == \"\" { name = \"Dude\" } return englishHelloPrefix + name } B\u00f6ylece uygulamam\u0131za \u00f6nceki \u00f6zellikleri etkilemeden yeni bir \u00f6zellik eklemi\u015f olduk. Bu a\u015famada eski commiti amend edip, fonksiyonumuzu yeni versiyonu ile de\u011fi\u015ftirebiliriz. Geli\u015ftirme Disiplini \u00b6 Yeni \u00f6zelli\u011fi kullanan bir test yaz Kodun derlendi\u011finden emin ol Testi \u00e7al\u0131\u015ft\u0131r, hatay\u0131 g\u00f6zlemle Testi ge\u00e7irecek minimum kodu yaz Refactor Bu kadar ad\u0131m zahmetli ve paranoyak\u00e7a gelebilir fakat her ad\u0131mda kodun durumunu kontrol etmek olduk\u00e7a \u00f6nemlidir. Bu disipline sad\u0131k kalarak sadece amac\u0131na uygun testler yazmakla kalmay\u0131z ayn\u0131 zamanda otomatikle\u015ftirilmi\u015f testlerle s\u00fcrekli d\u00fczenlenen ve iyi \u015fekilde tasarlanan bir yaz\u0131l\u0131m geli\u015ftirmi\u015f oluruz. Testlerin ne i\u00e7in yaz\u0131ld\u0131\u011f\u0131n\u0131 anla\u015f\u0131l\u0131r bir \u015fekilde hata mesaj\u0131nda g\u00f6stermek \u00e7ok \u00f6nemlidir. Yaz\u0131l\u0131mc\u0131n\u0131n, testin neden hata verdi\u011fini anlayamamas\u0131 problemi \u00e7\u00f6zmeyi zorla\u015ft\u0131racakt\u0131r. Testlerin h\u0131zl\u0131 \u00e7al\u0131\u015fmas\u0131 ve kolay bir \u015fekilde \u00e7al\u0131\u015ft\u0131r\u0131labilmesi gerekir. Bu ak\u0131c\u0131 bir \u015fekilde kod yazmam\u0131z\u0131 sa\u011flayacakt\u0131r. Testsiz kod yazarak, uygulaman\u0131n ak\u0131\u015f\u0131n\u0131 ve olas\u0131 her durumunu kontrol etme i\u015fini kendinize y\u00fcklemi\u015f olursunuz. Bu da uzun d\u00f6nemde ciddi vakit kayb\u0131na yol a\u00e7acakt\u0131r. Daha fazla \u00f6zellik \u00b6 Yeni iste\u011fe g\u00f6re uygulamam\u0131za dil deste\u011fi ekleyece\u011fiz. E\u011fer dil sistemimiz taraf\u0131ndan destekleniyorsa selamlama mesaj\u0131 verilen dilde sa\u011flanacak. Desteklenmiyorsa \u00f6n tan\u0131ml\u0131 olan \u0130ngilizce mesaj g\u00f6nderilecek. Ba\u015flang\u0131\u00e7 olarak Frans\u0131zca dil deste\u011fi i\u00e7in test yazal\u0131m. t . Run ( \"in French\" , func ( t * testing . T ) { got := Hello ( \"Lara Fabian\" , \"French\" ) want := \"Bonjour, Lara Fabian\" assertCorrectMessage ( t , got , want ) }) Bu haliyle Hello tek parametre ald\u0131\u011f\u0131 i\u00e7in compiler hata verecektir. Bu ad\u0131mda, hile yap\u0131p do\u011frudan kodu yazmaktan ka\u00e7\u0131nmal\u0131y\u0131z. Fonksiyona gerekli olan 2. parametreyi ekleyelim. func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } return englishHelloPrefix + name } Testleri \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda, yeni \u00f6zelli\u011fe g\u00f6re tasarlanmad\u0131\u011f\u0131 i\u00e7in eski testler hata verecektir. Eski testlere parametre olarak bo\u015f string vererek compiler hatas\u0131ndan kurtulal\u0131m. Bu durumda, sadece yeni ekledi\u011fimiz testin fail olmas\u0131 gerekir. \u015eimdi response bodyi Yeni bir if ekleyerek Frans\u0131zca i\u00e7in yazd\u0131\u011f\u0131m\u0131z testi ge\u00e7ebiliriz. func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } if language == \"French\" { return \"Bonjour, \" + name } return englishHelloPrefix + name } Bu haliyle b\u00fct\u00fcn testleri ba\u015far\u0131l\u0131 olmas\u0131 gerekiyor. \u015eimdi kodumuzu refactor edebiliriz. \u0130\u015fe, kod i\u00e7inde tan\u0131ml\u0131 stringlerden ba\u015flayabiliriz. Yap\u0131lan her de\u011fi\u015fiklikte testlerin ba\u015far\u0131l\u0131 oldu\u011funu kontrol etmeliyiz. const french = \"French\" const englishHelloPrefix = \"Hello, \" const frenchHelloPrefix = \"Bonjour, \" func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } if language == french { return frenchHelloPrefix + name } return englishHelloPrefix + name } Yeni dil \u00b6 \u015eimdi Koreceye de destek verelim. Bunun i\u00e7in daha \u00f6nce yapt\u0131\u011f\u0131m\u0131z gibi: Korean yazd\u0131\u011f\u0131m\u0131zda \uc548\ub155 ile ba\u015flayan bir mesaj bekleyen test yazaca\u011f\u0131z Testi \u00e7al\u0131\u015ft\u0131r\u0131p hata alaca\u011f\u0131z ve hata mesaj\u0131n\u0131n d\u00fczg\u00fcn oldu\u011funa dikkat edece\u011fiz Kod \u00fczerinde testi ge\u00e7ecek minimum de\u011fi\u015fikli\u011fi yapaca\u011f\u0131z De\u011fi\u015fikliklerden sonra elimizde a\u015fa\u011f\u0131 yukar\u0131 b\u00f6yle bir kod olacak: func TestHello ( t * testing . T ) { assertCorrectMessage := func ( t * testing . T , got , want string ) { t . Helper () if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } t . Run ( \"Say hello to a specific name\" , func ( t * testing . T ) { got := Hello ( \"Mehmet\" , \"\" ) want := \"Hello, Mehmet\" assertCorrectMessage ( t , got , want ) }) t . Run ( \"Say 'Hello, Dude' when an empty string is provided\" , func ( t * testing . T ) { got := Hello ( \"\" , \"\" ) want := \"Hello, Dude\" assertCorrectMessage ( t , got , want ) }) t . Run ( \"in French\" , func ( t * testing . T ) { got := Hello ( \"Lara Fabian\" , \"French\" ) want := \"Bonjour, Lara Fabian\" assertCorrectMessage ( t , got , want ) }) t . Run ( \"in Korean\" , func ( t * testing . T ) { got := Hello ( \"\uc138\uc0c1\" , \"Korean\" ) want := \"\uc548\ub155 \uc138\uc0c1\" assertCorrectMessage ( t , got , want ) }) } const french = \"French\" const korean = \"Korean\" const englishHelloPrefix = \"Hello, \" const frenchHelloPrefix = \"Bonjour, \" const koreanHelloPrefix = \"\uc548\ub155 \" func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } if language == french { return frenchHelloPrefix + name } if language == korean { return koreanHelloPrefix + name } return englishHelloPrefix + name } Yeni \u00f6zelli\u011fimizi, \u00e7al\u0131\u015fan testi ile ekledi\u011fimize g\u00f6re \u015fimdi kodumuzu refactor edebiliriz. func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } prefix := englishHelloPrefix switch language { case french : prefix = frenchHelloPrefix case korean : prefix = koreanHelloPrefix } return prefix + name } Real World Example \u00b6 Ger\u00e7ek bir uygulamaya testlerin nas\u0131l yaz\u0131ld\u0131\u011f\u0131n\u0131 incelemek i\u00e7in https://randomuser.me/api/ APIsinden kullan\u0131c\u0131lar\u0131 \u00e7eken bir HTTP Client yazal\u0131m. UserClient yap\u0131s\u0131 ile, verilerin \u00e7ekilece\u011fi URLi, ka\u00e7 sayfa veri \u00e7ekece\u011fini ve her sayfada ne kadar veri alaca\u011f\u0131 ve de HTTP isteklerinin at\u0131laca\u011f\u0131 k\u00fct\u00fcphane belirliyoruz. type UserClient struct { BaseUrl string TaskCount , ResultPerPage int } uc := & UserClient { BaseUrl : \"https://randomuser.me/api/\" , TaskCount : 20 , ResultPerPage : 100 , requester : & http . Client {}, } user , _ := uc . Get () users , _ := uc . FetchAll () fmt . Println ( len ( res )) // 2000 Mocking \u00b6 Unit testlerin \u00e7al\u0131\u015ft\u0131\u011f\u0131 ortamdan, d\u0131\u015f kaynaklardan ve k\u00fct\u00fcphanelerden ba\u011f\u0131ms\u0131z olmas\u0131 gerekir. Bu y\u00fczden http.Client ayn\u0131 davran\u0131\u015f\u0131 sergileyen fakat sahte veri d\u00f6nen ba\u015fka bir mod\u00fcl ile de\u011fi\u015ftirilmeli. Ortak davran\u0131\u015flara sahip mod\u00fcller geli\u015ftirmenin en kolay yolu ortak interface kullanmak. http.Clientin kullanaca\u011f\u0131m\u0131z methodlar\u0131na sahip Requester ad\u0131nda bir interface tan\u0131mlayal\u0131m. type Requester interface { Get ( url string ) ( resp * http . Response , err error ) } type UserClient struct { BaseUrl string TaskCount , ResultPerPage int requester Requester } func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { } func ( d * UserClient ) FetchAll () ( result [] map [ string ] interface {}, err error ) { } Testleri \u00e7al\u0131\u015ft\u0131r\u0131rken kullanaca\u011f\u0131m\u0131z, http.Client gibi Requesteri implement eden sahte bir client olu\u015ftural\u0131m ve FakeClient\u0131 kullanarak UserClient i\u00e7in bir test yazal\u0131m. type FakeClient struct { Body [] byte Error error } func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = & http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } func TestGetUser ( t * testing . T ) { userclient := & UserClient {} t . Run ( \"get userclient returns err on bad response\" , func ( t * testing . T ) { userclient . requester = & FakeClient { Error : errors . New ( \"Bad Request\" ), } _ , err := userclient . Get () if err == nil { t . Error ( \"Expected to get an error\" ) } }) } http.Clienti, sahtesi ile a\u015fa\u011f\u0131daki \u015fekilde de\u011fi\u015ftirdik. userclient . requester = & FakeClient { Body : [] byte ( `{\"status\": \"ok\"}` ), } FakeClient ald\u0131\u011f\u0131 Body verisini Get methodu \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda bize http.Clientinkine benzer \u015fekilde d\u00f6necek. func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = & http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } Art\u0131k elimizde fail olan bir test var. Bu testi ge\u00e7ecek kodu yazabiliriz. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { err := erros . New ( \"Error\" ) return } \u015eimdi de response bodyi kontrol eden bir test yazal\u0131m. t . Run ( \"get userclient returns err if response body invalid\" , func ( t * testing . T ) { userclient . requester = & FakeClient {} _ , err := userclient . Get () if err == nil { t . Error ( \"Expected to get an error\" ) } }) Art\u0131k testi ge\u00e7mek i\u00e7in kod yazabiliriz. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( \"%s?results=%d\" , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } } Son olarak ba\u015far\u0131l\u0131 response durumunu test edelim. t . Run ( \"get userclient returns unmarshalled response body on success\" , func ( t * testing . T ) { userclient . requester = & FakeClient { Body : [] byte ( `{\"status\": \"ok\"}` ), } got , _ := userclient . Get () want := map [ string ] interface {}{ \"status\" : \"ok\" , } if ! reflect . DeepEqual ( got , want ) { t . Errorf ( \"got %q want %q\" , got , want ) } }) Art\u0131k byte JSONu d\u00fczg\u00fcnce parse eden bir kod yazmam\u0131z gerekiyor. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( \"%s?results=%d\" , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } defer res . Body . Close () buf := new ( bytes . Buffer ) buf . ReadFrom ( res . Body ) newStr := buf . String () var data map [ string ] interface {} err = json . Unmarshal ([] byte ( newStr ), & data ) response = data return } Table Test \u00b6 Kod tekrar\u0131n\u0131 azaltmak i\u00e7in table driven test y\u00f6ntemini kullanabiliriz. func TestFetchAll ( t * testing . T ) { testCases := [] struct { name string client * UserClient expected [] map [ string ] interface {} }{ { \"get userclient returns err on bad response\" , & UserClient { ResultPerPage : 1 , TaskCount : 0 , requester : & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), }, }, [] map [ string ] interface {}{}, }, { \"get userclient returns err if response body invalid\" , & UserClient { ResultPerPage : 0 , TaskCount : 1 , requester : & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), }, }, [] map [ string ] interface {}{}, }, { \"get userclient returns unmarshalled response body on success\" , & UserClient { ResultPerPage : 0 , TaskCount : 1 , requester : & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), }, }, [] map [ string ] interface {}{}, }, } for _ , tt := range testCases { t . Run ( tt . name , func ( t * testing . T ) { got , _ := tt . client . FetchAll () if ! reflect . DeepEqual ( got , tt . expected ) { t . Errorf ( \"got %q want %q\" , got , tt . expected ) } }) } } Anti-Patternler \u00b6 \u0130kinci S\u0131n\u0131f Vatanda\u015fl\u0131k D i\u011fer kodlar\u0131 yazarken uygulad\u0131\u011f\u0131m\u0131z yaz\u0131l\u0131m prensipleri test kodlar\u0131 i\u00e7in de ge\u00e7erli. Obsessive Coverage Test coverage\u0131n y\u00fcksek olmas\u0131, projenin b\u00fct\u00fcn durumlar\u0131n\u0131n test edildi\u011fini g\u00f6stermez. Bir projenin d\u00fczg\u00fcn test edildi\u011finin g\u00f6stergesi sadece coverage raporlar\u0131 de\u011fildir. Structural Inspection Projede structlar\u0131n, ve di\u011fer veri yap\u0131lar\u0131n\u0131n ald\u0131klar\u0131 de\u011ferleri de\u011fil methodlar\u0131 ve fonksiyonlar\u0131n davran\u0131\u015flar\u0131n\u0131 test etmeliyiz. God Object Test edilmesi zor, b\u00fcy\u00fck yap\u0131lar par\u00e7alanmal\u0131d\u0131r. E\u011fer test etti\u011fimiz kod \u00e7ok fazla mock kulland\u0131r\u0131yorsa bu God Objectin belirtisi olabilir. Mockery Testlerde a\u015f\u0131r\u0131 mock kullan\u0131m\u0131, uygulama davran\u0131\u015f\u0131n\u0131 de\u011fil mockerlar\u0131n de\u011ferlerini test etmemizle sonu\u00e7lan\u0131r. Instance Reuse Test edilen yap\u0131lar, \u00e7al\u0131\u015ft\u0131r\u0131lan her test i\u00e7in yeniden \u00fcretilmelidir. Local Hero Testler \u00e7al\u0131\u015ft\u0131\u011f\u0131 ortamdan ve makineden ba\u011f\u0131ms\u0131z olmal\u0131d\u0131r. Happy Path Testing Uygulamada sadece ba\u015far\u0131l\u0131 sonu\u00e7lar\u0131 de\u011fil, olas\u0131 b\u00fct\u00fcn durumlar\u0131 test etmeliyiz. K\u00f6t\u00fc \u0130simlendirme (S\u0131ral\u0131 \u0130simlendirme) Testlerin isimleri ve mesajlar\u0131 a\u00e7\u0131klay\u0131c\u0131 ve ay\u0131rt edici olmal\u0131d\u0131r. Yeni Test Yerine Assertion Ekleme Birime yeni \u00f6zellik eklendi\u011finde, veya bir k\u0131sm\u0131 de\u011fi\u015ftirildi\u011finde var olan bir teste ekstra bir kontrol eklenmemelidir. Sadece bu durumu yeni bir test yaz\u0131lmal\u0131d\u0131r. package main import ( \"bytes\" \"encoding/json\" \"fmt\" \"net/http\" ) type Requester interface { Get ( url string ) ( resp * http . Response , err error ) } type UserClient struct { BaseUrl string TaskCount , ResultPerPage int requester Requester } func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( \"%s?results=%d\" , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } defer res . Body . Close () buf := new ( bytes . Buffer ) buf . ReadFrom ( res . Body ) newStr := buf . String () var data map [ string ] interface {} err = json . Unmarshal ([] byte ( newStr ), & data ) response = data return } func ( d * UserClient ) FetchAll () ( result [] map [ string ] interface {}, err error ) { ch1 := make ( chan map [ string ] interface {}, 1 ) expectedCount := d . TaskCount * d . ResultPerPage result = [] map [ string ] interface {}{} if d . TaskCount == 0 || d . ResultPerPage == 0 { return } for i := 0 ; i < d . TaskCount ; i ++ { go func ( ch chan map [ string ] interface {}) { response , err := d . Get () if err != nil { for j := 0 ; j < d . ResultPerPage ; j ++ { ch <- map [ string ] interface {}{} } } else { data := response [ \"results\" ].([] interface {}) for _ , datum := range data { ch <- datum .( map [ string ] interface {}) } } }( ch1 ) } for data := range ch1 { result = append ( result , data ) if len ( result ) == expectedCount { close ( ch1 ) } } return result , nil } func main () { uc := & UserClient { BaseUrl : \"https://randomuser.me/api/\" , TaskCount : 20 , ResultPerPage : 100 , requester : & http . Client {}, } res , _ := uc . FetchAll () fmt . Println ( len ( res )) } package main import ( \"bytes\" \"errors\" \"io/ioutil\" \"net/http\" \"reflect\" \"testing\" ) type FakeClient struct { Body [] byte Error error } func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = & http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } func TestGetUser ( t * testing . T ) { userclient := & UserClient {} t . Run ( \"get userclient returns err on bad response\" , func ( t * testing . T ) { userclient . requester = & FakeClient { Error : errors . New ( \"Bad Request\" ), } _ , err := userclient . Get () if err == nil { t . Error ( \"Expected to get an error\" ) } }) t . Run ( \"get userclient returns err if response body invalid\" , func ( t * testing . T ) { userclient . requester = & FakeClient {} _ , err := userclient . Get () if err == nil { t . Error ( \"Expected to get an error\" ) } }) t . Run ( \"get userclient returns unmarshalled response body on success\" , func ( t * testing . T ) { userclient . requester = & FakeClient { Body : [] byte ( `{\"status\": \"ok\"}` ), } got , _ := userclient . Get () want := map [ string ] interface {}{ \"status\" : \"ok\" , } if ! reflect . DeepEqual ( got , want ) { t . Errorf ( \"got %q want %q\" , got , want ) } }) } func TestFetchAll ( t * testing . T ) { t . Run ( \"fetchall returns empty list if task count is 0\" , func ( t * testing . T ) { userclient := & UserClient { ResultPerPage : 1 , TaskCount : 0 , } userclient . requester = & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), } got , _ := userclient . FetchAll () want := [] map [ string ] interface {}{} if ! reflect . DeepEqual ( got , want ) { t . Errorf ( \"got %q want %q\" , got , want ) } }) t . Run ( \"fetchall returns empty list if per page is 0\" , func ( t * testing . T ) { userclient := & UserClient { ResultPerPage : 0 , TaskCount : 1 , } userclient . requester = & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), } got , _ := userclient . FetchAll () want := [] map [ string ] interface {}{} if ! reflect . DeepEqual ( got , want ) { t . Errorf ( \"got %q want %q\" , got , want ) } }) t . Run ( \"fetchall returns the same amount of records with item count\" , func ( t * testing . T ) { userclient := & UserClient { TaskCount : 5 , ResultPerPage : 2 , } userclient . requester = & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), } res , _ := userclient . FetchAll () got := len ( res ) want := 10 if got != want { t . Errorf ( \"got %d want %d\" , got , want ) } }) }","title":"Unit Testing"},{"location":"tr/unit-testing/#unit-testing","text":"Code without tests is broken as designed. Jacob Kaplan-Moss","title":"Unit Testing"},{"location":"tr/unit-testing/#giris","text":"Unit testing, projedeki fonksiyonel her bir birimin t\u00fcm davran\u0131\u015flar\u0131n\u0131n test edildi\u011fi yaz\u0131l\u0131m test y\u00f6ntemidir. Biraz daha a\u00e7mak gerekirse; bir birim, testi m\u00fcmk\u00fcn olan en k\u00fc\u00e7\u00fck yaz\u0131l\u0131m bile\u015fenidir ve \u00e7o\u011funlukla tek bir i\u015f, yapmakla g\u00f6revlidir. Unit testin amac\u0131, program\u0131n k\u00fc\u00e7\u00fck b\u00f6l\u00fcmlere ay\u0131r\u0131p, t\u00fcm b\u00f6l\u00fcmlerin beklenildi\u011fi gibi \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131ndan emin olmakt\u0131r. Unit testleri yaz\u0131lan bir projede: Projeye yeni eklenen kodun, istenildi\u011fi gibi \u00e7al\u0131\u015f\u0131p, \u00e7al\u0131\u015fmad\u0131\u011f\u0131n\u0131 kontrol edilebilir. Varolan kod d\u00fczenlendi\u011finde, projenin davran\u0131\u015f\u0131n\u0131n beklenmedik \u015fekilde de\u011fi\u015ftirmedi\u011finden emin olunur. Yaz\u0131l\u0131mc\u0131, projeye eklenecek karma\u015f\u0131k \u00f6zellikleri k\u00fc\u00e7\u00fck, anla\u015f\u0131l\u0131r par\u00e7alara b\u00f6lmesine dolay\u0131s\u0131yla i\u015fe yarar minimum fonksiyonelli\u011fe h\u0131zl\u0131ca eri\u015fip gereksiz optimizasyondan ka\u00e7\u0131nmas\u0131na yard\u0131mc\u0131 olur. Ekibe yeni kat\u0131lan yaz\u0131l\u0131mc\u0131lar, testleri d\u00f6k\u00fcman olarak kullanabilir. Testlerin bir projedeki b\u00fct\u00fcn hatalar\u0131 \u00e7\u00f6zmesi beklenmemelidir. Projelerde her zaman hata vard\u0131r. Bu hatalar, test edilmeyen bir durumdan, yanl\u0131\u015f test etmekten veya testlerin kontrol edemeyece\u011fi 3. parti k\u00fct\u00fcphanelerden, APIlerden, konfig\u00fcrasyon sorunlar\u0131nlar\u0131nda kaynakl\u0131 olabilir.","title":"Giri\u015f"},{"location":"tr/unit-testing/#test-etmek","text":"package main import \"fmt\" func main () { fmt . Println ( \"Hello, world\" ) } Yukar\u0131daki kodu test etmeden \u00f6nce yan etkilerden ar\u0131nd\u0131rmal\u0131y\u0131z. Buradaki side-effect Println fonksiyonu. package main import \"fmt\" func Hello () string { return \"Hello, world\" } func main () { fmt . Println ( Hello ()) } \u015eimdi Hello fonksiyonunu i\u00e7in test yazal\u0131m. func TestHello ( t * testing . T ) { got := Hello () want := \"Hello, world\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } Go testlerini \u00e7al\u0131\u015ft\u0131rmak i\u00e7in ek ara\u00e7lara veya frameworklere ihtiyac\u0131m\u0131z yok. Sadece go test komutu ile yazd\u0131\u011f\u0131m\u0131z testleri \u00e7al\u0131\u015ft\u0131rabiliriz. Test yazman\u0131n belirli kurallar \u00e7er\u00e7evesinde fonksiyonlar yazmaktan fark\u0131 yoktur. Bu fonksiyonlar\u0131n test olarak kabul edilmesi i\u00e7in: xxx_test.go gibi bir dosya i\u00e7inde olmas\u0131 Fonksiyon isminin Test ile ba\u015flamas\u0131 Fonksiyonun yaln\u0131zca t *testing.T parametresini almas\u0131 gerekir.","title":"Test etmek"},{"location":"tr/unit-testing/#yeni-ozellikler-eklemek","text":"Test ba\u015far\u0131l\u0131 bir \u015fekilde \u00e7al\u0131\u015ft\u0131\u011f\u0131na g\u00f6re art\u0131k uygulamaya yeni \u00f6zellikler ekleyebiliriz. \u015eimdi Hello fonksiyonu parametre olarak bir isim als\u0131n ve o ismi selamlas\u0131n. Bunun i\u00e7in \u00f6ncellikle kodun yeni halini test eden ve ba\u015far\u0131s\u0131z olan bir test yazaca\u011f\u0131z. func TestHello ( t * testing . T ) { got := Hello ( \"Mehmet\" ) want := \"Hello, Mehmet\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } Testi ge\u00e7irecek kadar kod yazal\u0131m. func Hello ( name string ) string { return \"Hello, Mehmet\" } Yukar\u0131daki \u00f6rnekte amac\u0131m\u0131z\u0131n d\u0131\u015f\u0131nda bir kod yazarak testin ge\u00e7mesini sa\u011flad\u0131k. Bu \u00f6rnek her ne kadar abes dursada, bu t\u00fcr durumlar daha b\u00fcy\u00fck \u00f6l\u00e7ekli i\u015flerde ba\u015f\u0131m\u0131za gelebilir ve fark edilmedi\u011finde anla\u015f\u0131lmas\u0131 zor buglar ortaya \u00e7\u0131kartabilir. Ekledi\u011fimiz \u00f6zelli\u011fin d\u00fczg\u00fcn \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan emin olmak i\u00e7in bir test daha ekleyelim. func TestHello ( t * testing . T ) { got := Hello ( \"Mehmet\" ) want := \"Hello, Mehmet\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } func TestHelloWithAnotherName ( t * testing . T ) { got := Hello ( \"Ahmet\" ) want := \"Hello, Ahmet\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } \u015eimdi de testi ge\u00e7ecek kodu yazal\u0131m. func Hello ( name string ) string { return \"Hello, \" + name } Bu a\u015famada elimizde testleri ile birlikte \u00e7al\u0131\u015fan yeni \u00f6zelli\u011fi commit edebiliriz. Bu a\u015famada, TDD ya\u015fam d\u00f6ng\u00fcs\u00fc gere\u011fi kod refactor edilmeye \u00e7al\u0131\u015f\u0131l\u0131r. \"Hello, \" her durumda sabit oldu\u011fu i\u00e7in globalde tan\u0131mlayabiliriz. const englishHelloPrefix = \"Hello, \" func Hello ( name string ) string { return englishHelloPrefix + name } Refactor yap\u0131ld\u0131ktan sonra mutlaka testler yeniden \u00e7al\u0131\u015ft\u0131r\u0131lmal\u0131 ve kod davran\u0131\u015f\u0131n\u0131n de\u011fi\u015fmedi\u011finden emin olunmal\u0131d\u0131r. \u015eimdi uygulamam\u0131za bir \u00f6zellik daha ekleyelim. Bu kez Hello fonksiyonuna bo\u015f isim verilince \u00f6n tan\u0131ml\u0131 mesajla selamlas\u0131n. Tabiki \u00f6nce testini yaz\u0131yoruz. Ayn\u0131 kod par\u00e7as\u0131 i\u00e7in yaz\u0131lan testleri tek fonksiyon alt\u0131nda toplayabiliriz. t.Run yap\u0131s\u0131 sayesinde verdi\u011fimiz farkl\u0131 test mesajlar\u0131 ile birlikte testleri bir araya getirebiliriz. func TestHello ( t * testing . T ) { t . Run ( \"Say hello to a specific name\" , func ( t * testing . T ) { got := Hello ( \"Mehmet\" ) want := \"Hello, Mehmet\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } }) t . Run ( \"Say 'Hello, Dude' when an empty string is provided\" , func ( t * testing . T ) { got := Hello ( \"\" ) want := \"Hello, Dude\" if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } }) } Refactoring sadece business logic i\u00e7eren kodlar i\u00e7in de\u011fildir. Test kodlar\u0131na da projede t\u0131pk\u0131 di\u011fer kodlar gibi yakla\u015f\u0131lmal\u0131d\u0131r. Bu a\u015famada testlerimizde tekrar eden k\u0131s\u0131mlar i\u00e7in bir fonksiyon yazabiliriz. func TestHello ( t * testing . T ) { assertCorrectMessage := func ( t * testing . T , got , want string ) { t . Helper () if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } t . Run ( \"Say hello to a specific name\" , func ( t * testing . T ) { got := Hello ( \"Mehmet\" ) want := \"Hello, Mehmet\" assertCorrectMessage ( t , got , want ) }) t . Run ( \"Say 'Hello, Dude' when an empty string is provided\" , func ( t * testing . T ) { got := Hello ( \"\" ) want := \"Hello, Dude\" assertCorrectMessage ( t , got , want ) }) } \u015eimdi elimizde d\u00fczg\u00fcn bir \u015fekilde yaz\u0131lm\u0131\u015f hata veren bir test var. Uygulamaya testi ge\u00e7mek i\u00e7in yeterli kodu yazal\u0131m. const englishHelloPrefix = \"Hello, \" func Hello ( name string ) string { if name == \"\" { name = \"Dude\" } return englishHelloPrefix + name } B\u00f6ylece uygulamam\u0131za \u00f6nceki \u00f6zellikleri etkilemeden yeni bir \u00f6zellik eklemi\u015f olduk. Bu a\u015famada eski commiti amend edip, fonksiyonumuzu yeni versiyonu ile de\u011fi\u015ftirebiliriz.","title":"Yeni \u00d6zellikler Eklemek"},{"location":"tr/unit-testing/#gelistirme-disiplini","text":"Yeni \u00f6zelli\u011fi kullanan bir test yaz Kodun derlendi\u011finden emin ol Testi \u00e7al\u0131\u015ft\u0131r, hatay\u0131 g\u00f6zlemle Testi ge\u00e7irecek minimum kodu yaz Refactor Bu kadar ad\u0131m zahmetli ve paranoyak\u00e7a gelebilir fakat her ad\u0131mda kodun durumunu kontrol etmek olduk\u00e7a \u00f6nemlidir. Bu disipline sad\u0131k kalarak sadece amac\u0131na uygun testler yazmakla kalmay\u0131z ayn\u0131 zamanda otomatikle\u015ftirilmi\u015f testlerle s\u00fcrekli d\u00fczenlenen ve iyi \u015fekilde tasarlanan bir yaz\u0131l\u0131m geli\u015ftirmi\u015f oluruz. Testlerin ne i\u00e7in yaz\u0131ld\u0131\u011f\u0131n\u0131 anla\u015f\u0131l\u0131r bir \u015fekilde hata mesaj\u0131nda g\u00f6stermek \u00e7ok \u00f6nemlidir. Yaz\u0131l\u0131mc\u0131n\u0131n, testin neden hata verdi\u011fini anlayamamas\u0131 problemi \u00e7\u00f6zmeyi zorla\u015ft\u0131racakt\u0131r. Testlerin h\u0131zl\u0131 \u00e7al\u0131\u015fmas\u0131 ve kolay bir \u015fekilde \u00e7al\u0131\u015ft\u0131r\u0131labilmesi gerekir. Bu ak\u0131c\u0131 bir \u015fekilde kod yazmam\u0131z\u0131 sa\u011flayacakt\u0131r. Testsiz kod yazarak, uygulaman\u0131n ak\u0131\u015f\u0131n\u0131 ve olas\u0131 her durumunu kontrol etme i\u015fini kendinize y\u00fcklemi\u015f olursunuz. Bu da uzun d\u00f6nemde ciddi vakit kayb\u0131na yol a\u00e7acakt\u0131r.","title":"Geli\u015ftirme Disiplini"},{"location":"tr/unit-testing/#daha-fazla-ozellik","text":"Yeni iste\u011fe g\u00f6re uygulamam\u0131za dil deste\u011fi ekleyece\u011fiz. E\u011fer dil sistemimiz taraf\u0131ndan destekleniyorsa selamlama mesaj\u0131 verilen dilde sa\u011flanacak. Desteklenmiyorsa \u00f6n tan\u0131ml\u0131 olan \u0130ngilizce mesaj g\u00f6nderilecek. Ba\u015flang\u0131\u00e7 olarak Frans\u0131zca dil deste\u011fi i\u00e7in test yazal\u0131m. t . Run ( \"in French\" , func ( t * testing . T ) { got := Hello ( \"Lara Fabian\" , \"French\" ) want := \"Bonjour, Lara Fabian\" assertCorrectMessage ( t , got , want ) }) Bu haliyle Hello tek parametre ald\u0131\u011f\u0131 i\u00e7in compiler hata verecektir. Bu ad\u0131mda, hile yap\u0131p do\u011frudan kodu yazmaktan ka\u00e7\u0131nmal\u0131y\u0131z. Fonksiyona gerekli olan 2. parametreyi ekleyelim. func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } return englishHelloPrefix + name } Testleri \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda, yeni \u00f6zelli\u011fe g\u00f6re tasarlanmad\u0131\u011f\u0131 i\u00e7in eski testler hata verecektir. Eski testlere parametre olarak bo\u015f string vererek compiler hatas\u0131ndan kurtulal\u0131m. Bu durumda, sadece yeni ekledi\u011fimiz testin fail olmas\u0131 gerekir. \u015eimdi response bodyi Yeni bir if ekleyerek Frans\u0131zca i\u00e7in yazd\u0131\u011f\u0131m\u0131z testi ge\u00e7ebiliriz. func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } if language == \"French\" { return \"Bonjour, \" + name } return englishHelloPrefix + name } Bu haliyle b\u00fct\u00fcn testleri ba\u015far\u0131l\u0131 olmas\u0131 gerekiyor. \u015eimdi kodumuzu refactor edebiliriz. \u0130\u015fe, kod i\u00e7inde tan\u0131ml\u0131 stringlerden ba\u015flayabiliriz. Yap\u0131lan her de\u011fi\u015fiklikte testlerin ba\u015far\u0131l\u0131 oldu\u011funu kontrol etmeliyiz. const french = \"French\" const englishHelloPrefix = \"Hello, \" const frenchHelloPrefix = \"Bonjour, \" func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } if language == french { return frenchHelloPrefix + name } return englishHelloPrefix + name }","title":"Daha fazla \u00f6zellik"},{"location":"tr/unit-testing/#yeni-dil","text":"\u015eimdi Koreceye de destek verelim. Bunun i\u00e7in daha \u00f6nce yapt\u0131\u011f\u0131m\u0131z gibi: Korean yazd\u0131\u011f\u0131m\u0131zda \uc548\ub155 ile ba\u015flayan bir mesaj bekleyen test yazaca\u011f\u0131z Testi \u00e7al\u0131\u015ft\u0131r\u0131p hata alaca\u011f\u0131z ve hata mesaj\u0131n\u0131n d\u00fczg\u00fcn oldu\u011funa dikkat edece\u011fiz Kod \u00fczerinde testi ge\u00e7ecek minimum de\u011fi\u015fikli\u011fi yapaca\u011f\u0131z De\u011fi\u015fikliklerden sonra elimizde a\u015fa\u011f\u0131 yukar\u0131 b\u00f6yle bir kod olacak: func TestHello ( t * testing . T ) { assertCorrectMessage := func ( t * testing . T , got , want string ) { t . Helper () if got != want { t . Errorf ( \"got %q want %q\" , got , want ) } } t . Run ( \"Say hello to a specific name\" , func ( t * testing . T ) { got := Hello ( \"Mehmet\" , \"\" ) want := \"Hello, Mehmet\" assertCorrectMessage ( t , got , want ) }) t . Run ( \"Say 'Hello, Dude' when an empty string is provided\" , func ( t * testing . T ) { got := Hello ( \"\" , \"\" ) want := \"Hello, Dude\" assertCorrectMessage ( t , got , want ) }) t . Run ( \"in French\" , func ( t * testing . T ) { got := Hello ( \"Lara Fabian\" , \"French\" ) want := \"Bonjour, Lara Fabian\" assertCorrectMessage ( t , got , want ) }) t . Run ( \"in Korean\" , func ( t * testing . T ) { got := Hello ( \"\uc138\uc0c1\" , \"Korean\" ) want := \"\uc548\ub155 \uc138\uc0c1\" assertCorrectMessage ( t , got , want ) }) } const french = \"French\" const korean = \"Korean\" const englishHelloPrefix = \"Hello, \" const frenchHelloPrefix = \"Bonjour, \" const koreanHelloPrefix = \"\uc548\ub155 \" func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } if language == french { return frenchHelloPrefix + name } if language == korean { return koreanHelloPrefix + name } return englishHelloPrefix + name } Yeni \u00f6zelli\u011fimizi, \u00e7al\u0131\u015fan testi ile ekledi\u011fimize g\u00f6re \u015fimdi kodumuzu refactor edebiliriz. func Hello ( name string , language string ) string { if name == \"\" { name = \"Dude\" } prefix := englishHelloPrefix switch language { case french : prefix = frenchHelloPrefix case korean : prefix = koreanHelloPrefix } return prefix + name }","title":"Yeni dil"},{"location":"tr/unit-testing/#real-world-example","text":"Ger\u00e7ek bir uygulamaya testlerin nas\u0131l yaz\u0131ld\u0131\u011f\u0131n\u0131 incelemek i\u00e7in https://randomuser.me/api/ APIsinden kullan\u0131c\u0131lar\u0131 \u00e7eken bir HTTP Client yazal\u0131m. UserClient yap\u0131s\u0131 ile, verilerin \u00e7ekilece\u011fi URLi, ka\u00e7 sayfa veri \u00e7ekece\u011fini ve her sayfada ne kadar veri alaca\u011f\u0131 ve de HTTP isteklerinin at\u0131laca\u011f\u0131 k\u00fct\u00fcphane belirliyoruz. type UserClient struct { BaseUrl string TaskCount , ResultPerPage int } uc := & UserClient { BaseUrl : \"https://randomuser.me/api/\" , TaskCount : 20 , ResultPerPage : 100 , requester : & http . Client {}, } user , _ := uc . Get () users , _ := uc . FetchAll () fmt . Println ( len ( res )) // 2000","title":"Real World Example"},{"location":"tr/unit-testing/#mocking","text":"Unit testlerin \u00e7al\u0131\u015ft\u0131\u011f\u0131 ortamdan, d\u0131\u015f kaynaklardan ve k\u00fct\u00fcphanelerden ba\u011f\u0131ms\u0131z olmas\u0131 gerekir. Bu y\u00fczden http.Client ayn\u0131 davran\u0131\u015f\u0131 sergileyen fakat sahte veri d\u00f6nen ba\u015fka bir mod\u00fcl ile de\u011fi\u015ftirilmeli. Ortak davran\u0131\u015flara sahip mod\u00fcller geli\u015ftirmenin en kolay yolu ortak interface kullanmak. http.Clientin kullanaca\u011f\u0131m\u0131z methodlar\u0131na sahip Requester ad\u0131nda bir interface tan\u0131mlayal\u0131m. type Requester interface { Get ( url string ) ( resp * http . Response , err error ) } type UserClient struct { BaseUrl string TaskCount , ResultPerPage int requester Requester } func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { } func ( d * UserClient ) FetchAll () ( result [] map [ string ] interface {}, err error ) { } Testleri \u00e7al\u0131\u015ft\u0131r\u0131rken kullanaca\u011f\u0131m\u0131z, http.Client gibi Requesteri implement eden sahte bir client olu\u015ftural\u0131m ve FakeClient\u0131 kullanarak UserClient i\u00e7in bir test yazal\u0131m. type FakeClient struct { Body [] byte Error error } func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = & http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } func TestGetUser ( t * testing . T ) { userclient := & UserClient {} t . Run ( \"get userclient returns err on bad response\" , func ( t * testing . T ) { userclient . requester = & FakeClient { Error : errors . New ( \"Bad Request\" ), } _ , err := userclient . Get () if err == nil { t . Error ( \"Expected to get an error\" ) } }) } http.Clienti, sahtesi ile a\u015fa\u011f\u0131daki \u015fekilde de\u011fi\u015ftirdik. userclient . requester = & FakeClient { Body : [] byte ( `{\"status\": \"ok\"}` ), } FakeClient ald\u0131\u011f\u0131 Body verisini Get methodu \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda bize http.Clientinkine benzer \u015fekilde d\u00f6necek. func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = & http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } Art\u0131k elimizde fail olan bir test var. Bu testi ge\u00e7ecek kodu yazabiliriz. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { err := erros . New ( \"Error\" ) return } \u015eimdi de response bodyi kontrol eden bir test yazal\u0131m. t . Run ( \"get userclient returns err if response body invalid\" , func ( t * testing . T ) { userclient . requester = & FakeClient {} _ , err := userclient . Get () if err == nil { t . Error ( \"Expected to get an error\" ) } }) Art\u0131k testi ge\u00e7mek i\u00e7in kod yazabiliriz. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( \"%s?results=%d\" , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } } Son olarak ba\u015far\u0131l\u0131 response durumunu test edelim. t . Run ( \"get userclient returns unmarshalled response body on success\" , func ( t * testing . T ) { userclient . requester = & FakeClient { Body : [] byte ( `{\"status\": \"ok\"}` ), } got , _ := userclient . Get () want := map [ string ] interface {}{ \"status\" : \"ok\" , } if ! reflect . DeepEqual ( got , want ) { t . Errorf ( \"got %q want %q\" , got , want ) } }) Art\u0131k byte JSONu d\u00fczg\u00fcnce parse eden bir kod yazmam\u0131z gerekiyor. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( \"%s?results=%d\" , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } defer res . Body . Close () buf := new ( bytes . Buffer ) buf . ReadFrom ( res . Body ) newStr := buf . String () var data map [ string ] interface {} err = json . Unmarshal ([] byte ( newStr ), & data ) response = data return }","title":"Mocking"},{"location":"tr/unit-testing/#table-test","text":"Kod tekrar\u0131n\u0131 azaltmak i\u00e7in table driven test y\u00f6ntemini kullanabiliriz. func TestFetchAll ( t * testing . T ) { testCases := [] struct { name string client * UserClient expected [] map [ string ] interface {} }{ { \"get userclient returns err on bad response\" , & UserClient { ResultPerPage : 1 , TaskCount : 0 , requester : & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), }, }, [] map [ string ] interface {}{}, }, { \"get userclient returns err if response body invalid\" , & UserClient { ResultPerPage : 0 , TaskCount : 1 , requester : & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), }, }, [] map [ string ] interface {}{}, }, { \"get userclient returns unmarshalled response body on success\" , & UserClient { ResultPerPage : 0 , TaskCount : 1 , requester : & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), }, }, [] map [ string ] interface {}{}, }, } for _ , tt := range testCases { t . Run ( tt . name , func ( t * testing . T ) { got , _ := tt . client . FetchAll () if ! reflect . DeepEqual ( got , tt . expected ) { t . Errorf ( \"got %q want %q\" , got , tt . expected ) } }) } }","title":"Table Test"},{"location":"tr/unit-testing/#anti-patternler","text":"\u0130kinci S\u0131n\u0131f Vatanda\u015fl\u0131k D i\u011fer kodlar\u0131 yazarken uygulad\u0131\u011f\u0131m\u0131z yaz\u0131l\u0131m prensipleri test kodlar\u0131 i\u00e7in de ge\u00e7erli. Obsessive Coverage Test coverage\u0131n y\u00fcksek olmas\u0131, projenin b\u00fct\u00fcn durumlar\u0131n\u0131n test edildi\u011fini g\u00f6stermez. Bir projenin d\u00fczg\u00fcn test edildi\u011finin g\u00f6stergesi sadece coverage raporlar\u0131 de\u011fildir. Structural Inspection Projede structlar\u0131n, ve di\u011fer veri yap\u0131lar\u0131n\u0131n ald\u0131klar\u0131 de\u011ferleri de\u011fil methodlar\u0131 ve fonksiyonlar\u0131n davran\u0131\u015flar\u0131n\u0131 test etmeliyiz. God Object Test edilmesi zor, b\u00fcy\u00fck yap\u0131lar par\u00e7alanmal\u0131d\u0131r. E\u011fer test etti\u011fimiz kod \u00e7ok fazla mock kulland\u0131r\u0131yorsa bu God Objectin belirtisi olabilir. Mockery Testlerde a\u015f\u0131r\u0131 mock kullan\u0131m\u0131, uygulama davran\u0131\u015f\u0131n\u0131 de\u011fil mockerlar\u0131n de\u011ferlerini test etmemizle sonu\u00e7lan\u0131r. Instance Reuse Test edilen yap\u0131lar, \u00e7al\u0131\u015ft\u0131r\u0131lan her test i\u00e7in yeniden \u00fcretilmelidir. Local Hero Testler \u00e7al\u0131\u015ft\u0131\u011f\u0131 ortamdan ve makineden ba\u011f\u0131ms\u0131z olmal\u0131d\u0131r. Happy Path Testing Uygulamada sadece ba\u015far\u0131l\u0131 sonu\u00e7lar\u0131 de\u011fil, olas\u0131 b\u00fct\u00fcn durumlar\u0131 test etmeliyiz. K\u00f6t\u00fc \u0130simlendirme (S\u0131ral\u0131 \u0130simlendirme) Testlerin isimleri ve mesajlar\u0131 a\u00e7\u0131klay\u0131c\u0131 ve ay\u0131rt edici olmal\u0131d\u0131r. Yeni Test Yerine Assertion Ekleme Birime yeni \u00f6zellik eklendi\u011finde, veya bir k\u0131sm\u0131 de\u011fi\u015ftirildi\u011finde var olan bir teste ekstra bir kontrol eklenmemelidir. Sadece bu durumu yeni bir test yaz\u0131lmal\u0131d\u0131r. package main import ( \"bytes\" \"encoding/json\" \"fmt\" \"net/http\" ) type Requester interface { Get ( url string ) ( resp * http . Response , err error ) } type UserClient struct { BaseUrl string TaskCount , ResultPerPage int requester Requester } func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( \"%s?results=%d\" , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } defer res . Body . Close () buf := new ( bytes . Buffer ) buf . ReadFrom ( res . Body ) newStr := buf . String () var data map [ string ] interface {} err = json . Unmarshal ([] byte ( newStr ), & data ) response = data return } func ( d * UserClient ) FetchAll () ( result [] map [ string ] interface {}, err error ) { ch1 := make ( chan map [ string ] interface {}, 1 ) expectedCount := d . TaskCount * d . ResultPerPage result = [] map [ string ] interface {}{} if d . TaskCount == 0 || d . ResultPerPage == 0 { return } for i := 0 ; i < d . TaskCount ; i ++ { go func ( ch chan map [ string ] interface {}) { response , err := d . Get () if err != nil { for j := 0 ; j < d . ResultPerPage ; j ++ { ch <- map [ string ] interface {}{} } } else { data := response [ \"results\" ].([] interface {}) for _ , datum := range data { ch <- datum .( map [ string ] interface {}) } } }( ch1 ) } for data := range ch1 { result = append ( result , data ) if len ( result ) == expectedCount { close ( ch1 ) } } return result , nil } func main () { uc := & UserClient { BaseUrl : \"https://randomuser.me/api/\" , TaskCount : 20 , ResultPerPage : 100 , requester : & http . Client {}, } res , _ := uc . FetchAll () fmt . Println ( len ( res )) } package main import ( \"bytes\" \"errors\" \"io/ioutil\" \"net/http\" \"reflect\" \"testing\" ) type FakeClient struct { Body [] byte Error error } func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = & http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } func TestGetUser ( t * testing . T ) { userclient := & UserClient {} t . Run ( \"get userclient returns err on bad response\" , func ( t * testing . T ) { userclient . requester = & FakeClient { Error : errors . New ( \"Bad Request\" ), } _ , err := userclient . Get () if err == nil { t . Error ( \"Expected to get an error\" ) } }) t . Run ( \"get userclient returns err if response body invalid\" , func ( t * testing . T ) { userclient . requester = & FakeClient {} _ , err := userclient . Get () if err == nil { t . Error ( \"Expected to get an error\" ) } }) t . Run ( \"get userclient returns unmarshalled response body on success\" , func ( t * testing . T ) { userclient . requester = & FakeClient { Body : [] byte ( `{\"status\": \"ok\"}` ), } got , _ := userclient . Get () want := map [ string ] interface {}{ \"status\" : \"ok\" , } if ! reflect . DeepEqual ( got , want ) { t . Errorf ( \"got %q want %q\" , got , want ) } }) } func TestFetchAll ( t * testing . T ) { t . Run ( \"fetchall returns empty list if task count is 0\" , func ( t * testing . T ) { userclient := & UserClient { ResultPerPage : 1 , TaskCount : 0 , } userclient . requester = & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), } got , _ := userclient . FetchAll () want := [] map [ string ] interface {}{} if ! reflect . DeepEqual ( got , want ) { t . Errorf ( \"got %q want %q\" , got , want ) } }) t . Run ( \"fetchall returns empty list if per page is 0\" , func ( t * testing . T ) { userclient := & UserClient { ResultPerPage : 0 , TaskCount : 1 , } userclient . requester = & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), } got , _ := userclient . FetchAll () want := [] map [ string ] interface {}{} if ! reflect . DeepEqual ( got , want ) { t . Errorf ( \"got %q want %q\" , got , want ) } }) t . Run ( \"fetchall returns the same amount of records with item count\" , func ( t * testing . T ) { userclient := & UserClient { TaskCount : 5 , ResultPerPage : 2 , } userclient . requester = & FakeClient { Body : [] byte ( `{\"results\": [{\"test\": \"ok\"}]` ), } res , _ := userclient . FetchAll () got := len ( res ) want := 10 if got != want { t . Errorf ( \"got %d want %d\" , got , want ) } }) }","title":"Anti-Patternler"}]}