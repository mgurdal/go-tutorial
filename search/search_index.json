{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Go Tutorial English | T\u00fcrk\u00e7e Topics Data Structures Array, Slice, Map, Struct, Interface, Error, other common data structures and their usages. Concurrency The use of concurrency patterns in go.","title":"Home"},{"location":"#go-tutorial","text":"English | T\u00fcrk\u00e7e","title":"Go Tutorial"},{"location":"#topics","text":"Data Structures Array, Slice, Map, Struct, Interface, Error, other common data structures and their usages. Concurrency The use of concurrency patterns in go.","title":"Topics"},{"location":"concurrency/","text":"Concurrency English | T\u00fcrk\u00e7e In computer science, concurrency is the ability to run sequentially in a program in a way that does not affect the result or algorithms. The ability to run the workpieces independently allows us to use the processor at maximum efficiency by executing the instructions in different cores. Goroutines Goroutines are functions in a task queue that waits to be executed by a system thread. To create a goroutine, we only need to write 'go' when running the function. In the application below, every time the Work function is called it blocks the application until it is finished. func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { Work ( work work work work work work... ) Work ( zxcasfv ) } Let's run the blocking parts as goroutine. func main () { go Work ( work work work work work work... ) go Work ( zxcasfv ) } When we run the program, it will end without printing anything on the screen. When the function main finishes it ends and the program closes without waiting Work function to write something on the screen. We can capture the output of Work function by adding a small delay at the end of the main function, package main import ( fmt time ) func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { go Work ( work work work work work work... ) go Work ( zxcasfv ) time . Sleep ( time . Second * 1 ) } WaitGroup In certain moments of the application, we may have to wait for some goroutines to end. With WaitGroup, we can specify the number of goroutines we want to run and wait for them to finish their work. All the goroutines need to do here is to run WaitGroup's Done method when it finishes. func Work ( msg string , wg * sync . WaitGroup ) { time . Sleep ( time . Second * 2 ) fmt . Println ( msg ) wg . Done () } func main () { nWorkers1 , nWorkers2 := 5 , 4 wg := sync . WaitGroup {} wg . Add ( nWorkers1 ) for i := 0 ; i nWorkers1 ; i ++ { go Work ( work-1 , wg ) } wg . Wait () wg . Add ( nWorkers2 ) for i := 0 ; i nWorkers2 ; i ++ { go Work ( work-2 , wg ) wg . Wait () } Channels Channels allows us to communicate goroutines with each other. In the above example, we cannot get the return value from the functions we run with go . We can create channels to send the result of a goroutine to the main function or anoter goroutine. Channels can be created as make(chan data_type, buffer) . func Work ( msg string , ch chan string ) { time . Sleep ( time . Second * 2 ) ch - msg } func main () { ch1 := make ( chan string ) go Work ( work-1 , ch1 ) go Work ( work-2 , ch1 ) for i := 0 ; i 2 ; i ++ { msg := - ch1 fmt . Println ( msg ) } } Mutex Wikipedia Definition In computer science, mutual exclusion is a property of concurrency control, which is instituted for the purpose of preventing race conditions. It is the requirement that one thread of execution never enters its critical section at the same time that another concurrent thread of execution enters its own critical section, which refers to an interval of time during which a thread of execution accesses a shared resource, such as shared memory. func Click ( counter * int , wg * sync . WaitGroup ) { counter += 1 wg . Done () } func main () { counter := 0 nWorkers := 500 wg := sync . WaitGroup {} wg . Add ( nWorkers1 ) for i := 0 ; i nWorkers1 ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter ) } func Click ( counter * int , wg * sync . WaitGroup ) { mx . Lock () counter += 1 mx . Unlock () wg . Done () } func main () { counter := 0 mx := sync . Mutex {} nWorkers := 500 wg := sync . WaitGroup {} wg . Add ( nWorkers ) for i := 0 ; i nWorkers ; i ++ { go Work ( counter , wg , mx ) } wg . Wait () fmt . Println ( counter ) } Select Sending data to channels or waiting for data from channels blocks the application. Select allows us to await data from multiple channels. In the example below, two goroutines continuously sending data to chan1 and chan2 . We can read all incoming messages from both channel by selecting both of them within a infinite loop. When a message comes from any of the channels select will enter in a case and handle the message and the for loop will start the selection process again. chan1 := make ( chan string ) chan2 := make ( chan string ) go func () { for { time . Sleep ( 2 * time . Second ) chan1 - one } }() go func () { for { time . Sleep ( 1 * time . Second ) chan2 - two } }() for { select { case msg1 := - chan1 : fmt . Println ( msg1 ) case msg2 := - chan2 : fmt . Println ( msg2 ) } } Adding Timeout A program like above will be locked if no data is sent to both channels. To prevent this, we can add timeouts. We can break the loop by waiting from another finite channel and then end the function when the case is matched. Go has predefined channels for this kind of purposes. Time module has an time.After method which yields a result after a certain delay. chan1 := make ( chan string ) chan2 := make ( chan string ) go func () { for { time . Sleep ( 1 * time . Second ) chan1 - one } }() go func () { for { time . Sleep ( 2 * time . Second ) chan2 - two } }() for { select { case msg1 := - chan1 : fmt . Println ( msg1 ) case msg2 := - chan2 : fmt . Println ( msg2 ) case - time . After ( time . Second * 1 ): fmt . Println ( \ud83c\udfb5 Brave Sir Robin ran away \ud83c\udfb5 ) fmt . Println ( \ud83c\udfb5 Bravely ran away away \ud83c\udfb5 ) return } } Example A group of workers is working in a iron and coal mine deposit, where ores are explored, mined and processed. In the application below, we can see how workers can work in parallel with the concurrency tools provided by the go language. package main import ( fmt strconv sync time ) // Vein holds and yields ores type Vein struct { Ores [] string } // Reveal shows the next ore in the mine func ( vein * Vein ) Reveal () ( ore string ) { if len ( vein . Ores ) == 0 { return } ore = vein . Ores [ 0 ] vein . Ores = vein . Ores [ 1 :] return ore } // Worker can explore veins, mines or processes ores. type Worker struct { name string } // Find sends the next found ore in the mine to the miner channel func ( w * Worker ) Find ( vein * Vein , ch chan - string ) { ore := vein . Reveal () if ore != { fmt . Println ( w . name , found , ore ) time . Sleep ( time . Second * 2 ) ch - ore } } // Mine extracts the found ore and sends it to smelting channel func ( w * Worker ) Mine ( finder - chan string , smelter chan - string ) { for ore := range finder { fmt . Println ( w . name , mining , ore ) time . Sleep ( time . Second * 1 ) smelter - ore } } // Smelt melts or processes the ore func ( w * Worker ) Smelt ( coal_miner , iron_miner - chan string , wg * sync . WaitGroup ) { for { select { case coal_ore := - coal_miner : time . Sleep ( time . Second * 1 ) fmt . Println ( w . name , processed , coal_ore ) case iron_ore := - iron_miner : time . Sleep ( time . Second * 2 ) fmt . Println ( w . name , smelted , iron_ore ) } wg . Done () } } func main () { wg := sync . WaitGroup {} // Create a Iron Vein with 100 ores in it n_iron_ores := 100 iron_vein := Vein { make ([] string , n_iron_ores )} for i := range iron_vein . Ores { iron_vein . Ores [ i ] = iron-ore- + strconv . Itoa ( i ) } // Create a Coal Vein with 50 ores in it n_coal_ores := 50 coal_vein := Vein { make ([] string , n_coal_ores )} for i := range coal_vein . Ores { coal_vein . Ores [ i ] = coal-ore- + strconv . Itoa ( i ) } // Create ore delivery channel between workers finder_to_miner := make ( chan string ) coal_miner_to_smelter := make ( chan string ) iron_miner_to_smelter := make ( chan string ) // Create ore explorers n_finders := 6 finders := make ([] * Worker , n_finders ) for i := range finders { finders [ i ] = Worker { name : finder- + strconv . Itoa ( i ), } } // Create ore miners n_miners := 50 miners := make ([] * Worker , n_miners ) for i := range miners { miners [ i ] = Worker { name : miner- + strconv . Itoa ( i ), } } // Create ore smelters n_smelters := 10 smelters := make ([] * Worker , n_smelters ) for i := range smelters { smelters [ i ] = Worker { name : smelter- + strconv . Itoa ( i ), } } // Send half of the explorers to find ores in coal vein // and other half to iron vein for i := 0 ; i n_iron_ores + n_coal_ores ; i ++ { wg . Add ( 1 ) finder_idx := i % len ( finders ) go finders [ finder_idx ]. Find ( coal_vein , finder_to_miner ) go finders [ finder_idx ]. Find ( iron_vein , finder_to_miner ) } // Assing half of the miners to mine iron ores and the other half to coal for i , miner := range miners { if i % 2 == 0 { go miner . Mine ( finder_to_miner , iron_miner_to_smelter ) } else { go miner . Mine ( finder_to_miner , coal_miner_to_smelter ) } } // Start working the smelters for _ , smelter := range smelters { go smelter . Smelt ( coal_miner_to_smelter , iron_miner_to_smelter , wg ) } // Wait for all ores to be found, mined and smelted wg . Wait () }","title":"Concurrency"},{"location":"concurrency/#concurrency","text":"English | T\u00fcrk\u00e7e In computer science, concurrency is the ability to run sequentially in a program in a way that does not affect the result or algorithms. The ability to run the workpieces independently allows us to use the processor at maximum efficiency by executing the instructions in different cores.","title":"Concurrency"},{"location":"concurrency/#goroutines","text":"Goroutines are functions in a task queue that waits to be executed by a system thread. To create a goroutine, we only need to write 'go' when running the function. In the application below, every time the Work function is called it blocks the application until it is finished. func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { Work ( work work work work work work... ) Work ( zxcasfv ) } Let's run the blocking parts as goroutine. func main () { go Work ( work work work work work work... ) go Work ( zxcasfv ) } When we run the program, it will end without printing anything on the screen. When the function main finishes it ends and the program closes without waiting Work function to write something on the screen. We can capture the output of Work function by adding a small delay at the end of the main function, package main import ( fmt time ) func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { go Work ( work work work work work work... ) go Work ( zxcasfv ) time . Sleep ( time . Second * 1 ) }","title":"Goroutines"},{"location":"concurrency/#waitgroup","text":"In certain moments of the application, we may have to wait for some goroutines to end. With WaitGroup, we can specify the number of goroutines we want to run and wait for them to finish their work. All the goroutines need to do here is to run WaitGroup's Done method when it finishes. func Work ( msg string , wg * sync . WaitGroup ) { time . Sleep ( time . Second * 2 ) fmt . Println ( msg ) wg . Done () } func main () { nWorkers1 , nWorkers2 := 5 , 4 wg := sync . WaitGroup {} wg . Add ( nWorkers1 ) for i := 0 ; i nWorkers1 ; i ++ { go Work ( work-1 , wg ) } wg . Wait () wg . Add ( nWorkers2 ) for i := 0 ; i nWorkers2 ; i ++ { go Work ( work-2 , wg ) wg . Wait () }","title":"WaitGroup"},{"location":"concurrency/#channels","text":"Channels allows us to communicate goroutines with each other. In the above example, we cannot get the return value from the functions we run with go . We can create channels to send the result of a goroutine to the main function or anoter goroutine. Channels can be created as make(chan data_type, buffer) . func Work ( msg string , ch chan string ) { time . Sleep ( time . Second * 2 ) ch - msg } func main () { ch1 := make ( chan string ) go Work ( work-1 , ch1 ) go Work ( work-2 , ch1 ) for i := 0 ; i 2 ; i ++ { msg := - ch1 fmt . Println ( msg ) } }","title":"Channels"},{"location":"concurrency/#mutex","text":"Wikipedia Definition In computer science, mutual exclusion is a property of concurrency control, which is instituted for the purpose of preventing race conditions. It is the requirement that one thread of execution never enters its critical section at the same time that another concurrent thread of execution enters its own critical section, which refers to an interval of time during which a thread of execution accesses a shared resource, such as shared memory. func Click ( counter * int , wg * sync . WaitGroup ) { counter += 1 wg . Done () } func main () { counter := 0 nWorkers := 500 wg := sync . WaitGroup {} wg . Add ( nWorkers1 ) for i := 0 ; i nWorkers1 ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter ) } func Click ( counter * int , wg * sync . WaitGroup ) { mx . Lock () counter += 1 mx . Unlock () wg . Done () } func main () { counter := 0 mx := sync . Mutex {} nWorkers := 500 wg := sync . WaitGroup {} wg . Add ( nWorkers ) for i := 0 ; i nWorkers ; i ++ { go Work ( counter , wg , mx ) } wg . Wait () fmt . Println ( counter ) }","title":"Mutex"},{"location":"concurrency/#select","text":"Sending data to channels or waiting for data from channels blocks the application. Select allows us to await data from multiple channels. In the example below, two goroutines continuously sending data to chan1 and chan2 . We can read all incoming messages from both channel by selecting both of them within a infinite loop. When a message comes from any of the channels select will enter in a case and handle the message and the for loop will start the selection process again. chan1 := make ( chan string ) chan2 := make ( chan string ) go func () { for { time . Sleep ( 2 * time . Second ) chan1 - one } }() go func () { for { time . Sleep ( 1 * time . Second ) chan2 - two } }() for { select { case msg1 := - chan1 : fmt . Println ( msg1 ) case msg2 := - chan2 : fmt . Println ( msg2 ) } }","title":"Select"},{"location":"concurrency/#adding-timeout","text":"A program like above will be locked if no data is sent to both channels. To prevent this, we can add timeouts. We can break the loop by waiting from another finite channel and then end the function when the case is matched. Go has predefined channels for this kind of purposes. Time module has an time.After method which yields a result after a certain delay. chan1 := make ( chan string ) chan2 := make ( chan string ) go func () { for { time . Sleep ( 1 * time . Second ) chan1 - one } }() go func () { for { time . Sleep ( 2 * time . Second ) chan2 - two } }() for { select { case msg1 := - chan1 : fmt . Println ( msg1 ) case msg2 := - chan2 : fmt . Println ( msg2 ) case - time . After ( time . Second * 1 ): fmt . Println ( \ud83c\udfb5 Brave Sir Robin ran away \ud83c\udfb5 ) fmt . Println ( \ud83c\udfb5 Bravely ran away away \ud83c\udfb5 ) return } }","title":"Adding Timeout"},{"location":"concurrency/#example","text":"A group of workers is working in a iron and coal mine deposit, where ores are explored, mined and processed. In the application below, we can see how workers can work in parallel with the concurrency tools provided by the go language. package main import ( fmt strconv sync time ) // Vein holds and yields ores type Vein struct { Ores [] string } // Reveal shows the next ore in the mine func ( vein * Vein ) Reveal () ( ore string ) { if len ( vein . Ores ) == 0 { return } ore = vein . Ores [ 0 ] vein . Ores = vein . Ores [ 1 :] return ore } // Worker can explore veins, mines or processes ores. type Worker struct { name string } // Find sends the next found ore in the mine to the miner channel func ( w * Worker ) Find ( vein * Vein , ch chan - string ) { ore := vein . Reveal () if ore != { fmt . Println ( w . name , found , ore ) time . Sleep ( time . Second * 2 ) ch - ore } } // Mine extracts the found ore and sends it to smelting channel func ( w * Worker ) Mine ( finder - chan string , smelter chan - string ) { for ore := range finder { fmt . Println ( w . name , mining , ore ) time . Sleep ( time . Second * 1 ) smelter - ore } } // Smelt melts or processes the ore func ( w * Worker ) Smelt ( coal_miner , iron_miner - chan string , wg * sync . WaitGroup ) { for { select { case coal_ore := - coal_miner : time . Sleep ( time . Second * 1 ) fmt . Println ( w . name , processed , coal_ore ) case iron_ore := - iron_miner : time . Sleep ( time . Second * 2 ) fmt . Println ( w . name , smelted , iron_ore ) } wg . Done () } } func main () { wg := sync . WaitGroup {} // Create a Iron Vein with 100 ores in it n_iron_ores := 100 iron_vein := Vein { make ([] string , n_iron_ores )} for i := range iron_vein . Ores { iron_vein . Ores [ i ] = iron-ore- + strconv . Itoa ( i ) } // Create a Coal Vein with 50 ores in it n_coal_ores := 50 coal_vein := Vein { make ([] string , n_coal_ores )} for i := range coal_vein . Ores { coal_vein . Ores [ i ] = coal-ore- + strconv . Itoa ( i ) } // Create ore delivery channel between workers finder_to_miner := make ( chan string ) coal_miner_to_smelter := make ( chan string ) iron_miner_to_smelter := make ( chan string ) // Create ore explorers n_finders := 6 finders := make ([] * Worker , n_finders ) for i := range finders { finders [ i ] = Worker { name : finder- + strconv . Itoa ( i ), } } // Create ore miners n_miners := 50 miners := make ([] * Worker , n_miners ) for i := range miners { miners [ i ] = Worker { name : miner- + strconv . Itoa ( i ), } } // Create ore smelters n_smelters := 10 smelters := make ([] * Worker , n_smelters ) for i := range smelters { smelters [ i ] = Worker { name : smelter- + strconv . Itoa ( i ), } } // Send half of the explorers to find ores in coal vein // and other half to iron vein for i := 0 ; i n_iron_ores + n_coal_ores ; i ++ { wg . Add ( 1 ) finder_idx := i % len ( finders ) go finders [ finder_idx ]. Find ( coal_vein , finder_to_miner ) go finders [ finder_idx ]. Find ( iron_vein , finder_to_miner ) } // Assing half of the miners to mine iron ores and the other half to coal for i , miner := range miners { if i % 2 == 0 { go miner . Mine ( finder_to_miner , iron_miner_to_smelter ) } else { go miner . Mine ( finder_to_miner , coal_miner_to_smelter ) } } // Start working the smelters for _ , smelter := range smelters { go smelter . Smelt ( coal_miner_to_smelter , iron_miner_to_smelter , wg ) } // Wait for all ores to be found, mined and smelted wg . Wait () }","title":"Example"},{"location":"data-structures/","text":"English | T\u00fcrk\u00e7e This page describes the data structures of go language and their usages in general programming. Array Arrays are structures that enable us to keep the same types of data together. For example; A list consisting of 4, 5, 19 and 25 defines an array. Go does not allow us to create arrays from different data types. Definition Arrays are basically defined as [Size]Type . We can see several ways to create arrays below. An array capable of holding 3 units of type string . var fruits [ 3 ] string When defined as such, each field in the array is filled with the default value of the data type. Based on this example, it will be defined as [0, 0, 0] . We can change these values \u200b\u200bby accessing them on their indexes. fruits [ 0 ] = \ud83c\udf4c fruits [ 1 ] = \ud83c\udf4f fruits // [\ud83c\udf4c \ud83c\udf4f] If we use a data type other than the one defined for Array, we will encounter an error. arr [ 2 ] = 1 cannot use 1 ( type int ) as type string in assignment We can define the same array in a shorter way. fruits := [ 3 ] int { \ud83c\udf4c , \ud83c\udf4f } fruits // [\ud83c\udf4c \ud83c\udf4f] In this definition, we assign a 3 unit long array whose first 2 elements we directly define to the variable 'arr'. If we are going to create the arrayi with the values, we can leave the dimension calculation part to compiler using the expression ... fruits := [] int { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf49] Using with Loop Arrays can be used basically in 2 ways with the for loop. 1- Accessing with Index. fruits := [ 3 ] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } for index := range fruits { fruit := fruits [ index ] fmt . Println ( fruit ) } 2- By directly accessing the value. fruits := [ 3 ] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } for _ , fruit := range fruits { fmt . Println ( fruit ) } Slice Slices are very similar to arrays in terms of usage. The difference of slices is that their size is dynamic. When defining slice, we use the structure of []Type as in the array, but we leave the brackets empty. // define nil slice var slc [] int // assigning value to nill slice slc = [] int { 12 , 24 , 39 } // direct identification slc := [] int { 12 , 24 , 39 } make We can also use the make function to define the slice. The first parameter of the make function determines the size of the slice to be created. // define by size n_items = 20 slc := make ([] int , n_items ) // definition by size and capacity capacity := 40 slc := make ([] int , n_items , capacity ) Slice Operations While creating the slice, it is filled with the default value of the data type that it will hold, as much as its capacity. However, only part of its length can be accessed. If we want to increase the size of a slice, we can use the append and copy functions for this. copy copy allows us to copy one slice of another slicea of \u200b\u200bthe same or larger capacity and returns how many elements are copied. bucket := make ([] string , 5 ) fruits := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } n_copied := copy ( bucket , fruits ) n_copied // 5 bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49] When copying a slice, the elements replace the elements in the same index in the target slice. fruits := [] string { \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } apples := [] string { \ud83c\udf4e , , \ud83c\udf4f } copy ( fruits , apples ) fruits // [\ud83c\udf4e \ud83c\udf4f] append The append function takes the slice that we will increase in size as the first parameter and the elements we will add later and return a new slice containing all the elements to us. Therefore, it is necessary to keep the return value in a variable (usually the old slice variable). bucket := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf48 , \ud83c\udf49 } green_apple := \ud83c\udf4f bucket = append ( bucket , green_apple ) bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49 \ud83c\udf4f] When we resize a slice and assign it to another variable, changes in the new slice will also affect the original slice. fruits := [] string { \ud83c\udf4e , \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } apples := fruits [: 2 ] apples [ 0 ] = \ud83c\udf4f apples [ 1 ] = \ud83c\udf4f apples // [\ud83c\udf4f \ud83c\udf4f] fruits // [\ud83c\udf4f \ud83c\udf4f \ud83c\udf47 \ud83c\udf52 \ud83c\udf49] cut If we want to subtract a certain range in the slice, we can use the method below. This method will add the elements up to the start index we have specified in Slice and the elements after the end index. Thus, we will frustrate the elements in between. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } cut_start_index , cut_end_index := 4 , 6 edibles = append ( edibles [: cut_start_index ], edibles [ cut_end_index :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54] delete If we want to delete an element in the slice using its index, we can use the following method. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 edibles = append ( edibles [: index_of_cherry ], edibles [ index_of_cherry + 1 :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] We can do the same with the copy function. In the example below, unlike the above, line 4: First, we selected the section after the element of \u00e9edible in slice. This gave us a slice in the format \\ [\ud83c\udf52 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54 ], if we show all the capacity. Then, after the element `` 1 '' index, we have _ replaced_ with the selected slice. Thus, we have obtained the list of [[\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54 \ud83e\udd54 ]. In line 5, we slice the slice according to the number of new staff. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 n_copied := copy ( edibles [ index_of_cherry :], edibles [ index_of_cherry + 1 :]) new_length := index_of_cherry + n_copied edibles = edibles [: new_length ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] Delete Without Preserving Order We can also do the deletion by ignoring the array order. In the example below, we have replaced the last element in the slice with the element we want to delete. Then we reduced the size of the slice by 1. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 edibles [ index_of_cherry ] = edibles [ len ( edibles ) - 1 ] edibles = edibles [: len ( edibles ) - 1 ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83e\udd54 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d] Garbage Collection If the elements we use in slice are struct with pointer or pointer fields, the cut and delete operations shown above can create a memory leak. The reason for this is that after slice is deleted, it can keep the reference of the deleted element. In addition to the operations we have done in the examples below, we filled in the fields that were idle after my process with nil values. Thus, garbage collector can understand that these areas will no longer be used and bring them back to the system. cut (memory safe) apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } cut_start_index , cut_end_index := 1 , 5 copy ( fruits [ cut_start_index :], fruits [ cut_end_index :]) cleanup_index := len ( fruits ) - cut_end_index + cut_start_index for free_index , free_end := cleanup_index , len ( fruits ); free_index free_end ; free_index ++ { fruits [ free_index ] = nil } fruits = fruits [: cleanup_index ] fruits // [\ud83c\udf4e \ud83c\udf4c] delete (memory safe) apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } delete_index := 2 copy ( fruits [ delete_index :], fruits [ delete_index + 1 :]) fruits [ len ( fruits ) - 1 ] = nil fruits = fruits [: len ( fruits ) - 1 ] fruits // [\ud83c\udf4e \ud83c\udf4e \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c] Delete Without Preserving Order (memory safe) apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } delete_index := 2 fruits [ delete_index ] = fruits [ len ( fruits ) - 1 ] fruits [ len ( fruits ) - 1 ] = nil fruits = fruits [: len ( fruits ) - 1 ] fruits // [\ud83c\udf4e \ud83c\udf4e \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c] expand If we want to combine one slice and the other, we can use the following methods. bucket := [] string { \ud83c\udf4c , \ud83c\udf47 , \ud83c\udf49 } apples := [] string { \ud83c\udf4f , \ud83c\udf4e } bucket = append ( bucket , apples ... ) bucket // [\ud83c\udf4c \ud83c\udf47 \ud83c\udf49 \ud83c\udf4f \ud83c\udf4e] In the example below, we have combined the elements after the index determined by apples in line 7 . Afterwards, we added these slice elements to the bucket items up to the index we determined. bucket := [] string { \ud83c\udf4c , \ud83c\udf47 , \ud83c\udf49 } apples := [] string { \ud83c\udf4f , \ud83c\udf4e } expand_index := 2 bucket = append ( bucket [: expand_index ] append ( apples , bucket [ expand_index :] ... ) ... , ) bucket // [\ud83c\udf4c \ud83c\udf47 \ud83c\udf4f \ud83c\udf4e \ud83c\udf49] filter We can filter the slice elements according to a certain criterion. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 , \ud83c\udf4f , \ud83c\udf4e } apple_criteria := \ud83c\udf4e apples := [] string {} for _ , fruit := range fruits { if fruit == apple_criteria { apples = append ( apples , fruit ) } } apples // [\ud83c\udf4e \ud83c\udf4e] insert If we want to add a new element to any part of the slice; we can use these methods. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c insert_index := 2 fruits = append ( fruits [: insert_index ], append ([] string { banana }, fruits [ insert_index :] ... ) ... , ) fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49] Memory Concern The append([]string{banana}, fruits[insert_index:] ...) section in line 7 creates a slice itself and copies the elements of the slice fruits[insert_index:] to this slicea. These elements are then copied to the fruits slice. Creating a new slice and copying for the 2nd time can be avoided. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c insert_index := 2 fruits = append ( fruits , ) copy ( fruits [ insert_index + 1 :], fruits [ insert_index :]) fruits [ insert_index ] = banana fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49] pop In the example below, we have removed the last element of the slice and assigned it to a variable. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } item , fruits := fruits [ len ( fruits ) - 1 ], fruits [: len ( fruits ) - 1 ] item // \ud83c\udf49 fruits // [\ud83c\udf4f \ud83c\udf4e] push front (unshift) In this example, we put a new element at the beginning of the slice. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c fruits = append ([] string { banana }, fruits ... ) fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf4e \ud83c\udf49] pop front (shift) In this example, we removed the first element of the slice and assigned it to a variable. fruits := [] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana , fruits := fruits [ 0 ], fruits [ 1 :] banana // \ud83c\udf4c fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf49] Map One of the most frequently used data types is maps. map holds values with a unique keys. Identification Maps can be defined as map[KeyType]ValueType or make(map[KeyType]ValueType) . var mymap = map [ string ] string {} mymap = make ( map [ string ] string ) Assigning Value monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 1979 : Life of Brian , } monty_python_films_by_year [ 1983 ] = The Meaning of Life We can access the values \u200b\u200bwe assign using the same key. film_name := monty_python_films_by_year [ 1983 ] film_name // The Meaning of Life When accessing an element of Mapin, we can access an additional value that indicates whether the element is registered in the map. film_name , registered := monty_python_films_by_year [ 2019 ] if ! registered { fmt . Println ( Monty python did not relase a film at 2019 ) } else { fmt . Println ( film_name ) } Accessing to values using with for Map values are accessible in 2 ways. 1- By using one variable in the for loop, by accessing through keys. monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 1979 : Life of Brian , 1983 : The Meaning of Life , } for year := range monty_python_films_by_year { film_name := monty_python_films_by_year [ year ] fmt . Println ( film_name , was released at , year ) } 2- Using 2 variables in the loop, accessing both key and value. for year , film_name := range monty_python_films_by_year { fmt . Println ( film_name , was released at , year ) } /* Monty Python and the Holy Grail was released at 1971 Life of Brian was released at 1979 The Meaning of Life was released at 1983 */ delete We can use the delete function to delete an element on the map. monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 2016 : Batman v Superman , } delete ( monty_python_films_by_year , 2016 ) _ , registered := monty_python_films_by_year [ 2016 ] registered // false len ( monty_python_films_by_year ) // 1 struct Structs are user-defined data structures that can hold different types of data with their names. Definition Structs can be defined as follows. type StructName struct { field fieldType } We can define the fields of the same type of struct in one line. type Film struct { name , director string imdb float32 release_year int } var new_film = Film {} new_film // { 0 0} We can also give tags to the struct fields. type Film struct { Name string `json: film_name ` Director string `json: director_name ` Imdb float32 `json: imdb_score ` ReleaseYear int `json: year_of_release ` } Tags are popular among ORMs and serialization libraries that deal with type conversion. These tags can be accessed with the 'reflect` module. f := Film {} t := reflect . TypeOf ( f ) for _ , f := range [] string { Name , Director , Imdb , ReleaseYear } { field , found := t . FieldByName ( f ) if ! found { continue } fmt . Println ( field . Tag . Get ( json )) } /* film_name director_name imdb_score year_of_release */ Assigning Value A struct can be created by giving its parameters in order. new_film := Film { Mad Max: Fury Road , George Miller , 8.1 , 2015 } new_film // {Mad Max: Fury Road George Miller 8.1 2015} Similarly, it can be created by specifying the parameters and the values with the separator : . new_film := Film { Name : Ran , Director : Akira Kurosawa , Imdb : 8.2 , ReleaseYear : 1985 , } new_film // {Ran Akira Kurosawa 8.2 1985} If some fields are left blank while creating Struct; these fields are defined by the null values of that data type. new_film := Film { name : Batman v Superman , director : Zack Snyder , release_year : 2016 , } new_film // {Batman v Superman Zack Snyder 0 2016} Anonymous struct In some special cases, we may need to define structs in the function body. We can do this by the following method. provider_config := struct { name string baseUrl string apiKey string }{ name : mapbox , baseUrl : https://api.mapbox.com/geocoding/v5/ , apiKey : 123asds123 , } provider_config // {mapbox https://api.mapbox.com/geocoding/v5/ 123asds123} Anonymous fields Struct can also be defined without specifying field names. The data types specified in such a definition must be different from each other. type Item struct { string // code int // quantity float32 // price } item := Item { child-seat-1 , 5 , 20.1 , } item // {child-seat 5 20.1} Promoted fields A struct can be used in another struct without giving the domain name. In this case, the structure inside is accessed by its own name. Based on the example below, Content in Page can be accessed as page.Content . type Content struct { body string size int } type Page struct { nextUrl string previousURL string Content } content := Content { body : h1 Hi /h1 , size : 11 , } page := Page { nextUrl : http://.../3 , previousURL : http://.../1 , Content : content , } page // {http://.../3 http://.../1 { h1 Hi /h1 11}} page . Content // { h1 Hi /h1 11} Pointer Pointer is a variable that holds the memory address of another variable. When a new object is created in runtime, we need to keep it in memory. We substitute the space allocated in the memory for the object with variables. Definition Pointers are also variables. The difference from other variables is that it keeps the address of the variable that indicates the location of that data, not any data. A pointer can be defined using the var pointer * Type structure. If no value is assigned, the value of the pointer is determined as nil . var ptr * int ptr // nil We can also define pointers using the new function. ptr := new ( int ) ptr // nil Assigning Value Assigning Value We can assign the address of another variable as a value to the Pointer by using the sign. Using the pointer with the * sign, we can access the variable it is pointing to (hence the data). var carbon string = Carbon var ptrCarbon * string ptrCarbon = carbon ptrCarbon // 0xc000092030 * ptrCarbon // Carbon * ptrCarbon = Altered + * ptrCarbon carbon // Altered Carbon Functions In general, functions in GO are defined in the following structure. func fonksiyon_name ([ list of parameters ]) [ returning data types ] { function body } func sigmoid ( value float64 ) float64 { return 1.0 / ( 1.0 + math . Exp ( - value )) } sigmoid ( 0.5 ) // 0.62246 Parameters Parameters given to functions are copied. For this reason, changes made on the parameters do not affect the status of variables outside the function. type Wallet struct { userID int balance float64 deposit float64 } func withdraw ( wallet Wallet , amount float64 ) { wallet . balance -= amount } In the above code, we have simply defined a wallet structure and the 'withdraw' function that can withdraw money from the wallet. In the lines below, we created a wallet and used it with this function. wallet := Wallet { userID : 1 , balance : 30000.12 , deposit : 40000.01 , } item_price := 10023.0 withdraw ( wallet , item_price ) wallet . balance // 3000.12 As you can see, the money in the wallet has not changed. We can prevent this type of accident in 2 ways. Method 1, we can return the new balance of the wallet and update the wallet later. func withdraw ( wallet Wallet , amount float64 ) float64 { new_balance := wallet . balance - amount return new_balance } wallet . balance = withdraw ( wallet , item_price ) wallet . balance // 19977.12 This change changes the intended use of the withdraw function, whose job is to withdraw money from the wallet. Method 2, Instead of the wallet variable, we can give the wallet's address as a parameter. func withdraw ( wallet * Wallet , amount float64 ) { wallet . balance -= amount } withdraw ( wallet , item_price ) wallet . balance // 19977.12 The disadvantage of this method is that it is not thread safe. When we want to withdraw money from the wallet with different threads, it will be difficult to keep track of the balance status. Dynamic parameters Dynamic parameters can be defined in GO functions. To define the parameters of this type, the sign ... is written before the parameter type. func ReLU ( nums ... float64 ) [] float64 { new_nums := make ([] float64 , len ( nums )) for idx , value := range nums { if value 0 { new_nums [ idx ] = value } else { new_nums [ idx ] = 0. } } return new_nums } nums := [] float64 { 1. , 0.2 , 0. , 0. , - 0.1 , 0.1 } nums = ReLU ( nums ... ) nums // [1 0.2 0 0 0 0.1] Return Values Returning multiple values Multiple values can be returned in GO functions. It is necessary to define the values to be returned in order between () . func swap ( first_arg , second_arg string ) ( string , string ) { return second_arg , first_arg } var language1 , language2 string = Python , GO language1 , language2 = swap ( language1 , language2 ) language1 , language2 // GO Python Naming Return Values We can name the return values of the functions and determine the values with these variables. Since the named return values will take the null value of the data type, they can also be used as the default return values of the function. type Record struct { id int data string } type DB struct { records [] Record locked bool } func BulkCreate ( records [] Record , db * DB ) ( n_created int , err error ) { if db . locked { err = errors . New ( DB is locked ) } else { db . records = append ( db . records , records ... ) n_created = len ( records ) } return n_created , err } db := DB { records : [] Record {}, locked : true , } data := [] Record {} for i := 0 ; i 100 ; i ++ { rec := Record { id : i , data : test , } data = append ( data , rec ) } n_created , err := BulkCreate ( data , db ) if err != nil { fmt . Println ( err ) } Anonymous Function Functions in GO are also variable and can be defined within other functions. We can use anonymous functions in a limited part of the project to get a specific job done. In the code example below, we assumed that we would not need this process elsewhere in the project, we used an anonymous function to break up a slice of the specified size. records := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } batchSize := 3 batchedRecords := func ( data [] int , batchSize int ) [][] int { var batches [][] int for batchSize len ( data ) { data , batches = data [ batchSize :], append ( batches , data [ 0 : batchSize : batchSize ]) } batches = append ( batches , data ) return batches }( records , batchSize ) batchedRecords // [[0 1 2] [3 4 5] [6 7 8] [9]] We can assign this type of functions to a variable and use it several times. In the example below, we combine the country code and phone numbers that are sent separately from a specific API with the function we define as variables. type Vendor struct { name string countryCode string phone string } vendor := Vendor { name : Volswagen Group , countryCode : 1 , phone : 403120120 , } formatPhoneNumbers := func ( contact Vendor ) string { return + + contact . countryCode + contact . phone } formatPhoneNumbers ( vendor ) // +1403120120 Methods There are no classes or inheritance in GO language like other object oriented programming languages. An experience similar to object oriented programming can be achieved in GO language by adding an additional argument called `receiver 'to the functions. type Connection struct { host string port int timeOut int isClosed bool } func ( conn * Connection ) Close () { conn . isClosed = true fmt . Println ( Connection , conn . host + : + strconv . Itoa ( conn . port ), closed. ) } In the above structure, we have added (conn * Connection) to the Close function in addition to a normal function. Thus, as we can see in the example below, we were able to access the function via the Connection type as c.Close () . c := Connection { host : 0.0.0.0 , port : 8080 , timeOut : 1 , isClosed : false , } c . Close () // Connection 0.0.0.0:8080 closed. Pointer receiver | Value receiver As with the function parameters, it should be decided whether the receivers will be used with the value of the structure or the memory address. We can also use receivers for types other than struct. type Iterable [] int func ( iterable * Iterable ) Append ( items ... int ) { * iterable = append ( * iterable , items ... ) } arr := Iterable { 1 , 2 } arr . Append ( 4 , 5 , 6 ) arr // [1 2 4 5 6] Errors In GO, we can create our own error types. To achieve this, the data type must implement the Error method. Definition In the example below, we have defined a new error called 'HTTPError', which indicates the HTTP code and the reason for the error. type HTTPError struct { Status int Reason string } func ( e HTTPError ) Error () string { return fmt . Sprintf ( %v: %v , e . Status , e . Reason ) } func MakeRequest () error { return HTTPError { Status : 400 , Reason : Bad Request , } } Usa Case When the function is executed, it can be checked whether the returned error value is `nil' and measures can be taken accordingly. err := MakeRequest () if err != nil { fmt . Println ( err ) } Interface Interfaces are structures that specify the methods an object can have. Therefore, interfaces express the behavior of objects. For example; data can be read from or written to a file. If an interface contains reading and writing methods and the file object has these methods, it can be said that the file has implemented this interface. The main purpose of Interfaces is to create a common protocol for different data structures that show the same behavior but are used in different cases by defining the methods, the parameters they take and the return values in a general way; . Definition To indicate that one type uses an interface, we do not need to use expressions like class File implements IO , as in most other object oriented languages. GO establishes the relationship between interfaces and types by sharing the same methods. type IOInterface interface { Read () [] byte Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } type Socket struct { ip string port int buffer [] byte } func ( sock * Socket ) Read () [] byte { return sock . buffer } func ( sock * Socket ) Write ( stream [] byte ) int { sock . buffer = append ( sock . buffer , stream ... ) return len ( stream ) } In the above application, we have defined the 'IO' interface that defines the 'Read' and 'Write' methods, and the 'File' and 'Socket' types with these methods. Use Case In the example below, since the Log method takes the IO interface as a parameter, it can read the data and do its job without worrying about which data type it comes from. type Logger struct { } func ( log * Logger ) Log ( io IO ) { for _ , data := range io . Read () { fmt . Print ( string ( data )) } fmt . Println () } file := File { name : test } sock := Socket { ip : 0.0.0.0 , port : 21 } logger := Logger {} data := [] byte ( data ) file . Write ( data ) sock . Write ( file . Read ()) logger . Log ( file ) // data logger . Log ( sock ) // data Using Multiple Interfaces GO types can implement multiple interfaces. For this, it only needs to have the methods of the interface. type Reader interface { Read () [] byte } type Writer interface { Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } var file Reader = File { name : test , content : [] byte ( data ), } var sock Writer = Socket { ip : 0.0.0.0 , port : 21 , } sock . Write ( file . Read ()) sock . buffer // sock.buffer undefined (type Writer has no field or method buffer Type Conversion If we need to take advantage of certain properties of data type hierarchies, we need to convert assets from one data type to another. We can check whether the type we are converting correctly implements that interface with an additional parameter that we can get from conversion. s := sock .( * Socket ) string ( s . buffer ) // data type Serializer interface { Serialize () } s , ok := sock .( Serializer ) s , ok // nil, false Empty Interface Interfaces are types like other data structures and can be used in the same way. Empty interface in GO projects; It is defined as interface {} . Since it has no method, the requirements of the empty interface are met by all types. This feature of the empty interface allows us to define dynamic parameters and values. type Booking struct { Provider string CustomerID string ExtraProviderParams interface {} } booking1 := Booking { Provider : ACL , CustomerID : customer-01a , ExtraProviderParams : map [ string ] interface {}{ Passengers : 4 , PaymentTime : after-booking , }, } booking2 := Booking { Provider : DCM , CustomerID : customer-03f , ExtraProviderParams : [] interface {}{ 4 , after-booking , }, } booking1 // {ACL customer-01a map[Passengers:4 PaymentTime:after-booking]} booking2 // {DCM customer-01a [4 after-booking]} Type Checking Interface types can be controlled by the switch structure. In the example below, the Stringify function allows us to use different data types in the function by taking the parameter as interface {} . In this function, we will check the int string and float incoming values according to their types and convert them to string as we determine. func Stringify ( value interface {}) ( string , error ) { switch value .( type ) { case string : return value .( string ), nil case float32 , float64 : return fmt . Sprintf ( %.2f , value ), nil case int : return fmt . Sprintf ( %d , value ), nil default : return , errors . New ( Invalid type ) } } Stringify ( 12 ) // 12 Stringify ( 12.52312313 ) // 12.52 Stringify ( test ) // test Additional Resources https://medium.com/rungo/structures-in-go-76377cc106a2 https://golangbot.com/arrays-and-slices/ https://blog.golang.org/go-slices-usage-and-internals https://gobyexample.com/slices https://medium.com/rungo/the-anatomy-of-slices-in-go-6450e3bb2b94 https://opensource.com/article/18/7/introduction-go-arrays-and-slices https://appliedgo.net/slices/ https://gobyexample.com/maps https://blog.golang.org/go-maps-in-action https://medium.com/rungo/the-anatomy-of-maps-in-go-79b82836838b https://github.com/Pungyeon/clean-go-article https://medium.com/rungo/error-handling-in-go-f0125de052f0 https://github.com/golang/go/wiki/SliceTricks https://gobyexample.com/variadic-functions https://github.com/emirpasic/gods https://github.com/avelino/awesome-go https://golangbot.com/pointers/ http://www.golang-book.com/books/intro/8 https://medium.com/rungo/the-anatomy-of-arrays-in-go-24429e4491b7 https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca https://medium.com/rungo/interfaces-in-go-ab1601159b3a https://medium.com/@dotronglong/interface-naming-convention-in-golang-f53d9f471593 https://yourbasic.org/golang/interfaces-explained/ https://medium.com/rungo/structures-in-go-76377cc106a2 https://talks.golang.org/2012/10things.slide#9 https://flaviocopes.com/go-empty-interface/ https://research.swtch.com/interfaces https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go","title":"Data Structures"},{"location":"data-structures/#array","text":"Arrays are structures that enable us to keep the same types of data together. For example; A list consisting of 4, 5, 19 and 25 defines an array. Go does not allow us to create arrays from different data types.","title":"Array"},{"location":"data-structures/#definition","text":"Arrays are basically defined as [Size]Type . We can see several ways to create arrays below. An array capable of holding 3 units of type string . var fruits [ 3 ] string When defined as such, each field in the array is filled with the default value of the data type. Based on this example, it will be defined as [0, 0, 0] . We can change these values \u200b\u200bby accessing them on their indexes. fruits [ 0 ] = \ud83c\udf4c fruits [ 1 ] = \ud83c\udf4f fruits // [\ud83c\udf4c \ud83c\udf4f] If we use a data type other than the one defined for Array, we will encounter an error. arr [ 2 ] = 1 cannot use 1 ( type int ) as type string in assignment We can define the same array in a shorter way. fruits := [ 3 ] int { \ud83c\udf4c , \ud83c\udf4f } fruits // [\ud83c\udf4c \ud83c\udf4f] In this definition, we assign a 3 unit long array whose first 2 elements we directly define to the variable 'arr'. If we are going to create the arrayi with the values, we can leave the dimension calculation part to compiler using the expression ... fruits := [] int { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf49] Using with Loop Arrays can be used basically in 2 ways with the for loop. 1- Accessing with Index. fruits := [ 3 ] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } for index := range fruits { fruit := fruits [ index ] fmt . Println ( fruit ) } 2- By directly accessing the value. fruits := [ 3 ] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } for _ , fruit := range fruits { fmt . Println ( fruit ) }","title":"Definition"},{"location":"data-structures/#slice","text":"Slices are very similar to arrays in terms of usage. The difference of slices is that their size is dynamic. When defining slice, we use the structure of []Type as in the array, but we leave the brackets empty. // define nil slice var slc [] int // assigning value to nill slice slc = [] int { 12 , 24 , 39 } // direct identification slc := [] int { 12 , 24 , 39 }","title":"Slice"},{"location":"data-structures/#make","text":"We can also use the make function to define the slice. The first parameter of the make function determines the size of the slice to be created. // define by size n_items = 20 slc := make ([] int , n_items ) // definition by size and capacity capacity := 40 slc := make ([] int , n_items , capacity )","title":"make"},{"location":"data-structures/#slice-operations","text":"While creating the slice, it is filled with the default value of the data type that it will hold, as much as its capacity. However, only part of its length can be accessed. If we want to increase the size of a slice, we can use the append and copy functions for this.","title":"Slice Operations"},{"location":"data-structures/#copy","text":"copy allows us to copy one slice of another slicea of \u200b\u200bthe same or larger capacity and returns how many elements are copied. bucket := make ([] string , 5 ) fruits := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } n_copied := copy ( bucket , fruits ) n_copied // 5 bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49] When copying a slice, the elements replace the elements in the same index in the target slice. fruits := [] string { \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } apples := [] string { \ud83c\udf4e , , \ud83c\udf4f } copy ( fruits , apples ) fruits // [\ud83c\udf4e \ud83c\udf4f]","title":"copy"},{"location":"data-structures/#append","text":"The append function takes the slice that we will increase in size as the first parameter and the elements we will add later and return a new slice containing all the elements to us. Therefore, it is necessary to keep the return value in a variable (usually the old slice variable). bucket := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf48 , \ud83c\udf49 } green_apple := \ud83c\udf4f bucket = append ( bucket , green_apple ) bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49 \ud83c\udf4f] When we resize a slice and assign it to another variable, changes in the new slice will also affect the original slice. fruits := [] string { \ud83c\udf4e , \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } apples := fruits [: 2 ] apples [ 0 ] = \ud83c\udf4f apples [ 1 ] = \ud83c\udf4f apples // [\ud83c\udf4f \ud83c\udf4f] fruits // [\ud83c\udf4f \ud83c\udf4f \ud83c\udf47 \ud83c\udf52 \ud83c\udf49]","title":"append"},{"location":"data-structures/#cut","text":"If we want to subtract a certain range in the slice, we can use the method below. This method will add the elements up to the start index we have specified in Slice and the elements after the end index. Thus, we will frustrate the elements in between. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } cut_start_index , cut_end_index := 4 , 6 edibles = append ( edibles [: cut_start_index ], edibles [ cut_end_index :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54]","title":"cut"},{"location":"data-structures/#delete","text":"If we want to delete an element in the slice using its index, we can use the following method. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 edibles = append ( edibles [: index_of_cherry ], edibles [ index_of_cherry + 1 :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] We can do the same with the copy function. In the example below, unlike the above, line 4: First, we selected the section after the element of \u00e9edible in slice. This gave us a slice in the format \\ [\ud83c\udf52 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54 ], if we show all the capacity. Then, after the element `` 1 '' index, we have _ replaced_ with the selected slice. Thus, we have obtained the list of [[\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54 \ud83e\udd54 ]. In line 5, we slice the slice according to the number of new staff. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 n_copied := copy ( edibles [ index_of_cherry :], edibles [ index_of_cherry + 1 :]) new_length := index_of_cherry + n_copied edibles = edibles [: new_length ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54]","title":"delete"},{"location":"data-structures/#delete-without-preserving-order","text":"We can also do the deletion by ignoring the array order. In the example below, we have replaced the last element in the slice with the element we want to delete. Then we reduced the size of the slice by 1. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 edibles [ index_of_cherry ] = edibles [ len ( edibles ) - 1 ] edibles = edibles [: len ( edibles ) - 1 ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83e\udd54 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d] Garbage Collection If the elements we use in slice are struct with pointer or pointer fields, the cut and delete operations shown above can create a memory leak. The reason for this is that after slice is deleted, it can keep the reference of the deleted element. In addition to the operations we have done in the examples below, we filled in the fields that were idle after my process with nil values. Thus, garbage collector can understand that these areas will no longer be used and bring them back to the system.","title":"Delete Without Preserving Order"},{"location":"data-structures/#cut-memory-safe","text":"apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } cut_start_index , cut_end_index := 1 , 5 copy ( fruits [ cut_start_index :], fruits [ cut_end_index :]) cleanup_index := len ( fruits ) - cut_end_index + cut_start_index for free_index , free_end := cleanup_index , len ( fruits ); free_index free_end ; free_index ++ { fruits [ free_index ] = nil } fruits = fruits [: cleanup_index ] fruits // [\ud83c\udf4e \ud83c\udf4c]","title":"cut (memory safe)"},{"location":"data-structures/#delete-memory-safe","text":"apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } delete_index := 2 copy ( fruits [ delete_index :], fruits [ delete_index + 1 :]) fruits [ len ( fruits ) - 1 ] = nil fruits = fruits [: len ( fruits ) - 1 ] fruits // [\ud83c\udf4e \ud83c\udf4e \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c]","title":"delete (memory safe)"},{"location":"data-structures/#delete-without-preserving-order-memory-safe","text":"apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } delete_index := 2 fruits [ delete_index ] = fruits [ len ( fruits ) - 1 ] fruits [ len ( fruits ) - 1 ] = nil fruits = fruits [: len ( fruits ) - 1 ] fruits // [\ud83c\udf4e \ud83c\udf4e \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c]","title":"Delete Without Preserving Order (memory safe)"},{"location":"data-structures/#expand","text":"If we want to combine one slice and the other, we can use the following methods. bucket := [] string { \ud83c\udf4c , \ud83c\udf47 , \ud83c\udf49 } apples := [] string { \ud83c\udf4f , \ud83c\udf4e } bucket = append ( bucket , apples ... ) bucket // [\ud83c\udf4c \ud83c\udf47 \ud83c\udf49 \ud83c\udf4f \ud83c\udf4e] In the example below, we have combined the elements after the index determined by apples in line 7 . Afterwards, we added these slice elements to the bucket items up to the index we determined. bucket := [] string { \ud83c\udf4c , \ud83c\udf47 , \ud83c\udf49 } apples := [] string { \ud83c\udf4f , \ud83c\udf4e } expand_index := 2 bucket = append ( bucket [: expand_index ] append ( apples , bucket [ expand_index :] ... ) ... , ) bucket // [\ud83c\udf4c \ud83c\udf47 \ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"expand"},{"location":"data-structures/#filter","text":"We can filter the slice elements according to a certain criterion. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 , \ud83c\udf4f , \ud83c\udf4e } apple_criteria := \ud83c\udf4e apples := [] string {} for _ , fruit := range fruits { if fruit == apple_criteria { apples = append ( apples , fruit ) } } apples // [\ud83c\udf4e \ud83c\udf4e]","title":"filter"},{"location":"data-structures/#insert","text":"If we want to add a new element to any part of the slice; we can use these methods. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c insert_index := 2 fruits = append ( fruits [: insert_index ], append ([] string { banana }, fruits [ insert_index :] ... ) ... , ) fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49] Memory Concern The append([]string{banana}, fruits[insert_index:] ...) section in line 7 creates a slice itself and copies the elements of the slice fruits[insert_index:] to this slicea. These elements are then copied to the fruits slice. Creating a new slice and copying for the 2nd time can be avoided. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c insert_index := 2 fruits = append ( fruits , ) copy ( fruits [ insert_index + 1 :], fruits [ insert_index :]) fruits [ insert_index ] = banana fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49]","title":"insert"},{"location":"data-structures/#pop","text":"In the example below, we have removed the last element of the slice and assigned it to a variable. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } item , fruits := fruits [ len ( fruits ) - 1 ], fruits [: len ( fruits ) - 1 ] item // \ud83c\udf49 fruits // [\ud83c\udf4f \ud83c\udf4e]","title":"pop"},{"location":"data-structures/#push-front-unshift","text":"In this example, we put a new element at the beginning of the slice. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c fruits = append ([] string { banana }, fruits ... ) fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"push front (unshift)"},{"location":"data-structures/#pop-front-shift","text":"In this example, we removed the first element of the slice and assigned it to a variable. fruits := [] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana , fruits := fruits [ 0 ], fruits [ 1 :] banana // \ud83c\udf4c fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"pop front (shift)"},{"location":"data-structures/#map","text":"One of the most frequently used data types is maps. map holds values with a unique keys.","title":"Map"},{"location":"data-structures/#identification","text":"Maps can be defined as map[KeyType]ValueType or make(map[KeyType]ValueType) . var mymap = map [ string ] string {} mymap = make ( map [ string ] string )","title":"Identification"},{"location":"data-structures/#assigning-value","text":"monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 1979 : Life of Brian , } monty_python_films_by_year [ 1983 ] = The Meaning of Life We can access the values \u200b\u200bwe assign using the same key. film_name := monty_python_films_by_year [ 1983 ] film_name // The Meaning of Life When accessing an element of Mapin, we can access an additional value that indicates whether the element is registered in the map. film_name , registered := monty_python_films_by_year [ 2019 ] if ! registered { fmt . Println ( Monty python did not relase a film at 2019 ) } else { fmt . Println ( film_name ) }","title":"Assigning Value"},{"location":"data-structures/#accessing-to-values-using-with-for","text":"Map values are accessible in 2 ways. 1- By using one variable in the for loop, by accessing through keys. monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 1979 : Life of Brian , 1983 : The Meaning of Life , } for year := range monty_python_films_by_year { film_name := monty_python_films_by_year [ year ] fmt . Println ( film_name , was released at , year ) } 2- Using 2 variables in the loop, accessing both key and value. for year , film_name := range monty_python_films_by_year { fmt . Println ( film_name , was released at , year ) } /* Monty Python and the Holy Grail was released at 1971 Life of Brian was released at 1979 The Meaning of Life was released at 1983 */","title":"Accessing to values using with for"},{"location":"data-structures/#delete_1","text":"We can use the delete function to delete an element on the map. monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 2016 : Batman v Superman , } delete ( monty_python_films_by_year , 2016 ) _ , registered := monty_python_films_by_year [ 2016 ] registered // false len ( monty_python_films_by_year ) // 1","title":"delete"},{"location":"data-structures/#struct","text":"Structs are user-defined data structures that can hold different types of data with their names.","title":"struct"},{"location":"data-structures/#definition_1","text":"Structs can be defined as follows. type StructName struct { field fieldType } We can define the fields of the same type of struct in one line. type Film struct { name , director string imdb float32 release_year int } var new_film = Film {} new_film // { 0 0} We can also give tags to the struct fields. type Film struct { Name string `json: film_name ` Director string `json: director_name ` Imdb float32 `json: imdb_score ` ReleaseYear int `json: year_of_release ` } Tags are popular among ORMs and serialization libraries that deal with type conversion. These tags can be accessed with the 'reflect` module. f := Film {} t := reflect . TypeOf ( f ) for _ , f := range [] string { Name , Director , Imdb , ReleaseYear } { field , found := t . FieldByName ( f ) if ! found { continue } fmt . Println ( field . Tag . Get ( json )) } /* film_name director_name imdb_score year_of_release */","title":"Definition"},{"location":"data-structures/#assigning-value_1","text":"A struct can be created by giving its parameters in order. new_film := Film { Mad Max: Fury Road , George Miller , 8.1 , 2015 } new_film // {Mad Max: Fury Road George Miller 8.1 2015} Similarly, it can be created by specifying the parameters and the values with the separator : . new_film := Film { Name : Ran , Director : Akira Kurosawa , Imdb : 8.2 , ReleaseYear : 1985 , } new_film // {Ran Akira Kurosawa 8.2 1985} If some fields are left blank while creating Struct; these fields are defined by the null values of that data type. new_film := Film { name : Batman v Superman , director : Zack Snyder , release_year : 2016 , } new_film // {Batman v Superman Zack Snyder 0 2016}","title":"Assigning Value"},{"location":"data-structures/#anonymous-struct","text":"In some special cases, we may need to define structs in the function body. We can do this by the following method. provider_config := struct { name string baseUrl string apiKey string }{ name : mapbox , baseUrl : https://api.mapbox.com/geocoding/v5/ , apiKey : 123asds123 , } provider_config // {mapbox https://api.mapbox.com/geocoding/v5/ 123asds123}","title":"Anonymous struct"},{"location":"data-structures/#anonymous-fields","text":"Struct can also be defined without specifying field names. The data types specified in such a definition must be different from each other. type Item struct { string // code int // quantity float32 // price } item := Item { child-seat-1 , 5 , 20.1 , } item // {child-seat 5 20.1}","title":"Anonymous fields"},{"location":"data-structures/#promoted-fields","text":"A struct can be used in another struct without giving the domain name. In this case, the structure inside is accessed by its own name. Based on the example below, Content in Page can be accessed as page.Content . type Content struct { body string size int } type Page struct { nextUrl string previousURL string Content } content := Content { body : h1 Hi /h1 , size : 11 , } page := Page { nextUrl : http://.../3 , previousURL : http://.../1 , Content : content , } page // {http://.../3 http://.../1 { h1 Hi /h1 11}} page . Content // { h1 Hi /h1 11}","title":"Promoted fields"},{"location":"data-structures/#pointer","text":"Pointer is a variable that holds the memory address of another variable. When a new object is created in runtime, we need to keep it in memory. We substitute the space allocated in the memory for the object with variables.","title":"Pointer"},{"location":"data-structures/#definition_2","text":"Pointers are also variables. The difference from other variables is that it keeps the address of the variable that indicates the location of that data, not any data. A pointer can be defined using the var pointer * Type structure. If no value is assigned, the value of the pointer is determined as nil . var ptr * int ptr // nil We can also define pointers using the new function. ptr := new ( int ) ptr // nil","title":"Definition"},{"location":"data-structures/#assigning-value_2","text":"Assigning Value We can assign the address of another variable as a value to the Pointer by using the sign. Using the pointer with the * sign, we can access the variable it is pointing to (hence the data). var carbon string = Carbon var ptrCarbon * string ptrCarbon = carbon ptrCarbon // 0xc000092030 * ptrCarbon // Carbon * ptrCarbon = Altered + * ptrCarbon carbon // Altered Carbon","title":"Assigning Value"},{"location":"data-structures/#functions","text":"In general, functions in GO are defined in the following structure. func fonksiyon_name ([ list of parameters ]) [ returning data types ] { function body } func sigmoid ( value float64 ) float64 { return 1.0 / ( 1.0 + math . Exp ( - value )) } sigmoid ( 0.5 ) // 0.62246","title":"Functions"},{"location":"data-structures/#parameters","text":"Parameters given to functions are copied. For this reason, changes made on the parameters do not affect the status of variables outside the function. type Wallet struct { userID int balance float64 deposit float64 } func withdraw ( wallet Wallet , amount float64 ) { wallet . balance -= amount } In the above code, we have simply defined a wallet structure and the 'withdraw' function that can withdraw money from the wallet. In the lines below, we created a wallet and used it with this function. wallet := Wallet { userID : 1 , balance : 30000.12 , deposit : 40000.01 , } item_price := 10023.0 withdraw ( wallet , item_price ) wallet . balance // 3000.12 As you can see, the money in the wallet has not changed. We can prevent this type of accident in 2 ways. Method 1, we can return the new balance of the wallet and update the wallet later. func withdraw ( wallet Wallet , amount float64 ) float64 { new_balance := wallet . balance - amount return new_balance } wallet . balance = withdraw ( wallet , item_price ) wallet . balance // 19977.12 This change changes the intended use of the withdraw function, whose job is to withdraw money from the wallet. Method 2, Instead of the wallet variable, we can give the wallet's address as a parameter. func withdraw ( wallet * Wallet , amount float64 ) { wallet . balance -= amount } withdraw ( wallet , item_price ) wallet . balance // 19977.12 The disadvantage of this method is that it is not thread safe. When we want to withdraw money from the wallet with different threads, it will be difficult to keep track of the balance status.","title":"Parameters"},{"location":"data-structures/#dynamic-parameters","text":"Dynamic parameters can be defined in GO functions. To define the parameters of this type, the sign ... is written before the parameter type. func ReLU ( nums ... float64 ) [] float64 { new_nums := make ([] float64 , len ( nums )) for idx , value := range nums { if value 0 { new_nums [ idx ] = value } else { new_nums [ idx ] = 0. } } return new_nums } nums := [] float64 { 1. , 0.2 , 0. , 0. , - 0.1 , 0.1 } nums = ReLU ( nums ... ) nums // [1 0.2 0 0 0 0.1]","title":"Dynamic parameters"},{"location":"data-structures/#return-values","text":"","title":"Return Values"},{"location":"data-structures/#returning-multiple-values","text":"Multiple values can be returned in GO functions. It is necessary to define the values to be returned in order between () . func swap ( first_arg , second_arg string ) ( string , string ) { return second_arg , first_arg } var language1 , language2 string = Python , GO language1 , language2 = swap ( language1 , language2 ) language1 , language2 // GO Python","title":"Returning multiple values"},{"location":"data-structures/#naming-return-values","text":"We can name the return values of the functions and determine the values with these variables. Since the named return values will take the null value of the data type, they can also be used as the default return values of the function. type Record struct { id int data string } type DB struct { records [] Record locked bool } func BulkCreate ( records [] Record , db * DB ) ( n_created int , err error ) { if db . locked { err = errors . New ( DB is locked ) } else { db . records = append ( db . records , records ... ) n_created = len ( records ) } return n_created , err } db := DB { records : [] Record {}, locked : true , } data := [] Record {} for i := 0 ; i 100 ; i ++ { rec := Record { id : i , data : test , } data = append ( data , rec ) } n_created , err := BulkCreate ( data , db ) if err != nil { fmt . Println ( err ) }","title":"Naming Return Values"},{"location":"data-structures/#anonymous-function","text":"Functions in GO are also variable and can be defined within other functions. We can use anonymous functions in a limited part of the project to get a specific job done. In the code example below, we assumed that we would not need this process elsewhere in the project, we used an anonymous function to break up a slice of the specified size. records := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } batchSize := 3 batchedRecords := func ( data [] int , batchSize int ) [][] int { var batches [][] int for batchSize len ( data ) { data , batches = data [ batchSize :], append ( batches , data [ 0 : batchSize : batchSize ]) } batches = append ( batches , data ) return batches }( records , batchSize ) batchedRecords // [[0 1 2] [3 4 5] [6 7 8] [9]] We can assign this type of functions to a variable and use it several times. In the example below, we combine the country code and phone numbers that are sent separately from a specific API with the function we define as variables. type Vendor struct { name string countryCode string phone string } vendor := Vendor { name : Volswagen Group , countryCode : 1 , phone : 403120120 , } formatPhoneNumbers := func ( contact Vendor ) string { return + + contact . countryCode + contact . phone } formatPhoneNumbers ( vendor ) // +1403120120","title":"Anonymous Function"},{"location":"data-structures/#methods","text":"There are no classes or inheritance in GO language like other object oriented programming languages. An experience similar to object oriented programming can be achieved in GO language by adding an additional argument called `receiver 'to the functions. type Connection struct { host string port int timeOut int isClosed bool } func ( conn * Connection ) Close () { conn . isClosed = true fmt . Println ( Connection , conn . host + : + strconv . Itoa ( conn . port ), closed. ) } In the above structure, we have added (conn * Connection) to the Close function in addition to a normal function. Thus, as we can see in the example below, we were able to access the function via the Connection type as c.Close () . c := Connection { host : 0.0.0.0 , port : 8080 , timeOut : 1 , isClosed : false , } c . Close () // Connection 0.0.0.0:8080 closed.","title":"Methods"},{"location":"data-structures/#pointer-receiver-value-receiver","text":"As with the function parameters, it should be decided whether the receivers will be used with the value of the structure or the memory address. We can also use receivers for types other than struct. type Iterable [] int func ( iterable * Iterable ) Append ( items ... int ) { * iterable = append ( * iterable , items ... ) } arr := Iterable { 1 , 2 } arr . Append ( 4 , 5 , 6 ) arr // [1 2 4 5 6]","title":"Pointer receiver | Value receiver"},{"location":"data-structures/#errors","text":"In GO, we can create our own error types. To achieve this, the data type must implement the Error method.","title":"Errors"},{"location":"data-structures/#definition_3","text":"In the example below, we have defined a new error called 'HTTPError', which indicates the HTTP code and the reason for the error. type HTTPError struct { Status int Reason string } func ( e HTTPError ) Error () string { return fmt . Sprintf ( %v: %v , e . Status , e . Reason ) } func MakeRequest () error { return HTTPError { Status : 400 , Reason : Bad Request , } }","title":"Definition"},{"location":"data-structures/#usa-case","text":"When the function is executed, it can be checked whether the returned error value is `nil' and measures can be taken accordingly. err := MakeRequest () if err != nil { fmt . Println ( err ) }","title":"Usa Case"},{"location":"data-structures/#interface","text":"Interfaces are structures that specify the methods an object can have. Therefore, interfaces express the behavior of objects. For example; data can be read from or written to a file. If an interface contains reading and writing methods and the file object has these methods, it can be said that the file has implemented this interface. The main purpose of Interfaces is to create a common protocol for different data structures that show the same behavior but are used in different cases by defining the methods, the parameters they take and the return values in a general way; .","title":"Interface"},{"location":"data-structures/#definition_4","text":"To indicate that one type uses an interface, we do not need to use expressions like class File implements IO , as in most other object oriented languages. GO establishes the relationship between interfaces and types by sharing the same methods. type IOInterface interface { Read () [] byte Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } type Socket struct { ip string port int buffer [] byte } func ( sock * Socket ) Read () [] byte { return sock . buffer } func ( sock * Socket ) Write ( stream [] byte ) int { sock . buffer = append ( sock . buffer , stream ... ) return len ( stream ) } In the above application, we have defined the 'IO' interface that defines the 'Read' and 'Write' methods, and the 'File' and 'Socket' types with these methods.","title":"Definition"},{"location":"data-structures/#use-case","text":"In the example below, since the Log method takes the IO interface as a parameter, it can read the data and do its job without worrying about which data type it comes from. type Logger struct { } func ( log * Logger ) Log ( io IO ) { for _ , data := range io . Read () { fmt . Print ( string ( data )) } fmt . Println () } file := File { name : test } sock := Socket { ip : 0.0.0.0 , port : 21 } logger := Logger {} data := [] byte ( data ) file . Write ( data ) sock . Write ( file . Read ()) logger . Log ( file ) // data logger . Log ( sock ) // data","title":"Use Case"},{"location":"data-structures/#using-multiple-interfaces","text":"GO types can implement multiple interfaces. For this, it only needs to have the methods of the interface. type Reader interface { Read () [] byte } type Writer interface { Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } var file Reader = File { name : test , content : [] byte ( data ), } var sock Writer = Socket { ip : 0.0.0.0 , port : 21 , } sock . Write ( file . Read ()) sock . buffer // sock.buffer undefined (type Writer has no field or method buffer","title":"Using Multiple Interfaces"},{"location":"data-structures/#type-conversion","text":"If we need to take advantage of certain properties of data type hierarchies, we need to convert assets from one data type to another. We can check whether the type we are converting correctly implements that interface with an additional parameter that we can get from conversion. s := sock .( * Socket ) string ( s . buffer ) // data type Serializer interface { Serialize () } s , ok := sock .( Serializer ) s , ok // nil, false","title":"Type Conversion"},{"location":"data-structures/#empty-interface","text":"Interfaces are types like other data structures and can be used in the same way. Empty interface in GO projects; It is defined as interface {} . Since it has no method, the requirements of the empty interface are met by all types. This feature of the empty interface allows us to define dynamic parameters and values. type Booking struct { Provider string CustomerID string ExtraProviderParams interface {} } booking1 := Booking { Provider : ACL , CustomerID : customer-01a , ExtraProviderParams : map [ string ] interface {}{ Passengers : 4 , PaymentTime : after-booking , }, } booking2 := Booking { Provider : DCM , CustomerID : customer-03f , ExtraProviderParams : [] interface {}{ 4 , after-booking , }, } booking1 // {ACL customer-01a map[Passengers:4 PaymentTime:after-booking]} booking2 // {DCM customer-01a [4 after-booking]}","title":"Empty Interface"},{"location":"data-structures/#type-checking","text":"Interface types can be controlled by the switch structure. In the example below, the Stringify function allows us to use different data types in the function by taking the parameter as interface {} . In this function, we will check the int string and float incoming values according to their types and convert them to string as we determine. func Stringify ( value interface {}) ( string , error ) { switch value .( type ) { case string : return value .( string ), nil case float32 , float64 : return fmt . Sprintf ( %.2f , value ), nil case int : return fmt . Sprintf ( %d , value ), nil default : return , errors . New ( Invalid type ) } } Stringify ( 12 ) // 12 Stringify ( 12.52312313 ) // 12.52 Stringify ( test ) // test","title":"Type Checking"},{"location":"data-structures/#additional-resources","text":"https://medium.com/rungo/structures-in-go-76377cc106a2 https://golangbot.com/arrays-and-slices/ https://blog.golang.org/go-slices-usage-and-internals https://gobyexample.com/slices https://medium.com/rungo/the-anatomy-of-slices-in-go-6450e3bb2b94 https://opensource.com/article/18/7/introduction-go-arrays-and-slices https://appliedgo.net/slices/ https://gobyexample.com/maps https://blog.golang.org/go-maps-in-action https://medium.com/rungo/the-anatomy-of-maps-in-go-79b82836838b https://github.com/Pungyeon/clean-go-article https://medium.com/rungo/error-handling-in-go-f0125de052f0 https://github.com/golang/go/wiki/SliceTricks https://gobyexample.com/variadic-functions https://github.com/emirpasic/gods https://github.com/avelino/awesome-go https://golangbot.com/pointers/ http://www.golang-book.com/books/intro/8 https://medium.com/rungo/the-anatomy-of-arrays-in-go-24429e4491b7 https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca https://medium.com/rungo/interfaces-in-go-ab1601159b3a https://medium.com/@dotronglong/interface-naming-convention-in-golang-f53d9f471593 https://yourbasic.org/golang/interfaces-explained/ https://medium.com/rungo/structures-in-go-76377cc106a2 https://talks.golang.org/2012/10things.slide#9 https://flaviocopes.com/go-empty-interface/ https://research.swtch.com/interfaces https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go","title":"Additional Resources"},{"location":"tr/","text":"Go Dersi English | T\u00fcrk\u00e7e Konular Veri Yap\u0131lar\u0131 Array, Slice, Map, Struct, Interface, Error, ve di\u011fer temel veri yap\u0131lar\u0131n\u0131n kullan\u0131m\u0131. Concurrency E\u015fzamanl\u0131 \u00e7al\u0131\u015fma tasar\u0131mlar\u0131n\u0131n Go dilinde kullan\u0131m\u0131.","title":"Go Dersi"},{"location":"tr/#go-dersi","text":"English | T\u00fcrk\u00e7e","title":"Go Dersi"},{"location":"tr/#konular","text":"Veri Yap\u0131lar\u0131 Array, Slice, Map, Struct, Interface, Error, ve di\u011fer temel veri yap\u0131lar\u0131n\u0131n kullan\u0131m\u0131. Concurrency E\u015fzamanl\u0131 \u00e7al\u0131\u015fma tasar\u0131mlar\u0131n\u0131n Go dilinde kullan\u0131m\u0131.","title":"Konular"},{"location":"tr/best-practices/","text":"Best Practices A language that doesn\u2019t affect the way you think about programming is not worth knowing.\u200a\u2014\u200aAlan Perlis Genel Prensipler Keep it simple Don\u2019t Repeat Yourself You ain't gonna need it Avoid Nesting \u0130yi GO kodu dilin kendi kodlar\u0131 gibidir. Standart olarak bu yaz\u0131m tercih edilmelidir. // Reset clears the state of the Writer z such that it is equivalent to its // initial state from NewWriterLevel or NewWriterLevelDict, but instead writing // to w. func ( z * Writer ) Reset ( w io . Writer ) { z . w = w // z.level and z.dict left unchanged. if z . compressor != nil { z . compressor . Reset ( w ) } if z . digest != nil { z . digest . Reset () } z . err = nil z . scratch = [ 4 ] byte {} z . wroteHeader = false } https://go-proverbs.github.io/ Kodlama Composition Fragile Base Class Problemi Fragile base class problemi nesne y\u00f6nelimli programlama sistemlerindeki temel bir mimari problemidir. Bu mimarilerde ana s\u0131n\u0131flar k\u0131r\u0131lgan kabul edilir. Bunun sebebi \u00fcst s\u0131n\u0131ftaki bir de\u011fi\u015fikli\u011fin alt s\u0131n\u0131flara da yans\u0131mas\u0131 ve alt s\u0131n\u0131flarda i\u015flev bozuklu\u011funa sebep olabilmesidir. Yaz\u0131l\u0131mc\u0131 bu t\u00fcr mimarilerde ana s\u0131n\u0131f\u0131n metodlar\u0131n\u0131 izole edemez ve bu nedenle ana s\u0131n\u0131fta yap\u0131lan de\u011fi\u015fikliklerin g\u00fcvenli olup olmad\u0131\u011f\u0131n\u0131ndan emin olamaz. Bu t\u00fcr dillerde kal\u0131t\u0131m yerine kompozisyon tercih edilmelidir. Kompleks ve hiyerar\u015fik yap\u0131lar kodun esnekli\u011fini kaybettirir. https://en.wikipedia.org/wiki/Composition_over_inheritance Kompozisyon y\u00f6nteminde ise bir s\u0131n\u0131f\u0131n di\u011ferinin t\u00fcm \u00f6zelliklerini miras almak yerine parametre olarak belli \u00f6zellikleri se\u00e7ilebilir. GO dilininin yaz\u0131l\u0131mc\u0131lar\u0131 kompozisyona itmesi en g\u00fc\u00e7l\u00fc \u00f6zelliklerinden birisidir. Loose Coupling Yaz\u0131l\u0131m d\u00fcnyas\u0131nda, coupling iki birimin birbirine ne kadar ba\u011f\u0131ml\u0131 oldu\u011funun \u00f6l\u00e7\u00fcs\u00fcd\u00fcr. Par\u00e7alar\u0131n\u0131n birbirine s\u0131k\u0131 s\u0131k\u0131ya ba\u011fl\u0131 oldu\u011fu programlarda de\u011fi\u015fiklik yapmak \u00e7ok zordur. Bu duruma shotgun surgery efekti de denir. Shotgun surgery terimi, projenin bir k\u0131sm\u0131nda yap\u0131lan de\u011fi\u015fikli\u011fin di\u011fer k\u0131s\u0131mlar\u0131nda s\u0131ral\u0131 halde ufak de\u011fi\u015fikliklere yol a\u00e7mas\u0131d\u0131r. \u00d6rnek vermek gerekirse: type Booking struct { ID int Status string } type DB struct {} func ( d DB ) Booking ( ID int ) * Booking {} type Client struct {} func Cancel ( ID int ) error { db := DB {} if booking := db . Booking ( ID ); booking . Status == active { return errors . New ( booking does not exists ) } return nil } func Get ( ID int ) error { db := DB {} if booking := db . Booking ( ID ); booking . Status == active { return errors . New ( booking does not exists ) } return nil } Yukar\u0131daki kodda Bookinge ait methodlarda tek bir kontrol var. O da bookingin aktif olmas\u0131. Her metoda bu kontrol\u00fc ekleyerek code smell olu\u015fturduk. \u015eimdi \"active\" kontrol\u00fc de\u011fi\u015firse Bookinge ait t\u00fcm metodlarda de\u011fi\u015fiklik yapmak gerekecek. Bu s\u0131k\u0131nt\u0131y\u0131 gidermek i\u00e7in ilk ad\u0131m, kontrol k\u0131sm\u0131n\u0131 ayr\u0131 bir fonksiyonda tan\u0131mlayabiliriz. func validateBooking ( db * DB , ID int ) bool { if booking := db . Booking ( ID ); booking . Status == active { return true } return false } func Cancel ( ID int ) error { db := DB {} if isActive := validateBooking ( db , ID ); isActive { return errors . New ( booking does not exists ) } return nil } func Get ( ID int ) error { db := DB {} if isActive := validateBooking ( db , ID ); isActive { return errors . New ( booking does not exists ) } return nil } Do\u011frulamada bir de\u011fi\u015fiklik oldu\u011funda art\u0131k sadece validateBooking fonksiyonun de\u011fi\u015ftirilmesi yeterli. Single Responsibility Yukar\u0131daki kod par\u00e7as\u0131nda hala d\u00fczeltilmesi gereken k\u0131s\u0131mlar var. validateBooking fonksiyonu DB tipini do\u011frudan kullan\u0131yor. Bu hem tight coupling olu\u015fmas\u0131na hem de i\u015fi sadece bookinglerin durumunu kontrol etmek olan fonksiyonun veritaban\u0131na da eri\u015ferek birden fazla i\u015f yapmas\u0131na sebep oluyor. // booking.go type Booking struct { ID int Status string } func ( b Booking ) Validate () bool { if b . Status == active { return true } return false } // db.go type DB struct {} func ( d DB ) Get ( ID int ) * Booking { return nil } // client.go type Client struct {} func Cancel ( ID int ) error { db := DB {} booking := db . Get ( ID ) if booking . Validate () { return errors . New ( booking does not exists ) } return nil } func Get ( ID int ) error { db := DB {} booking := db . Get ( ID ) if booking . Validate () { return errors . New ( booking does not exists ) } return nil } Liskov Substitution Nesne y\u00f6nelimli dillerde liskov substitution prensibi; miras alan s\u0131n\u0131f\u0131n, \u00fcst s\u0131n\u0131f ile yer de\u011fi\u015ftirdi\u011fi zaman, ayn\u0131 davran\u0131\u015f\u0131 sergilemesi gerekti\u011fini s\u00f6yler. GOda bu tarz soyut hiyerar\u015filer tan\u0131mlanamaz fakat substitution GO interfacelerinin \u00e7al\u0131\u015fma mant\u0131\u011f\u0131na \u00e7ok benzer. Interface Nesne y\u00f6nelimli programlamada \u00f6\u011frenilen y\u00f6ntemler GOya ta\u015f\u0131nmamal\u0131d\u0131r. Di\u011fer dillerden gelen yaz\u0131l\u0131mc\u0131lar interfaceleri genellikle a\u015fa\u011f\u0131daki \u015fekilde tan\u0131mlar. package rockband type Player interface { Play () } type BandMemeber struct {} func ( b BandMemeber ) Play (){ } package stage func Perform ( p Player ) { p . Play () } Bu tarz kullan\u0131mda Interface tan\u0131mlan\u0131r Interfacei kullanmak i\u00e7in tip tan\u0131mlan\u0131r Tan\u0131mlanan tiplerin interfacei implement eden metodlar\u0131 yaz\u0131l\u0131r Bu GO dilinde net bir \u015fekilde yanl\u0131\u015ft\u0131r \u00e7\u00fcnk\u00fc; interfacei uygulayacak ba\u015fka tipler olu\u015fmadan yani net bir nedenimiz olmadan tan\u0131mlad\u0131k. Daha ideali, \u00f6nce tipleri tan\u0131mlamak ve kullanmak. \u0130htiya\u00e7 duyulan yerde interfacelere ba\u015fvurmak olacakt\u0131r. package rockband type BandMemeber struct {} func ( b BandMemeber ) Play (){ } package stage type Player interface { Play () } func Perform ( p Player ) { p . Play () } Be conservative in what you send, be liberal in what you accept. Jon Postel Postel yasas\u0131n\u0131 GOya uyarlamak gerekirse. Fonksiyonlar parametre olarak interface almal\u0131, struct(belirli bir veri tipi) d\u00f6nmelidir. A great rule of thumb for Go is accept interfaces, return structs. Jack Lindamood Bununla birlikte fonksiyonlar\u0131n parametrelerinin de tamamen soyut olmamas\u0131nda fayda vard\u0131r. the empty interface says nothing Rob Pike Postel yasas\u0131n\u0131n \u00f6nemini test yazarken a\u00e7\u0131k \u015fekilde g\u00f6rebiliriz. Yukar\u0131daki fonksiyondaki Perform parametresinin belirli bir tip yerine interface olmas\u0131, bizi test yazarken ger\u00e7ek bir player objesi olu\u015fturmaktan kurtar\u0131r Open-Closed Software entities should be open for extension, but closed for modification. Bertrand Meyer package main import fmt type Cat struct { Name string } func ( c Cat ) Legs () int { return 4 } func ( c Cat ) PrintLegs () { fmt . Printf ( I have %d legs\\n , c . Legs ()) } type OctoCat struct { Cat } func ( o OctoCat ) Legs () int { return 5 } func main () { var octo OctoCat fmt . Println ( octo . Legs ()) // 5 octo . PrintLegs () // I have 4 legs } // source: https://dave.cheney.net/2016/08/20/solid-go-design Yukar\u0131daki \u00f6rnekte Cat tipi ve bu tipe ait ayak say\u0131s\u0131n\u0131 g\u00f6steren Legs metodu var. OctoCat tipine bu tipi g\u00f6md\u00fck ve Legs fonksiyonunu tan\u0131mlad\u0131k. Bu durumda OctoCat Legs metodundan 5 say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcyor ama PrintLegs metodu yine Legs metodunu kullanmas\u0131na ra\u011fmen 4 d\u00f6nd\u00fcr\u00fcyor. Bunun sebebi PrintLegs metodunun Cat tipi i\u00e7in tan\u0131mlanm\u0131\u015f olmas\u0131 ve receiver olarak Cati almas\u0131. Interface Segregation Clients should not be forced to depend on methods they do not use. Robert C. Martin Interface segregation, pek \u00e7ok davran\u0131\u015f i\u00e7eren b\u00fcy\u00fck veri yap\u0131lar\u0131 olu\u015fturmamam\u0131z\u0131 ve veri tipinin davran\u0131\u015f\u0131n\u0131 izole etmemizi s\u00f6yler. GO dilinde kompozisyon ve k\u00fc\u00e7\u00fck interface kullan\u0131mlar\u0131 benimsenir. Dependency Inversion High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. Robert C. Martin Bu prensibin GOda uygulamas\u0131n\u0131 paket seviyesinde g\u00f6rebiliriz. __ \u00d6nceki prensipler uyguland\u0131\u011f\u0131nda elimizde ama\u00e7lar\u0131 d\u00fczg\u00fcnce tan\u0131mlanm\u0131\u015f kod paketleri olacakt\u0131r. B\u00f6yle bir yap\u0131da kod i\u00e7indeki ba\u011f\u0131ml\u0131l\u0131klar\u0131n interfaceler ile tan\u0131mlanm\u0131\u015f olmas\u0131 ve bu interfacelerin sadece tan\u0131mlad\u0131klar\u0131 fonksiyonlarla alakal\u0131 olmas\u0131 gerekir. GOda importlar acyclic olmal\u0131d\u0131r. Yani A paketi B paketini import ediyorsa, B paketi A'y\u0131 import etmemelidir. __Bu ba\u011flamda Go projelerinin geni\u015f ve d\u00fcz \u015fekilde tasarlanmal\u0131d\u0131r. \u0130\u00e7 i\u00e7e paketler tan\u0131mlamaktan ka\u00e7\u0131n\u0131lmal\u0131d\u0131r. E\u011fer bir paketteki fonksiyon ba\u015fka bir paket olmadan d\u00fczg\u00fcn \u00e7al\u0131\u015fam\u0131yorsa; bu, projenin paket seviyesinde iyi \u015fekilde d\u00fczenlenmedi\u011fini g\u00f6sterir. Dependency inversion prensibi, projedeki as\u0131l i\u015flerin \u00fcst paketlerde, soyutlama/interface i\u015flerinin alt paketlere yapmaya te\u015fvik eder. Closure GO'nun sa\u011flad\u0131\u011f\u0131 interfaceler ve closurelar sayesinde \u00e7ok estetik ve kullan\u0131\u015fl\u0131 APIler yazabiliriz. Closure kendi g\u00f6vdesi d\u0131\u015f\u0131ndaki de\u011fi\u015fkenlere eri\u015fen fonksiyonlard\u0131r. Closure bir de\u011fi\u015fkene atan\u0131p istenildi\u011fi zaman \u00e7a\u011fr\u0131labilir veya ba\u015fka bir fonksiyona parametre olarak verilebilir. HTTP server olu\u015ftururken bu teknik s\u0131kl\u0131kla kullan\u0131l\u0131r. A\u015fa\u011f\u0131daki \u00f6rnekte home fonksiyonunu timed ile sarmalay\u0131p http.HandleFunc metoduna parametre olarak verdik. Bu da home/ end-pointine her istek geldi\u011finde, bu iste\u011fin i\u015flenme s\u00fcresini hesaplamam\u0131z\u0131 sa\u011flad\u0131. func main () { http . HandleFunc ( /hello , timed ( home )) http . ListenAndServe ( :3000 , nil ) } func timed ( f func ( http . ResponseWriter , * http . Request )) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { start := time . Now () f ( w , r ) end := time . Now () fmt . Println ( The request took , end . Sub ( start )) } } func home ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintln ( w , Home ) } GO kaynak kodlar\u0131nda da Closurelara bolca yer verilmi\u015ftir. {% embed url=\"https://github.com/golang/go/blob/4e215554aa0e76e534327b9e6721971b9e82c113/src/sort/sort.go#L307\" %} Concurrency Goroutineler her ne kadar boyutlar\u0131 k\u00fc\u00e7\u00fck ve \u00e7ok kullan\u0131\u015fl\u0131 yap\u0131lar olsa da ba\u011f\u0131ms\u0131z olmalar\u0131 kontrol edilmesi g\u00fc\u00e7 hatalara ve kod i\u00e7inde veri ak\u0131\u015f\u0131n\u0131n karma\u015f\u0131kla\u015fmas\u0131na yol a\u00e7makta. Bu y\u00fczden goroutinelerin \u00e7al\u0131\u015fma rutini API i\u00e7erisinde ve m\u00fcmk\u00fcn oldu\u011funca dar bir alanda tutulmal\u0131d\u0131r. Projede goroutine kullan\u0131lmaya karar verildi\u011finde race-conditionlar\u0131n \u00f6n\u00fcne ge\u00e7mek i\u00e7in \u00f6ncelikle kod senkron olarak tan\u0131mlanmal\u0131d\u0131r. Sonras\u0131nda, veri tipleri e\u015fzamanl\u0131 eri\u015fmeye kar\u015f\u0131 korunmal\u0131d\u0131r. Son olarak da korunan tipler goroutineler ile kullan\u0131lmal\u0131d\u0131r. make(chan struct{}) , sync.WaitGroup , context.Context and select yap\u0131lar\u0131 goroutineler s\u00f6z konusu oldu\u011funda s\u0131k\u00e7a kullan\u0131lmal\u0131 ve goroutinelerin \u00e7al\u0131\u015fma s\u00fcreci kontrol edilmelidir. \u0130deal \u00e7al\u0131\u015fma s\u00fcrecinde, goroutineler istenildi\u011fi zaman durdurulabilmeli. Ayr\u0131ca t\u00fcm sonu\u00e7lar gelene kadar goroutinelerin beklenmelidir. Ayn\u0131 WaitGroup ile farkl\u0131 tipte goroutineleri say\u0131lmamal\u0131d\u0131r. type Parent struct { wgFoo sync . WaitGroup wgBar sync . WaitGroup } func ( p * Parent ) foo () { defer p . wgFoo . Done () } func ( p * Parent ) bar () { defer p . wgBar . Done () } func ( p * Parent ) Go () { p . wgFoo . Add ( 1 ) go p . foo () p . wgBar . Add ( 1 ) go . bar () } Concurrency is a way of structuring your program to make it easy to understand and scaleable. Parallelism is simply the execution of goroutines in parallel. Channels Channel kullan\u0131c\u0131s\u0131 channeli keyfi kapatamamal\u0131d\u0131r. Daha \u00f6nce kapat\u0131lm\u0131\u015f bir channeli kapatmaya \u00e7al\u0131\u015fmak panic olu\u015fturacakt\u0131r. Channeller consumer ve producer olarak modellenmelidir. GO channellerin y\u00f6nlerini belirlememize olanak tan\u0131r. Bir i\u015fi da\u011f\u0131tmak i\u00e7in channelleri gerekti\u011finde s\u0131ral\u0131 halde i\u015flemek i\u00e7in mutexleri kullanmal\u0131y\u0131z. __ Yorumlama GO dilinde yorum sat\u0131rlar\u0131, yazd\u0131\u011f\u0131m\u0131z kodlar kadar \u00f6nemlidir. godoc arac\u0131 kaynak kodlardaki paketlerin d\u00f6k\u00fcmanlar\u0131 toplay\u0131p i\u015fler. Paketlerin, tiplerin, fonksiyonlar\u0131n ba\u015f\u0131na yaz\u0131lan yorum sat\u0131rlar\u0131, tan\u0131mlamalar\u0131 ile birlikte i\u015flenip o birim i\u015fin d\u00f6k\u00fcman olu\u015fturur. Yazd\u0131\u011f\u0131m\u0131z yorumlar\u0131n stili ve kalitesi godoc arac\u0131n\u0131n olu\u015fturaca\u011f\u0131 d\u00f6k\u00fcman\u0131 da etkiler. E\u011fer paket basitse a\u00e7\u0131klamas\u0131 k\u0131sa olabilir. // Package draw provides image composition functions. // package draw \u00c7ok yayg\u0131n kullan\u0131lacak bir kodu detayl\u0131ca a\u00e7\u0131klamam\u0131z gerekir. // The cap built-in function returns the capacity of v, according to its type: // Array: the number of elements in v (same as len(v)). // Pointer to array: the number of elements in *v (same as len(v)). // Slice: the maximum length the slice can reach when resliced; // if v is nil, cap(v) is zero. // Channel: the channel buffer capacity, in units of elements; // if v is nil, cap(v) is zero. // For some arguments, such as a simple array expression, the result can be a // constant. See the Go language specification s Length and capacity section for // details. func cap ( v Type ) int D\u00f6k\u00fcman Bir projenin anla\u015f\u0131l\u0131r ve s\u00fcrd\u00fcr\u00fclebilir olmas\u0131 i\u00e7in d\u00f6k\u00fcman \u00e7ok \u00f6nemlidir. D\u00f6k\u00fcmanlar\u0131n da t\u0131pk\u0131 iyi dizayn edilmi\u015f kodlar gibi, amac\u0131na uygun yaz\u0131lmas\u0131 gerekir. Ayn\u0131 zamanda d\u00f6k\u00fcmanlar\u0131n kolay yaz\u0131l\u0131p; d\u00fczenlenebilir olmas\u0131 gerekir. GO dilinde d\u00f6k\u00fcmanlar\u0131n kodla bir arada olmas\u0131 ve kodla birlikte geli\u015ftirilmesi uygun g\u00f6r\u00fcl\u00fcr. Bir go paketinde public olan her kod sat\u0131r\u0131 i\u00e7in mutlaka d\u00f6k\u00fcman yaz\u0131lmal\u0131d\u0131r. Paket i\u00e7inde kullan\u0131lan kodlar i\u00e7in de yazmak zaruri olmasa da projenin sa\u011fl\u0131\u011f\u0131 a\u00e7\u0131s\u0131ndan olduk\u00e7a faydal\u0131 olacakt\u0131r. E\u011fer go paketi birden fazla dosyadan olu\u015fuyorsa d\u00f6k\u00fcman doc.go ad\u0131ndaki ayr\u0131 bir dosyada tutulmal\u0131d\u0131r. D\u00f6k\u00fcman sat\u0131rlar\u0131 tam c\u00fcmleler halinde yaz\u0131lmal\u0131d\u0131r. \u0130lk c\u00fcmlenin ilk kelimesi paketin/tipin/fonksiyonun ismiyle ba\u015flamal\u0131d\u0131r. {% hint style=\"danger\" %} D\u00f6k\u00fcmanlar\u0131n i\u00e7eri\u011fi kodun nas\u0131l yaz\u0131ld\u0131\u011f\u0131, neleri kulland\u0131\u011f\u0131 ve nas\u0131l kulland\u0131\u011f\u0131 olmamal\u0131d\u0131r. Ayr\u0131ca kullan\u0131lmayan kodlar yorum sat\u0131r\u0131 olarak b\u0131rak\u0131lmamal\u0131d\u0131r. {% endhint %} // Ping the target server with a GET request func Ping ( url string , ch chan - * Stat , waitGroup * sync . WaitGroup , logger * Log , sem chan bool ) { // ping start time start := time . Now () // make a get request to url resp , err := http . Get ( url ) if err != nil { log . Fatal ( err ) } // close the body regardless defer resp . Body . Close () // ping end time end := time . Now () // create a stat struct to hold the ping information stat := Stat { start , end , url , resp . StatusCode , GET , resp . ContentLength } logger . AddStat ( * stat ) // extra := Stat{} // send stat to channel ch - stat // close semaphore sem - true // wait for semaphore to be closed defer func () { - sem }() // notify waitgroup waitGroup . Done () } {% hint style=\"success\" %} D\u00f6k\u00fcmanlar\u0131n i\u00e7eri\u011fi kodun neden yaz\u0131ld\u0131\u011f\u0131, i\u00e7eri\u011fi ve nas\u0131l kullan\u0131ld\u0131\u011f\u0131 olmal\u0131d\u0131r. {% endhint %} {% tabs %} {% tab title=\"ring_full\" %} // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Package ring implements operations on circular lists. package ring // A Ring is an element of a circular list, or ring. // Rings do not have a beginning or end; a pointer to any ring element // serves as reference to the entire ring. Empty rings are represented // as nil Ring pointers. The zero value for a Ring is a one-element // ring with a nil Value. // type Ring struct { next , prev * Ring Value interface {} // for use by client; untouched by this library } func ( r * Ring ) init () * Ring { r . next = r r . prev = r return r } // Next returns the next ring element. r must not be empty. func ( r * Ring ) Next () * Ring { if r . next == nil { return r . init () } return r . next } {% endtab %} {% tab title=\"ring_license\" %} // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. {% endtab %} {% tab title=\"ring_package_desc\" %} // Package ring implements operations on circular lists. package ring {% endtab %} {% tab title=\"ring_type_desc\" %} // A Ring is an element of a circular list, or ring. // Rings do not have a beginning or end; a pointer to any ring element // serves as reference to the entire ring. Empty rings are represented // as nil Ring pointers. The zero value for a Ring is a one-element // ring with a nil Value. // type Ring struct { next , prev * Ring Value interface {} // for use by client; untouched by this library } {% endtab %} {% tab title=\"ring_method_desc\" %} // Next returns the next ring element. r must not be empty. func ( r * Ring ) Next () * Ring { if r . next == nil { return r . init () } return r . next } {% endtab %} {% endtabs %} {% embed url=\"https://github.com/golang/go/blob/master/src/container/ring/ring.go\" %} \u0130simlendirme Paket Paketlerin isimleri belirlenirken paketin i\u00e7eri\u011fini an\u0131msatan isimler belirlenmelidir. Paket isimleri k\u0131sa, net, a\u00e7\u0131klay\u0131c\u0131, k\u00fc\u00e7\u00fck karakterlerle yaz\u0131lm\u0131\u015f tek bir kelime olmal\u0131d\u0131r. snake_case veya camelCase isimlere ihtiya\u00e7 yoktur. Paketlerin i\u00e7eri\u011finindeki isim \u00e7ak\u0131\u015fmalar\u0131 hakk\u0131nda endi\u015fe edilmemelidir. Paket isimleri, sadece paketler i\u00e7in belirlenen \u00f6n tan\u0131ml\u0131 isimdir ve proje genelinde tekil olmas\u0131na gerek yoktur. \u00c7ak\u0131\u015fma durumunda paketler farkl\u0131 bir isimle import edilebilirler. Kod Organizasyonu GO projelerinde network, veritaban\u0131 gibi i\u015fler i\u00e7in olu\u015fturulan paketler di\u011fer paketler taraf\u0131ndan kullan\u0131labilir fakat terminal komutu, http server ba\u015flatma gibi i\u015fleri y\u00f6neten paketler kendi ba\u015f\u0131na \u00e7al\u0131\u015f\u0131r. Proje yap\u0131s\u0131nda bu \u00f6ncelikle bu iki t\u00fcr\u00fc ay\u0131rmak faydal\u0131 olacakt\u0131r. Birbiriyle alakas\u0131z paketlerin birbirinden ba\u011f\u0131ms\u0131z olmas\u0131 gerekir. github.com/peterbourgon/foo/ circle.yml Dockerfile cmd/ foosrv/ main.go foocli/ main.go pkg/ fs/ fs.go fs_test.go mock.go mock_test.go merge/ merge.go merge_test.go api/ api.go api_test.go https://github.com/perkeep/perkeep Interface Tek metod i\u00e7eren interface isimleri genellikle method ismine -er eklenerek tan\u0131mlan\u0131r. \u00d6rne\u011fin Logger, Formatter. // Scanner is implemented by any value that has a Scan method, which scans // the input for the representation of a value and stores the result in the // receiver, which must be a pointer to be useful. The Scan method is called // for any argument to Scan, Scanf, or Scanln that implements it. type Scanner interface { Scan ( state ScanState , verb rune ) error } // Scanln is similar to Scan, but stops scanning at a newline and // after the final item there must be a newline or EOF. func Scanln ( a ... interface {}) ( n int , err error ) { return Fscanln ( os . Stdin , a ... ) } Fonksiyon Read , Write , Close , Flush , String vb. fonksiyonlar\u0131n \u00e7ok belirgin ve dil i\u00e7inde yayg\u0131n kullan\u0131mlar\u0131 vard\u0131r. Karma\u015f\u0131kl\u0131\u011f\u0131 \u00f6nlemek ad\u0131na kendi fonksiyonlar\u0131m\u0131za bu isimleri, ayn\u0131 i\u015fi, ayn\u0131 anlamda yapm\u0131yorsa, kullanmamam\u0131z gerekir. Eri\u015fim GO paketindeki yaln\u0131zca ba\u015f harfi b\u00fcy\u00fck yaz\u0131lm\u0131\u015f tiplere/de\u011fi\u015fkenlere/fonksiyonlara eri\u015filebilir. Bu y\u00f6ntem sayesinde paket i\u00e7in API belirleyebiliriz. GO paket i\u00e7indeki veri tipleri i\u00e7in do\u011frudan getter ve setter tan\u0131mlamaz fakat paket i\u00e7indeki bir veriye eri\u015fim i\u00e7in kendimiz getter/setter tan\u0131mlayabiliriz. Getter/setterler metodlar\u0131n isimlerinin Get veya Set ile ba\u015flamas\u0131na gerek yoktur. \u00d6rne\u011fin List ad\u0131ndaki bir tipin len alan\u0131na GetLen() veya GetLength() \u015fekinde de\u011fil Len() \u015feklinde eri\u015filmesi uygundur. // List represents a doubly linked list. // The zero value for List is an empty list ready to use. type List struct { root Element // sentinel list element, only root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element } // Len returns the number of elements of list l. // The complexity is O(1). func ( l * List ) Len () int { return l . len } Error Handling GOda hata kontrolleri de normal yaz\u0131l\u0131m ak\u0131\u015f\u0131n\u0131n bir par\u00e7as\u0131d\u0131r. Bu y\u00fczden t\u00fcm hatalar d\u00fczg\u00fcnce kontrol edilmelidir. Hatalar _ de\u011fi\u015fkenine atan\u0131p g\u00f6rmezden gelinmemelidir. E\u011fer bir fonksiyon hata d\u00f6n\u00fcyorsa bu hata kontrol edilmeli ve fonksiyonun ba\u015far\u0131l\u0131 \u015fekilde \u00e7al\u0131\u015ft\u0131\u011f\u0131na emin olunmal\u0131d\u0131r. \u00c7ok nadir durumlar haricinde panic hata kontrol\u00fc i\u00e7in kullan\u0131lmamal\u0131d\u0131r. E\u011fer yazd\u0131\u011f\u0131m\u0131z fonksiyon i\u00e7inde bir hata olu\u015fabilecekse, bu hata d\u00f6n\u00fc\u015f de\u011feri olarak tan\u0131mlanmal\u0131d\u0131r. Indent Errors Normal kodlar minimum indentation ile yaz\u0131lmal\u0131d\u0131r. Normal \u00e7al\u0131\u015fma ak\u0131\u015f\u0131n\u0131n d\u0131\u015f\u0131ndaki durumlar(hatalar) kodun ba\u015f\u0131nda if ile kontrol edilip; fonksiyondan erkenden d\u00f6n\u00fclmelidir. Bu, yaz\u0131l\u0131mc\u0131n\u0131n fonksiyonun ak\u0131\u015f\u0131n\u0131 kavramas\u0131n\u0131 \u00f6nemli \u00f6l\u00e7\u00fcde art\u0131racakt\u0131r. if err != nil { // error handling } else { // normal code } if err != nil { // error handling return // or continue, etc. } // normal code D\u00f6n\u00fc\u015f de\u011feri kullan\u0131lacaksa bu if d\u0131\u015f\u0131nda yap\u0131lmal\u0131d\u0131r. if x , err := f (); err != nil { // error handling return } else { // use x } x , err := f () if err != nil { // error handling return } // use x Testing Test yazmak, geli\u015ftirme s\u00fcrecinin bir par\u00e7as\u0131 olmal\u0131d\u0131r. Testlerde piskolojik olarak minimum %80 total coverage ve tercihen %100 happy-path coverage hedeflenmelidir. D\u00fczg\u00fcn testi yaz\u0131lmam\u0131\u015f her kod silinip yeniden testleri ile birlikte yaz\u0131labilir. Monkey-patchingden m\u00fcmk\u00fcn oldu\u011funca ka\u00e7\u0131n\u0131lmal\u0131; 3. parti ba\u011f\u0131ml\u0131l\u0131klar\u0131 mocklamak i\u00e7in \u00f6nce temel y\u00f6ntemlere ba\u015fvurulmal\u0131d\u0131r.","title":"Best Practices"},{"location":"tr/best-practices/#best-practices","text":"A language that doesn\u2019t affect the way you think about programming is not worth knowing.\u200a\u2014\u200aAlan Perlis","title":"Best Practices"},{"location":"tr/best-practices/#genel-prensipler","text":"Keep it simple Don\u2019t Repeat Yourself You ain't gonna need it","title":"Genel Prensipler"},{"location":"tr/best-practices/#avoid-nesting","text":"\u0130yi GO kodu dilin kendi kodlar\u0131 gibidir. Standart olarak bu yaz\u0131m tercih edilmelidir. // Reset clears the state of the Writer z such that it is equivalent to its // initial state from NewWriterLevel or NewWriterLevelDict, but instead writing // to w. func ( z * Writer ) Reset ( w io . Writer ) { z . w = w // z.level and z.dict left unchanged. if z . compressor != nil { z . compressor . Reset ( w ) } if z . digest != nil { z . digest . Reset () } z . err = nil z . scratch = [ 4 ] byte {} z . wroteHeader = false } https://go-proverbs.github.io/","title":"Avoid Nesting"},{"location":"tr/best-practices/#kodlama","text":"","title":"Kodlama"},{"location":"tr/best-practices/#composition","text":"","title":"Composition"},{"location":"tr/best-practices/#fragile-base-class-problemi","text":"Fragile base class problemi nesne y\u00f6nelimli programlama sistemlerindeki temel bir mimari problemidir. Bu mimarilerde ana s\u0131n\u0131flar k\u0131r\u0131lgan kabul edilir. Bunun sebebi \u00fcst s\u0131n\u0131ftaki bir de\u011fi\u015fikli\u011fin alt s\u0131n\u0131flara da yans\u0131mas\u0131 ve alt s\u0131n\u0131flarda i\u015flev bozuklu\u011funa sebep olabilmesidir. Yaz\u0131l\u0131mc\u0131 bu t\u00fcr mimarilerde ana s\u0131n\u0131f\u0131n metodlar\u0131n\u0131 izole edemez ve bu nedenle ana s\u0131n\u0131fta yap\u0131lan de\u011fi\u015fikliklerin g\u00fcvenli olup olmad\u0131\u011f\u0131n\u0131ndan emin olamaz. Bu t\u00fcr dillerde kal\u0131t\u0131m yerine kompozisyon tercih edilmelidir. Kompleks ve hiyerar\u015fik yap\u0131lar kodun esnekli\u011fini kaybettirir. https://en.wikipedia.org/wiki/Composition_over_inheritance Kompozisyon y\u00f6nteminde ise bir s\u0131n\u0131f\u0131n di\u011ferinin t\u00fcm \u00f6zelliklerini miras almak yerine parametre olarak belli \u00f6zellikleri se\u00e7ilebilir. GO dilininin yaz\u0131l\u0131mc\u0131lar\u0131 kompozisyona itmesi en g\u00fc\u00e7l\u00fc \u00f6zelliklerinden birisidir.","title":"Fragile Base Class Problemi"},{"location":"tr/best-practices/#loose-coupling","text":"Yaz\u0131l\u0131m d\u00fcnyas\u0131nda, coupling iki birimin birbirine ne kadar ba\u011f\u0131ml\u0131 oldu\u011funun \u00f6l\u00e7\u00fcs\u00fcd\u00fcr. Par\u00e7alar\u0131n\u0131n birbirine s\u0131k\u0131 s\u0131k\u0131ya ba\u011fl\u0131 oldu\u011fu programlarda de\u011fi\u015fiklik yapmak \u00e7ok zordur. Bu duruma shotgun surgery efekti de denir. Shotgun surgery terimi, projenin bir k\u0131sm\u0131nda yap\u0131lan de\u011fi\u015fikli\u011fin di\u011fer k\u0131s\u0131mlar\u0131nda s\u0131ral\u0131 halde ufak de\u011fi\u015fikliklere yol a\u00e7mas\u0131d\u0131r. \u00d6rnek vermek gerekirse: type Booking struct { ID int Status string } type DB struct {} func ( d DB ) Booking ( ID int ) * Booking {} type Client struct {} func Cancel ( ID int ) error { db := DB {} if booking := db . Booking ( ID ); booking . Status == active { return errors . New ( booking does not exists ) } return nil } func Get ( ID int ) error { db := DB {} if booking := db . Booking ( ID ); booking . Status == active { return errors . New ( booking does not exists ) } return nil } Yukar\u0131daki kodda Bookinge ait methodlarda tek bir kontrol var. O da bookingin aktif olmas\u0131. Her metoda bu kontrol\u00fc ekleyerek code smell olu\u015fturduk. \u015eimdi \"active\" kontrol\u00fc de\u011fi\u015firse Bookinge ait t\u00fcm metodlarda de\u011fi\u015fiklik yapmak gerekecek. Bu s\u0131k\u0131nt\u0131y\u0131 gidermek i\u00e7in ilk ad\u0131m, kontrol k\u0131sm\u0131n\u0131 ayr\u0131 bir fonksiyonda tan\u0131mlayabiliriz. func validateBooking ( db * DB , ID int ) bool { if booking := db . Booking ( ID ); booking . Status == active { return true } return false } func Cancel ( ID int ) error { db := DB {} if isActive := validateBooking ( db , ID ); isActive { return errors . New ( booking does not exists ) } return nil } func Get ( ID int ) error { db := DB {} if isActive := validateBooking ( db , ID ); isActive { return errors . New ( booking does not exists ) } return nil } Do\u011frulamada bir de\u011fi\u015fiklik oldu\u011funda art\u0131k sadece validateBooking fonksiyonun de\u011fi\u015ftirilmesi yeterli.","title":"Loose Coupling"},{"location":"tr/best-practices/#single-responsibility","text":"Yukar\u0131daki kod par\u00e7as\u0131nda hala d\u00fczeltilmesi gereken k\u0131s\u0131mlar var. validateBooking fonksiyonu DB tipini do\u011frudan kullan\u0131yor. Bu hem tight coupling olu\u015fmas\u0131na hem de i\u015fi sadece bookinglerin durumunu kontrol etmek olan fonksiyonun veritaban\u0131na da eri\u015ferek birden fazla i\u015f yapmas\u0131na sebep oluyor. // booking.go type Booking struct { ID int Status string } func ( b Booking ) Validate () bool { if b . Status == active { return true } return false } // db.go type DB struct {} func ( d DB ) Get ( ID int ) * Booking { return nil } // client.go type Client struct {} func Cancel ( ID int ) error { db := DB {} booking := db . Get ( ID ) if booking . Validate () { return errors . New ( booking does not exists ) } return nil } func Get ( ID int ) error { db := DB {} booking := db . Get ( ID ) if booking . Validate () { return errors . New ( booking does not exists ) } return nil }","title":"Single Responsibility"},{"location":"tr/best-practices/#liskov-substitution","text":"Nesne y\u00f6nelimli dillerde liskov substitution prensibi; miras alan s\u0131n\u0131f\u0131n, \u00fcst s\u0131n\u0131f ile yer de\u011fi\u015ftirdi\u011fi zaman, ayn\u0131 davran\u0131\u015f\u0131 sergilemesi gerekti\u011fini s\u00f6yler. GOda bu tarz soyut hiyerar\u015filer tan\u0131mlanamaz fakat substitution GO interfacelerinin \u00e7al\u0131\u015fma mant\u0131\u011f\u0131na \u00e7ok benzer.","title":"Liskov Substitution"},{"location":"tr/best-practices/#interface","text":"Nesne y\u00f6nelimli programlamada \u00f6\u011frenilen y\u00f6ntemler GOya ta\u015f\u0131nmamal\u0131d\u0131r. Di\u011fer dillerden gelen yaz\u0131l\u0131mc\u0131lar interfaceleri genellikle a\u015fa\u011f\u0131daki \u015fekilde tan\u0131mlar. package rockband type Player interface { Play () } type BandMemeber struct {} func ( b BandMemeber ) Play (){ } package stage func Perform ( p Player ) { p . Play () } Bu tarz kullan\u0131mda Interface tan\u0131mlan\u0131r Interfacei kullanmak i\u00e7in tip tan\u0131mlan\u0131r Tan\u0131mlanan tiplerin interfacei implement eden metodlar\u0131 yaz\u0131l\u0131r Bu GO dilinde net bir \u015fekilde yanl\u0131\u015ft\u0131r \u00e7\u00fcnk\u00fc; interfacei uygulayacak ba\u015fka tipler olu\u015fmadan yani net bir nedenimiz olmadan tan\u0131mlad\u0131k. Daha ideali, \u00f6nce tipleri tan\u0131mlamak ve kullanmak. \u0130htiya\u00e7 duyulan yerde interfacelere ba\u015fvurmak olacakt\u0131r. package rockband type BandMemeber struct {} func ( b BandMemeber ) Play (){ } package stage type Player interface { Play () } func Perform ( p Player ) { p . Play () } Be conservative in what you send, be liberal in what you accept. Jon Postel Postel yasas\u0131n\u0131 GOya uyarlamak gerekirse. Fonksiyonlar parametre olarak interface almal\u0131, struct(belirli bir veri tipi) d\u00f6nmelidir. A great rule of thumb for Go is accept interfaces, return structs. Jack Lindamood Bununla birlikte fonksiyonlar\u0131n parametrelerinin de tamamen soyut olmamas\u0131nda fayda vard\u0131r. the empty interface says nothing Rob Pike Postel yasas\u0131n\u0131n \u00f6nemini test yazarken a\u00e7\u0131k \u015fekilde g\u00f6rebiliriz. Yukar\u0131daki fonksiyondaki Perform parametresinin belirli bir tip yerine interface olmas\u0131, bizi test yazarken ger\u00e7ek bir player objesi olu\u015fturmaktan kurtar\u0131r","title":"Interface"},{"location":"tr/best-practices/#open-closed","text":"Software entities should be open for extension, but closed for modification. Bertrand Meyer package main import fmt type Cat struct { Name string } func ( c Cat ) Legs () int { return 4 } func ( c Cat ) PrintLegs () { fmt . Printf ( I have %d legs\\n , c . Legs ()) } type OctoCat struct { Cat } func ( o OctoCat ) Legs () int { return 5 } func main () { var octo OctoCat fmt . Println ( octo . Legs ()) // 5 octo . PrintLegs () // I have 4 legs } // source: https://dave.cheney.net/2016/08/20/solid-go-design Yukar\u0131daki \u00f6rnekte Cat tipi ve bu tipe ait ayak say\u0131s\u0131n\u0131 g\u00f6steren Legs metodu var. OctoCat tipine bu tipi g\u00f6md\u00fck ve Legs fonksiyonunu tan\u0131mlad\u0131k. Bu durumda OctoCat Legs metodundan 5 say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcyor ama PrintLegs metodu yine Legs metodunu kullanmas\u0131na ra\u011fmen 4 d\u00f6nd\u00fcr\u00fcyor. Bunun sebebi PrintLegs metodunun Cat tipi i\u00e7in tan\u0131mlanm\u0131\u015f olmas\u0131 ve receiver olarak Cati almas\u0131.","title":"Open-Closed  "},{"location":"tr/best-practices/#interface-segregation","text":"Clients should not be forced to depend on methods they do not use. Robert C. Martin Interface segregation, pek \u00e7ok davran\u0131\u015f i\u00e7eren b\u00fcy\u00fck veri yap\u0131lar\u0131 olu\u015fturmamam\u0131z\u0131 ve veri tipinin davran\u0131\u015f\u0131n\u0131 izole etmemizi s\u00f6yler. GO dilinde kompozisyon ve k\u00fc\u00e7\u00fck interface kullan\u0131mlar\u0131 benimsenir.","title":"Interface Segregation"},{"location":"tr/best-practices/#dependency-inversion","text":"High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. Robert C. Martin Bu prensibin GOda uygulamas\u0131n\u0131 paket seviyesinde g\u00f6rebiliriz. __ \u00d6nceki prensipler uyguland\u0131\u011f\u0131nda elimizde ama\u00e7lar\u0131 d\u00fczg\u00fcnce tan\u0131mlanm\u0131\u015f kod paketleri olacakt\u0131r. B\u00f6yle bir yap\u0131da kod i\u00e7indeki ba\u011f\u0131ml\u0131l\u0131klar\u0131n interfaceler ile tan\u0131mlanm\u0131\u015f olmas\u0131 ve bu interfacelerin sadece tan\u0131mlad\u0131klar\u0131 fonksiyonlarla alakal\u0131 olmas\u0131 gerekir. GOda importlar acyclic olmal\u0131d\u0131r. Yani A paketi B paketini import ediyorsa, B paketi A'y\u0131 import etmemelidir. __Bu ba\u011flamda Go projelerinin geni\u015f ve d\u00fcz \u015fekilde tasarlanmal\u0131d\u0131r. \u0130\u00e7 i\u00e7e paketler tan\u0131mlamaktan ka\u00e7\u0131n\u0131lmal\u0131d\u0131r. E\u011fer bir paketteki fonksiyon ba\u015fka bir paket olmadan d\u00fczg\u00fcn \u00e7al\u0131\u015fam\u0131yorsa; bu, projenin paket seviyesinde iyi \u015fekilde d\u00fczenlenmedi\u011fini g\u00f6sterir. Dependency inversion prensibi, projedeki as\u0131l i\u015flerin \u00fcst paketlerde, soyutlama/interface i\u015flerinin alt paketlere yapmaya te\u015fvik eder.","title":"Dependency Inversion"},{"location":"tr/best-practices/#closure","text":"GO'nun sa\u011flad\u0131\u011f\u0131 interfaceler ve closurelar sayesinde \u00e7ok estetik ve kullan\u0131\u015fl\u0131 APIler yazabiliriz. Closure kendi g\u00f6vdesi d\u0131\u015f\u0131ndaki de\u011fi\u015fkenlere eri\u015fen fonksiyonlard\u0131r. Closure bir de\u011fi\u015fkene atan\u0131p istenildi\u011fi zaman \u00e7a\u011fr\u0131labilir veya ba\u015fka bir fonksiyona parametre olarak verilebilir. HTTP server olu\u015ftururken bu teknik s\u0131kl\u0131kla kullan\u0131l\u0131r. A\u015fa\u011f\u0131daki \u00f6rnekte home fonksiyonunu timed ile sarmalay\u0131p http.HandleFunc metoduna parametre olarak verdik. Bu da home/ end-pointine her istek geldi\u011finde, bu iste\u011fin i\u015flenme s\u00fcresini hesaplamam\u0131z\u0131 sa\u011flad\u0131. func main () { http . HandleFunc ( /hello , timed ( home )) http . ListenAndServe ( :3000 , nil ) } func timed ( f func ( http . ResponseWriter , * http . Request )) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { start := time . Now () f ( w , r ) end := time . Now () fmt . Println ( The request took , end . Sub ( start )) } } func home ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintln ( w , Home ) } GO kaynak kodlar\u0131nda da Closurelara bolca yer verilmi\u015ftir. {% embed url=\"https://github.com/golang/go/blob/4e215554aa0e76e534327b9e6721971b9e82c113/src/sort/sort.go#L307\" %}","title":"Closure"},{"location":"tr/best-practices/#concurrency","text":"Goroutineler her ne kadar boyutlar\u0131 k\u00fc\u00e7\u00fck ve \u00e7ok kullan\u0131\u015fl\u0131 yap\u0131lar olsa da ba\u011f\u0131ms\u0131z olmalar\u0131 kontrol edilmesi g\u00fc\u00e7 hatalara ve kod i\u00e7inde veri ak\u0131\u015f\u0131n\u0131n karma\u015f\u0131kla\u015fmas\u0131na yol a\u00e7makta. Bu y\u00fczden goroutinelerin \u00e7al\u0131\u015fma rutini API i\u00e7erisinde ve m\u00fcmk\u00fcn oldu\u011funca dar bir alanda tutulmal\u0131d\u0131r. Projede goroutine kullan\u0131lmaya karar verildi\u011finde race-conditionlar\u0131n \u00f6n\u00fcne ge\u00e7mek i\u00e7in \u00f6ncelikle kod senkron olarak tan\u0131mlanmal\u0131d\u0131r. Sonras\u0131nda, veri tipleri e\u015fzamanl\u0131 eri\u015fmeye kar\u015f\u0131 korunmal\u0131d\u0131r. Son olarak da korunan tipler goroutineler ile kullan\u0131lmal\u0131d\u0131r. make(chan struct{}) , sync.WaitGroup , context.Context and select yap\u0131lar\u0131 goroutineler s\u00f6z konusu oldu\u011funda s\u0131k\u00e7a kullan\u0131lmal\u0131 ve goroutinelerin \u00e7al\u0131\u015fma s\u00fcreci kontrol edilmelidir. \u0130deal \u00e7al\u0131\u015fma s\u00fcrecinde, goroutineler istenildi\u011fi zaman durdurulabilmeli. Ayr\u0131ca t\u00fcm sonu\u00e7lar gelene kadar goroutinelerin beklenmelidir. Ayn\u0131 WaitGroup ile farkl\u0131 tipte goroutineleri say\u0131lmamal\u0131d\u0131r. type Parent struct { wgFoo sync . WaitGroup wgBar sync . WaitGroup } func ( p * Parent ) foo () { defer p . wgFoo . Done () } func ( p * Parent ) bar () { defer p . wgBar . Done () } func ( p * Parent ) Go () { p . wgFoo . Add ( 1 ) go p . foo () p . wgBar . Add ( 1 ) go . bar () } Concurrency is a way of structuring your program to make it easy to understand and scaleable. Parallelism is simply the execution of goroutines in parallel.","title":"Concurrency"},{"location":"tr/best-practices/#channels","text":"Channel kullan\u0131c\u0131s\u0131 channeli keyfi kapatamamal\u0131d\u0131r. Daha \u00f6nce kapat\u0131lm\u0131\u015f bir channeli kapatmaya \u00e7al\u0131\u015fmak panic olu\u015fturacakt\u0131r. Channeller consumer ve producer olarak modellenmelidir. GO channellerin y\u00f6nlerini belirlememize olanak tan\u0131r. Bir i\u015fi da\u011f\u0131tmak i\u00e7in channelleri gerekti\u011finde s\u0131ral\u0131 halde i\u015flemek i\u00e7in mutexleri kullanmal\u0131y\u0131z. __","title":"Channels"},{"location":"tr/best-practices/#yorumlama","text":"GO dilinde yorum sat\u0131rlar\u0131, yazd\u0131\u011f\u0131m\u0131z kodlar kadar \u00f6nemlidir. godoc arac\u0131 kaynak kodlardaki paketlerin d\u00f6k\u00fcmanlar\u0131 toplay\u0131p i\u015fler. Paketlerin, tiplerin, fonksiyonlar\u0131n ba\u015f\u0131na yaz\u0131lan yorum sat\u0131rlar\u0131, tan\u0131mlamalar\u0131 ile birlikte i\u015flenip o birim i\u015fin d\u00f6k\u00fcman olu\u015fturur. Yazd\u0131\u011f\u0131m\u0131z yorumlar\u0131n stili ve kalitesi godoc arac\u0131n\u0131n olu\u015fturaca\u011f\u0131 d\u00f6k\u00fcman\u0131 da etkiler. E\u011fer paket basitse a\u00e7\u0131klamas\u0131 k\u0131sa olabilir. // Package draw provides image composition functions. // package draw \u00c7ok yayg\u0131n kullan\u0131lacak bir kodu detayl\u0131ca a\u00e7\u0131klamam\u0131z gerekir. // The cap built-in function returns the capacity of v, according to its type: // Array: the number of elements in v (same as len(v)). // Pointer to array: the number of elements in *v (same as len(v)). // Slice: the maximum length the slice can reach when resliced; // if v is nil, cap(v) is zero. // Channel: the channel buffer capacity, in units of elements; // if v is nil, cap(v) is zero. // For some arguments, such as a simple array expression, the result can be a // constant. See the Go language specification s Length and capacity section for // details. func cap ( v Type ) int","title":"Yorumlama"},{"location":"tr/best-practices/#dokuman","text":"Bir projenin anla\u015f\u0131l\u0131r ve s\u00fcrd\u00fcr\u00fclebilir olmas\u0131 i\u00e7in d\u00f6k\u00fcman \u00e7ok \u00f6nemlidir. D\u00f6k\u00fcmanlar\u0131n da t\u0131pk\u0131 iyi dizayn edilmi\u015f kodlar gibi, amac\u0131na uygun yaz\u0131lmas\u0131 gerekir. Ayn\u0131 zamanda d\u00f6k\u00fcmanlar\u0131n kolay yaz\u0131l\u0131p; d\u00fczenlenebilir olmas\u0131 gerekir. GO dilinde d\u00f6k\u00fcmanlar\u0131n kodla bir arada olmas\u0131 ve kodla birlikte geli\u015ftirilmesi uygun g\u00f6r\u00fcl\u00fcr. Bir go paketinde public olan her kod sat\u0131r\u0131 i\u00e7in mutlaka d\u00f6k\u00fcman yaz\u0131lmal\u0131d\u0131r. Paket i\u00e7inde kullan\u0131lan kodlar i\u00e7in de yazmak zaruri olmasa da projenin sa\u011fl\u0131\u011f\u0131 a\u00e7\u0131s\u0131ndan olduk\u00e7a faydal\u0131 olacakt\u0131r. E\u011fer go paketi birden fazla dosyadan olu\u015fuyorsa d\u00f6k\u00fcman doc.go ad\u0131ndaki ayr\u0131 bir dosyada tutulmal\u0131d\u0131r. D\u00f6k\u00fcman sat\u0131rlar\u0131 tam c\u00fcmleler halinde yaz\u0131lmal\u0131d\u0131r. \u0130lk c\u00fcmlenin ilk kelimesi paketin/tipin/fonksiyonun ismiyle ba\u015flamal\u0131d\u0131r. {% hint style=\"danger\" %} D\u00f6k\u00fcmanlar\u0131n i\u00e7eri\u011fi kodun nas\u0131l yaz\u0131ld\u0131\u011f\u0131, neleri kulland\u0131\u011f\u0131 ve nas\u0131l kulland\u0131\u011f\u0131 olmamal\u0131d\u0131r. Ayr\u0131ca kullan\u0131lmayan kodlar yorum sat\u0131r\u0131 olarak b\u0131rak\u0131lmamal\u0131d\u0131r. {% endhint %} // Ping the target server with a GET request func Ping ( url string , ch chan - * Stat , waitGroup * sync . WaitGroup , logger * Log , sem chan bool ) { // ping start time start := time . Now () // make a get request to url resp , err := http . Get ( url ) if err != nil { log . Fatal ( err ) } // close the body regardless defer resp . Body . Close () // ping end time end := time . Now () // create a stat struct to hold the ping information stat := Stat { start , end , url , resp . StatusCode , GET , resp . ContentLength } logger . AddStat ( * stat ) // extra := Stat{} // send stat to channel ch - stat // close semaphore sem - true // wait for semaphore to be closed defer func () { - sem }() // notify waitgroup waitGroup . Done () } {% hint style=\"success\" %} D\u00f6k\u00fcmanlar\u0131n i\u00e7eri\u011fi kodun neden yaz\u0131ld\u0131\u011f\u0131, i\u00e7eri\u011fi ve nas\u0131l kullan\u0131ld\u0131\u011f\u0131 olmal\u0131d\u0131r. {% endhint %} {% tabs %} {% tab title=\"ring_full\" %} // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Package ring implements operations on circular lists. package ring // A Ring is an element of a circular list, or ring. // Rings do not have a beginning or end; a pointer to any ring element // serves as reference to the entire ring. Empty rings are represented // as nil Ring pointers. The zero value for a Ring is a one-element // ring with a nil Value. // type Ring struct { next , prev * Ring Value interface {} // for use by client; untouched by this library } func ( r * Ring ) init () * Ring { r . next = r r . prev = r return r } // Next returns the next ring element. r must not be empty. func ( r * Ring ) Next () * Ring { if r . next == nil { return r . init () } return r . next } {% endtab %} {% tab title=\"ring_license\" %} // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. {% endtab %} {% tab title=\"ring_package_desc\" %} // Package ring implements operations on circular lists. package ring {% endtab %} {% tab title=\"ring_type_desc\" %} // A Ring is an element of a circular list, or ring. // Rings do not have a beginning or end; a pointer to any ring element // serves as reference to the entire ring. Empty rings are represented // as nil Ring pointers. The zero value for a Ring is a one-element // ring with a nil Value. // type Ring struct { next , prev * Ring Value interface {} // for use by client; untouched by this library } {% endtab %} {% tab title=\"ring_method_desc\" %} // Next returns the next ring element. r must not be empty. func ( r * Ring ) Next () * Ring { if r . next == nil { return r . init () } return r . next } {% endtab %} {% endtabs %} {% embed url=\"https://github.com/golang/go/blob/master/src/container/ring/ring.go\" %}","title":"D\u00f6k\u00fcman"},{"location":"tr/best-practices/#isimlendirme","text":"","title":"\u0130simlendirme"},{"location":"tr/best-practices/#paket","text":"Paketlerin isimleri belirlenirken paketin i\u00e7eri\u011fini an\u0131msatan isimler belirlenmelidir. Paket isimleri k\u0131sa, net, a\u00e7\u0131klay\u0131c\u0131, k\u00fc\u00e7\u00fck karakterlerle yaz\u0131lm\u0131\u015f tek bir kelime olmal\u0131d\u0131r. snake_case veya camelCase isimlere ihtiya\u00e7 yoktur. Paketlerin i\u00e7eri\u011finindeki isim \u00e7ak\u0131\u015fmalar\u0131 hakk\u0131nda endi\u015fe edilmemelidir. Paket isimleri, sadece paketler i\u00e7in belirlenen \u00f6n tan\u0131ml\u0131 isimdir ve proje genelinde tekil olmas\u0131na gerek yoktur. \u00c7ak\u0131\u015fma durumunda paketler farkl\u0131 bir isimle import edilebilirler.","title":"Paket"},{"location":"tr/best-practices/#kod-organizasyonu","text":"GO projelerinde network, veritaban\u0131 gibi i\u015fler i\u00e7in olu\u015fturulan paketler di\u011fer paketler taraf\u0131ndan kullan\u0131labilir fakat terminal komutu, http server ba\u015flatma gibi i\u015fleri y\u00f6neten paketler kendi ba\u015f\u0131na \u00e7al\u0131\u015f\u0131r. Proje yap\u0131s\u0131nda bu \u00f6ncelikle bu iki t\u00fcr\u00fc ay\u0131rmak faydal\u0131 olacakt\u0131r. Birbiriyle alakas\u0131z paketlerin birbirinden ba\u011f\u0131ms\u0131z olmas\u0131 gerekir. github.com/peterbourgon/foo/ circle.yml Dockerfile cmd/ foosrv/ main.go foocli/ main.go pkg/ fs/ fs.go fs_test.go mock.go mock_test.go merge/ merge.go merge_test.go api/ api.go api_test.go https://github.com/perkeep/perkeep","title":"Kod Organizasyonu"},{"location":"tr/best-practices/#interface_1","text":"Tek metod i\u00e7eren interface isimleri genellikle method ismine -er eklenerek tan\u0131mlan\u0131r. \u00d6rne\u011fin Logger, Formatter. // Scanner is implemented by any value that has a Scan method, which scans // the input for the representation of a value and stores the result in the // receiver, which must be a pointer to be useful. The Scan method is called // for any argument to Scan, Scanf, or Scanln that implements it. type Scanner interface { Scan ( state ScanState , verb rune ) error } // Scanln is similar to Scan, but stops scanning at a newline and // after the final item there must be a newline or EOF. func Scanln ( a ... interface {}) ( n int , err error ) { return Fscanln ( os . Stdin , a ... ) }","title":"Interface"},{"location":"tr/best-practices/#fonksiyon","text":"Read , Write , Close , Flush , String vb. fonksiyonlar\u0131n \u00e7ok belirgin ve dil i\u00e7inde yayg\u0131n kullan\u0131mlar\u0131 vard\u0131r. Karma\u015f\u0131kl\u0131\u011f\u0131 \u00f6nlemek ad\u0131na kendi fonksiyonlar\u0131m\u0131za bu isimleri, ayn\u0131 i\u015fi, ayn\u0131 anlamda yapm\u0131yorsa, kullanmamam\u0131z gerekir.","title":"Fonksiyon"},{"location":"tr/best-practices/#erisim","text":"GO paketindeki yaln\u0131zca ba\u015f harfi b\u00fcy\u00fck yaz\u0131lm\u0131\u015f tiplere/de\u011fi\u015fkenlere/fonksiyonlara eri\u015filebilir. Bu y\u00f6ntem sayesinde paket i\u00e7in API belirleyebiliriz. GO paket i\u00e7indeki veri tipleri i\u00e7in do\u011frudan getter ve setter tan\u0131mlamaz fakat paket i\u00e7indeki bir veriye eri\u015fim i\u00e7in kendimiz getter/setter tan\u0131mlayabiliriz. Getter/setterler metodlar\u0131n isimlerinin Get veya Set ile ba\u015flamas\u0131na gerek yoktur. \u00d6rne\u011fin List ad\u0131ndaki bir tipin len alan\u0131na GetLen() veya GetLength() \u015fekinde de\u011fil Len() \u015feklinde eri\u015filmesi uygundur. // List represents a doubly linked list. // The zero value for List is an empty list ready to use. type List struct { root Element // sentinel list element, only root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element } // Len returns the number of elements of list l. // The complexity is O(1). func ( l * List ) Len () int { return l . len }","title":"Eri\u015fim"},{"location":"tr/best-practices/#error-handling","text":"GOda hata kontrolleri de normal yaz\u0131l\u0131m ak\u0131\u015f\u0131n\u0131n bir par\u00e7as\u0131d\u0131r. Bu y\u00fczden t\u00fcm hatalar d\u00fczg\u00fcnce kontrol edilmelidir. Hatalar _ de\u011fi\u015fkenine atan\u0131p g\u00f6rmezden gelinmemelidir. E\u011fer bir fonksiyon hata d\u00f6n\u00fcyorsa bu hata kontrol edilmeli ve fonksiyonun ba\u015far\u0131l\u0131 \u015fekilde \u00e7al\u0131\u015ft\u0131\u011f\u0131na emin olunmal\u0131d\u0131r. \u00c7ok nadir durumlar haricinde panic hata kontrol\u00fc i\u00e7in kullan\u0131lmamal\u0131d\u0131r. E\u011fer yazd\u0131\u011f\u0131m\u0131z fonksiyon i\u00e7inde bir hata olu\u015fabilecekse, bu hata d\u00f6n\u00fc\u015f de\u011feri olarak tan\u0131mlanmal\u0131d\u0131r.","title":"Error Handling"},{"location":"tr/best-practices/#indent-errors","text":"Normal kodlar minimum indentation ile yaz\u0131lmal\u0131d\u0131r. Normal \u00e7al\u0131\u015fma ak\u0131\u015f\u0131n\u0131n d\u0131\u015f\u0131ndaki durumlar(hatalar) kodun ba\u015f\u0131nda if ile kontrol edilip; fonksiyondan erkenden d\u00f6n\u00fclmelidir. Bu, yaz\u0131l\u0131mc\u0131n\u0131n fonksiyonun ak\u0131\u015f\u0131n\u0131 kavramas\u0131n\u0131 \u00f6nemli \u00f6l\u00e7\u00fcde art\u0131racakt\u0131r. if err != nil { // error handling } else { // normal code } if err != nil { // error handling return // or continue, etc. } // normal code D\u00f6n\u00fc\u015f de\u011feri kullan\u0131lacaksa bu if d\u0131\u015f\u0131nda yap\u0131lmal\u0131d\u0131r. if x , err := f (); err != nil { // error handling return } else { // use x } x , err := f () if err != nil { // error handling return } // use x","title":"Indent Errors"},{"location":"tr/best-practices/#testing","text":"Test yazmak, geli\u015ftirme s\u00fcrecinin bir par\u00e7as\u0131 olmal\u0131d\u0131r. Testlerde piskolojik olarak minimum %80 total coverage ve tercihen %100 happy-path coverage hedeflenmelidir. D\u00fczg\u00fcn testi yaz\u0131lmam\u0131\u015f her kod silinip yeniden testleri ile birlikte yaz\u0131labilir. Monkey-patchingden m\u00fcmk\u00fcn oldu\u011funca ka\u00e7\u0131n\u0131lmal\u0131; 3. parti ba\u011f\u0131ml\u0131l\u0131klar\u0131 mocklamak i\u00e7in \u00f6nce temel y\u00f6ntemlere ba\u015fvurulmal\u0131d\u0131r.","title":"Testing"},{"location":"tr/concurrency/","text":"Concurrency English | T\u00fcrk\u00e7e Bilgisayar biliminde concurrency(e\u015fzamanl\u0131l\u0131k), bir programdaki i\u015f birimlerinin veya algoritmalar\u0131n sonucu etkilemeyecek \u015fekilde s\u0131ras\u0131z bir bi\u00e7imde \u00e7al\u0131\u015ft\u0131r\u0131labilmesidir. \u0130\u015f par\u00e7alar\u0131n\u0131 birbirinden ba\u011f\u0131ms\u0131z \u00e7al\u0131\u015ft\u0131rabilmemiz, s\u00fcre\u00e7leri farkl\u0131 \u00e7ekirdeklerde y\u00fcr\u00fcterek, i\u015flemciyi maksimum verimde kullanmam\u0131z\u0131 sa\u011flar. GO dilinde concurrency goroutineler ile sa\u011flan\u0131r. Goroutines GO routineler boyutlar\u0131 k\u00fc\u00e7\u00fck threadler olarak d\u00fc\u015f\u00fcn\u00fclebilir. Goroutine olu\u015fturmak i\u00e7in sadece fonksiyonu \u00e7al\u0131\u015ft\u0131r\u0131rken ba\u015f\u0131na go yazmam\u0131z yeterli. A\u015fa\u011f\u0131daki uygulamada Work fonksiyonu her \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, \u00e7al\u0131\u015fmas\u0131 bitene kadar uygulamay\u0131 blokluyor. func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { Work ( work work work work work work... ) Work ( zxcasfv ) } Bloklayan k\u0131s\u0131mlar\u0131 goroutine olarak \u00e7al\u0131\u015ft\u0131ral\u0131m. func main () { go Work ( work work work work work work... ) go Work ( zxcasfv ) } Program\u0131 \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda ekrana hi\u00e7bir \u015fey yazd\u0131rmadan sonlanacak. main fonksiyonu, Work fonksiyonu hen\u00fcz ekrana bir \u015feyler yazacak kadar \u00e7al\u0131\u015fmadan, bitiyor ve program kapan\u0131yor. Ufak bir hile ile Work fonksiyonunun \u00e7\u0131kt\u0131s\u0131n\u0131 alabiliriz. package main import ( fmt time ) func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { go Work ( work work work work work work... ) go Work ( zxcasfv ) time . Sleep ( time . Second * 1 ) } waitGroup Uygulaman\u0131n belli anlar\u0131nda baz\u0131 goroutinelerin bitmesini beklememiz gerekebilir. WaitGroup ile ka\u00e7 tane gorouitne \u00e7al\u0131\u015faca\u011f\u0131n\u0131 \u00f6ncesinde girip sonras\u0131nda i\u015flerini bitirmelerini bekleyebiliriz. Goroutinelerin burada tek yapmas\u0131 gereken, i\u015fi bitti\u011finde WaitGroup'un Done methodunu \u00e7al\u0131\u015ft\u0131rmas\u0131. func Work ( msg string , wg * sync . WaitGroup ) { time . Sleep ( time . Second * 2 ) fmt . Println ( msg ) wg . Done () } func main () { nWorkers1 , nWorkers2 := 5 , 4 wg := sync . WaitGroup {} wg . Add ( nWorkers1 ) for i := 0 ; i nWorkers1 ; i ++ { go Work ( work-1 , wg ) } wg . Wait () wg . Add ( nWorkers2 ) for i := 0 ; i nWorkers2 ; i ++ { go Work ( work-2 , wg ) wg . Wait () } Channels Channeller goroutinelerin birbirleri ile haberle\u015fmesini sa\u011flar. Yukar\u0131daki \u00f6rnekte go ile \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131z fonksiyonlardan d\u00f6n\u00fc\u015f de\u011feri alam\u0131yoruz. Channellar ile goroutinin sonucu ana fonksiyona veya ba\u015fka bir goroutine g\u00f6ndermesini sa\u011flayabiliriz. channeller make(chan veritipi, buffer) \u015feklinde olu\u015fturulabilir. func Work ( msg string , ch chan string ) { ch - msg time . Sleep ( time . Second * 2 ) } func main () { ch1 := make ( chan string ) go Work ( work-1 , ch1 ) go Work ( work-2 , ch1 ) for i := 0 ; i 2 ; i ++ { msg := - ch1 fmt . Println ( msg ) } } Mutex Wikipedia Tan\u0131m\u0131 In computer science, mutual exclusion is a property of concurrency control, which is instituted for the purpose of preventing race conditions. It is the requirement that one thread of execution never enters its critical section at the same time that another concurrent thread of execution enters its own critical section, which refers to an interval of time during which a thread of execution accesses a shared resource, such as shared memory. func Click ( counter * int , wg * sync . WaitGroup ) { * counter += 1 wg . Done () } func main () { counter := 0 nUsers := 500 wg := sync . WaitGroup {} wg . Add ( nUsers ) for i := 0 ; i nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter ) } func Click ( counter * int , wg * sync . WaitGroup , mx * sync . Mutex ) { mx . Lock () * counter += 1 mx . Unlock () wg . Done () } func main () { counter := 0 mx := sync . Mutex {} nUsers := 500 wg := sync . WaitGroup {} wg . Add ( nUsers ) for i := 0 ; i nUsers ; i ++ { go Click ( counter , wg , mx ) } wg . Wait () fmt . Println ( counter ) } Select Kanallara veri g\u00f6ndermek veya kanallardan veri beklemek uygulamay\u0131 bloklar. Select ayn\u0131 anda birka\u00e7 tane kanal\u0131 beklememize olanak sa\u011flar. A\u015fa\u011f\u0131daki \u00f6rnekte 2 goroutine chan1 ve chan2 kanallar\u0131na s\u00fcrekli veri g\u00f6nderiyor. \u0130ki kanaldan da gelen t\u00fcm verileri sonsuz bir d\u00f6ng\u00fc i\u00e7indeki select yap\u0131s\u0131 ile alabiliriz. Herhangi bir kanaldan mesaj geldi\u011finde select o kanal\u0131 bekleyen case e girecek ve i\u00e7inde tan\u0131mlanan i\u015flemler bittikten sonra d\u00f6ng\u00fc kanal bekleme i\u015flemini tekrarlayacakt\u0131r. chan1 := make ( chan string ) chan2 := make ( chan string ) go func () { for { time . Sleep ( 2 * time . Second ) chan1 - one } }() go func () { for { time . Sleep ( 1 * time . Second ) chan2 - two } }() for { select { case msg1 := - chan1 : fmt . Println ( msg1 ) case msg2 := - chan2 : fmt . Println ( msg2 ) } } Zaman A\u015f\u0131m\u0131 Yukar\u0131daki gibi bir program 2 channela da veri g\u00f6nderilmezse kilitlenecektir. Bu sonsuz d\u00f6ng\u00fcy\u00fc ba\u015fka bir channel\u0131 bekleyerek k\u0131rabiliriz. Go, bu t\u00fcr bir ama\u00e7 i\u00e7in \u00f6nceden tan\u0131mlanm\u0131\u015f yap\u0131lara sahiptir. Time mod\u00fcl\u00fcndeki time.After metodunu bellirledi\u011fimiz bir s\u00fcreden sonra bir channel\u0131 tetiklemek i\u00e7in kullanabiliriz. chan1 := make ( chan string ) chan2 := make ( chan string ) go func () { for { time . Sleep ( 1 * time . Second ) chan1 - one } }() go func () { for { time . Sleep ( 2 * time . Second ) chan2 - two } }() for { select { case msg1 := - chan1 : fmt . Println ( msg1 ) case msg2 := - chan2 : fmt . Println ( msg2 ) case - time . After ( time . Second * 1 ): fmt . Println ( \ud83c\udfb5 Brave Sir Robin ran away \ud83c\udfb5 ) fmt . Println ( \ud83c\udfb5 Bravely ran away away \ud83c\udfb5 ) return } } \u00d6rnek Uygulama Bir gurup i\u015f\u00e7i demir ve k\u00f6m\u00fcr bar\u0131nd\u0131ran maden yataklar\u0131nda maden aray\u0131p, kaz\u0131p bu madenleri i\u015flemektedir. A\u015fa\u011f\u0131daki uygulamada go dilinin sa\u011flad\u0131\u011f\u0131 concurrency ara\u00e7lar\u0131 ile i\u015f\u00e7ilerin e\u015f zamanl\u0131 olarak nas\u0131l \u00e7al\u0131\u015ft\u0131r\u0131labilece\u011fini g\u00f6rebiliriz. package main import ( fmt strconv sync time ) // Vein madenleri bar\u0131nd\u0131r\u0131r type Vein struct { Ores [] string } // Reveal bir sonraki madeni a\u00e7\u0131\u011fa \u00e7\u0131kar\u0131r func ( vein * Vein ) Reveal () ( ore string ) { if len ( vein . Ores ) == 0 { return } ore = vein . Ores [ 0 ] vein . Ores = vein . Ores [ 1 :] return ore } // Worker madenleri bulur, kazar ve i\u015fler type Worker struct { name string } // Find maden yata\u011f\u0131nda arama yapar ve buldu\u011fu madeni kaz\u0131c\u0131lara g\u00f6nderir func ( w * Worker ) Find ( vein * Vein , ch chan - string ) { ore := vein . Reveal () if ore != { fmt . Println ( w . name , found , ore ) time . Sleep ( time . Second * 2 ) ch - ore } } // Mine madeni \u00e7\u0131kart\u0131r ve i\u015fleme kanal\u0131na g\u00f6nderir func ( w * Worker ) Mine ( finder - chan string , smelter chan - string ) { for ore := range finder { fmt . Println ( w . name , mining , ore ) time . Sleep ( time . Second * 1 ) smelter - ore } } // Smelt madenleri eritir veya i\u015fler func ( w * Worker ) Smelt ( coal_miner , iron_miner - chan string , wg * sync . WaitGroup ) { for { select { case coal_ore := - coal_miner : time . Sleep ( time . Second * 1 ) fmt . Println ( w . name , processed , coal_ore ) case iron_ore := - iron_miner : time . Sleep ( time . Second * 2 ) fmt . Println ( w . name , smelted , iron_ore ) } wg . Done () } } func main () { wg := sync . WaitGroup {} // 100 demir bar\u0131nd\u0131ran bir maden olu\u015ftur n_iron_ores := 100 iron_vein := Vein { make ([] string , n_iron_ores )} for i := range iron_vein . Ores { iron_vein . Ores [ i ] = iron-ore- + strconv . Itoa ( i ) } // 50 k\u00f6m\u00fcr bar\u0131nd\u0131ran bir maden olu\u015ftur n_coal_ores := 50 coal_vein := Vein { make ([] string , n_coal_ores )} for i := range coal_vein . Ores { coal_vein . Ores [ i ] = coal-ore- + strconv . Itoa ( i ) } // \u0130\u015f\u00e7iler aras\u0131nda maden iletim kanallar\u0131 olu\u015ftur finder_to_miner := make ( chan string ) coal_miner_to_smelter := make ( chan string ) iron_miner_to_smelter := make ( chan string ) // Maden arama i\u015f\u00e7ileri olu\u015ftur n_finders := 6 finders := make ([] * Worker , n_finders ) for i := range finders { finders [ i ] = Worker { name : finder- + strconv . Itoa ( i ), } } // Maden kaz\u0131c\u0131lar\u0131 olu\u015ftur n_miners := 50 miners := make ([] * Worker , n_miners ) for i := range miners { miners [ i ] = Worker { name : miner- + strconv . Itoa ( i ), } } // Maden i\u015fleyicileri olu\u015ftur n_smelters := 10 smelters := make ([] * Worker , n_smelters ) for i := range smelters { smelters [ i ] = Worker { name : smelter- + strconv . Itoa ( i ), } } // Maden aramac\u0131lar\u0131n yar\u0131s\u0131n\u0131 demir, di\u011fer yar\u0131s\u0131n\u0131 k\u00f6m\u00fcr madenine g\u00f6nder for i := 0 ; i n_iron_ores + n_coal_ores ; i ++ { wg . Add ( 1 ) finder_idx := i % len ( finders ) go finders [ finder_idx ]. Find ( coal_vein , finder_to_miner ) go finders [ finder_idx ]. Find ( iron_vein , finder_to_miner ) } // Kaz\u0131c\u0131lar\u0131n yar\u0131s\u0131n\u0131 demir, di\u011fer yar\u0131s\u0131n\u0131 k\u00f6m\u00fcr madeninde \u00e7al\u0131\u015ft\u0131r for i , miner := range miners { if i % 2 == 0 { go miner . Mine ( finder_to_miner , iron_miner_to_smelter ) } else { go miner . Mine ( finder_to_miner , coal_miner_to_smelter ) } } // Maden i\u015fleyen i\u015f\u00e7ileri \u00e7al\u0131\u015ft\u0131r for _ , smelter := range smelters { go smelter . Smelt ( coal_miner_to_smelter , iron_miner_to_smelter , wg ) } // B\u00fct\u00fcn madenlerin bulunmas\u0131n\u0131, kaz\u0131lmas\u0131n\u0131 ve i\u015flenmesini bekle wg . Wait () }","title":"Concurrency"},{"location":"tr/concurrency/#concurrency","text":"English | T\u00fcrk\u00e7e Bilgisayar biliminde concurrency(e\u015fzamanl\u0131l\u0131k), bir programdaki i\u015f birimlerinin veya algoritmalar\u0131n sonucu etkilemeyecek \u015fekilde s\u0131ras\u0131z bir bi\u00e7imde \u00e7al\u0131\u015ft\u0131r\u0131labilmesidir. \u0130\u015f par\u00e7alar\u0131n\u0131 birbirinden ba\u011f\u0131ms\u0131z \u00e7al\u0131\u015ft\u0131rabilmemiz, s\u00fcre\u00e7leri farkl\u0131 \u00e7ekirdeklerde y\u00fcr\u00fcterek, i\u015flemciyi maksimum verimde kullanmam\u0131z\u0131 sa\u011flar. GO dilinde concurrency goroutineler ile sa\u011flan\u0131r.","title":"Concurrency"},{"location":"tr/concurrency/#goroutines","text":"GO routineler boyutlar\u0131 k\u00fc\u00e7\u00fck threadler olarak d\u00fc\u015f\u00fcn\u00fclebilir. Goroutine olu\u015fturmak i\u00e7in sadece fonksiyonu \u00e7al\u0131\u015ft\u0131r\u0131rken ba\u015f\u0131na go yazmam\u0131z yeterli. A\u015fa\u011f\u0131daki uygulamada Work fonksiyonu her \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, \u00e7al\u0131\u015fmas\u0131 bitene kadar uygulamay\u0131 blokluyor. func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { Work ( work work work work work work... ) Work ( zxcasfv ) } Bloklayan k\u0131s\u0131mlar\u0131 goroutine olarak \u00e7al\u0131\u015ft\u0131ral\u0131m. func main () { go Work ( work work work work work work... ) go Work ( zxcasfv ) } Program\u0131 \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda ekrana hi\u00e7bir \u015fey yazd\u0131rmadan sonlanacak. main fonksiyonu, Work fonksiyonu hen\u00fcz ekrana bir \u015feyler yazacak kadar \u00e7al\u0131\u015fmadan, bitiyor ve program kapan\u0131yor. Ufak bir hile ile Work fonksiyonunun \u00e7\u0131kt\u0131s\u0131n\u0131 alabiliriz. package main import ( fmt time ) func Work ( msg string ) { fmt . Println ( msg ) time . Sleep ( time . Second * 2 ) } func main () { go Work ( work work work work work work... ) go Work ( zxcasfv ) time . Sleep ( time . Second * 1 ) }","title":"Goroutines"},{"location":"tr/concurrency/#waitgroup","text":"Uygulaman\u0131n belli anlar\u0131nda baz\u0131 goroutinelerin bitmesini beklememiz gerekebilir. WaitGroup ile ka\u00e7 tane gorouitne \u00e7al\u0131\u015faca\u011f\u0131n\u0131 \u00f6ncesinde girip sonras\u0131nda i\u015flerini bitirmelerini bekleyebiliriz. Goroutinelerin burada tek yapmas\u0131 gereken, i\u015fi bitti\u011finde WaitGroup'un Done methodunu \u00e7al\u0131\u015ft\u0131rmas\u0131. func Work ( msg string , wg * sync . WaitGroup ) { time . Sleep ( time . Second * 2 ) fmt . Println ( msg ) wg . Done () } func main () { nWorkers1 , nWorkers2 := 5 , 4 wg := sync . WaitGroup {} wg . Add ( nWorkers1 ) for i := 0 ; i nWorkers1 ; i ++ { go Work ( work-1 , wg ) } wg . Wait () wg . Add ( nWorkers2 ) for i := 0 ; i nWorkers2 ; i ++ { go Work ( work-2 , wg ) wg . Wait () }","title":"waitGroup"},{"location":"tr/concurrency/#channels","text":"Channeller goroutinelerin birbirleri ile haberle\u015fmesini sa\u011flar. Yukar\u0131daki \u00f6rnekte go ile \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131z fonksiyonlardan d\u00f6n\u00fc\u015f de\u011feri alam\u0131yoruz. Channellar ile goroutinin sonucu ana fonksiyona veya ba\u015fka bir goroutine g\u00f6ndermesini sa\u011flayabiliriz. channeller make(chan veritipi, buffer) \u015feklinde olu\u015fturulabilir. func Work ( msg string , ch chan string ) { ch - msg time . Sleep ( time . Second * 2 ) } func main () { ch1 := make ( chan string ) go Work ( work-1 , ch1 ) go Work ( work-2 , ch1 ) for i := 0 ; i 2 ; i ++ { msg := - ch1 fmt . Println ( msg ) } }","title":"Channels"},{"location":"tr/concurrency/#mutex","text":"Wikipedia Tan\u0131m\u0131 In computer science, mutual exclusion is a property of concurrency control, which is instituted for the purpose of preventing race conditions. It is the requirement that one thread of execution never enters its critical section at the same time that another concurrent thread of execution enters its own critical section, which refers to an interval of time during which a thread of execution accesses a shared resource, such as shared memory. func Click ( counter * int , wg * sync . WaitGroup ) { * counter += 1 wg . Done () } func main () { counter := 0 nUsers := 500 wg := sync . WaitGroup {} wg . Add ( nUsers ) for i := 0 ; i nUsers ; i ++ { go Click ( counter , wg ) } wg . Wait () fmt . Println ( counter ) } func Click ( counter * int , wg * sync . WaitGroup , mx * sync . Mutex ) { mx . Lock () * counter += 1 mx . Unlock () wg . Done () } func main () { counter := 0 mx := sync . Mutex {} nUsers := 500 wg := sync . WaitGroup {} wg . Add ( nUsers ) for i := 0 ; i nUsers ; i ++ { go Click ( counter , wg , mx ) } wg . Wait () fmt . Println ( counter ) }","title":"Mutex"},{"location":"tr/concurrency/#select","text":"Kanallara veri g\u00f6ndermek veya kanallardan veri beklemek uygulamay\u0131 bloklar. Select ayn\u0131 anda birka\u00e7 tane kanal\u0131 beklememize olanak sa\u011flar. A\u015fa\u011f\u0131daki \u00f6rnekte 2 goroutine chan1 ve chan2 kanallar\u0131na s\u00fcrekli veri g\u00f6nderiyor. \u0130ki kanaldan da gelen t\u00fcm verileri sonsuz bir d\u00f6ng\u00fc i\u00e7indeki select yap\u0131s\u0131 ile alabiliriz. Herhangi bir kanaldan mesaj geldi\u011finde select o kanal\u0131 bekleyen case e girecek ve i\u00e7inde tan\u0131mlanan i\u015flemler bittikten sonra d\u00f6ng\u00fc kanal bekleme i\u015flemini tekrarlayacakt\u0131r. chan1 := make ( chan string ) chan2 := make ( chan string ) go func () { for { time . Sleep ( 2 * time . Second ) chan1 - one } }() go func () { for { time . Sleep ( 1 * time . Second ) chan2 - two } }() for { select { case msg1 := - chan1 : fmt . Println ( msg1 ) case msg2 := - chan2 : fmt . Println ( msg2 ) } }","title":"Select"},{"location":"tr/concurrency/#zaman-asm","text":"Yukar\u0131daki gibi bir program 2 channela da veri g\u00f6nderilmezse kilitlenecektir. Bu sonsuz d\u00f6ng\u00fcy\u00fc ba\u015fka bir channel\u0131 bekleyerek k\u0131rabiliriz. Go, bu t\u00fcr bir ama\u00e7 i\u00e7in \u00f6nceden tan\u0131mlanm\u0131\u015f yap\u0131lara sahiptir. Time mod\u00fcl\u00fcndeki time.After metodunu bellirledi\u011fimiz bir s\u00fcreden sonra bir channel\u0131 tetiklemek i\u00e7in kullanabiliriz. chan1 := make ( chan string ) chan2 := make ( chan string ) go func () { for { time . Sleep ( 1 * time . Second ) chan1 - one } }() go func () { for { time . Sleep ( 2 * time . Second ) chan2 - two } }() for { select { case msg1 := - chan1 : fmt . Println ( msg1 ) case msg2 := - chan2 : fmt . Println ( msg2 ) case - time . After ( time . Second * 1 ): fmt . Println ( \ud83c\udfb5 Brave Sir Robin ran away \ud83c\udfb5 ) fmt . Println ( \ud83c\udfb5 Bravely ran away away \ud83c\udfb5 ) return } }","title":"Zaman A\u015f\u0131m\u0131"},{"location":"tr/concurrency/#ornek-uygulama","text":"Bir gurup i\u015f\u00e7i demir ve k\u00f6m\u00fcr bar\u0131nd\u0131ran maden yataklar\u0131nda maden aray\u0131p, kaz\u0131p bu madenleri i\u015flemektedir. A\u015fa\u011f\u0131daki uygulamada go dilinin sa\u011flad\u0131\u011f\u0131 concurrency ara\u00e7lar\u0131 ile i\u015f\u00e7ilerin e\u015f zamanl\u0131 olarak nas\u0131l \u00e7al\u0131\u015ft\u0131r\u0131labilece\u011fini g\u00f6rebiliriz. package main import ( fmt strconv sync time ) // Vein madenleri bar\u0131nd\u0131r\u0131r type Vein struct { Ores [] string } // Reveal bir sonraki madeni a\u00e7\u0131\u011fa \u00e7\u0131kar\u0131r func ( vein * Vein ) Reveal () ( ore string ) { if len ( vein . Ores ) == 0 { return } ore = vein . Ores [ 0 ] vein . Ores = vein . Ores [ 1 :] return ore } // Worker madenleri bulur, kazar ve i\u015fler type Worker struct { name string } // Find maden yata\u011f\u0131nda arama yapar ve buldu\u011fu madeni kaz\u0131c\u0131lara g\u00f6nderir func ( w * Worker ) Find ( vein * Vein , ch chan - string ) { ore := vein . Reveal () if ore != { fmt . Println ( w . name , found , ore ) time . Sleep ( time . Second * 2 ) ch - ore } } // Mine madeni \u00e7\u0131kart\u0131r ve i\u015fleme kanal\u0131na g\u00f6nderir func ( w * Worker ) Mine ( finder - chan string , smelter chan - string ) { for ore := range finder { fmt . Println ( w . name , mining , ore ) time . Sleep ( time . Second * 1 ) smelter - ore } } // Smelt madenleri eritir veya i\u015fler func ( w * Worker ) Smelt ( coal_miner , iron_miner - chan string , wg * sync . WaitGroup ) { for { select { case coal_ore := - coal_miner : time . Sleep ( time . Second * 1 ) fmt . Println ( w . name , processed , coal_ore ) case iron_ore := - iron_miner : time . Sleep ( time . Second * 2 ) fmt . Println ( w . name , smelted , iron_ore ) } wg . Done () } } func main () { wg := sync . WaitGroup {} // 100 demir bar\u0131nd\u0131ran bir maden olu\u015ftur n_iron_ores := 100 iron_vein := Vein { make ([] string , n_iron_ores )} for i := range iron_vein . Ores { iron_vein . Ores [ i ] = iron-ore- + strconv . Itoa ( i ) } // 50 k\u00f6m\u00fcr bar\u0131nd\u0131ran bir maden olu\u015ftur n_coal_ores := 50 coal_vein := Vein { make ([] string , n_coal_ores )} for i := range coal_vein . Ores { coal_vein . Ores [ i ] = coal-ore- + strconv . Itoa ( i ) } // \u0130\u015f\u00e7iler aras\u0131nda maden iletim kanallar\u0131 olu\u015ftur finder_to_miner := make ( chan string ) coal_miner_to_smelter := make ( chan string ) iron_miner_to_smelter := make ( chan string ) // Maden arama i\u015f\u00e7ileri olu\u015ftur n_finders := 6 finders := make ([] * Worker , n_finders ) for i := range finders { finders [ i ] = Worker { name : finder- + strconv . Itoa ( i ), } } // Maden kaz\u0131c\u0131lar\u0131 olu\u015ftur n_miners := 50 miners := make ([] * Worker , n_miners ) for i := range miners { miners [ i ] = Worker { name : miner- + strconv . Itoa ( i ), } } // Maden i\u015fleyicileri olu\u015ftur n_smelters := 10 smelters := make ([] * Worker , n_smelters ) for i := range smelters { smelters [ i ] = Worker { name : smelter- + strconv . Itoa ( i ), } } // Maden aramac\u0131lar\u0131n yar\u0131s\u0131n\u0131 demir, di\u011fer yar\u0131s\u0131n\u0131 k\u00f6m\u00fcr madenine g\u00f6nder for i := 0 ; i n_iron_ores + n_coal_ores ; i ++ { wg . Add ( 1 ) finder_idx := i % len ( finders ) go finders [ finder_idx ]. Find ( coal_vein , finder_to_miner ) go finders [ finder_idx ]. Find ( iron_vein , finder_to_miner ) } // Kaz\u0131c\u0131lar\u0131n yar\u0131s\u0131n\u0131 demir, di\u011fer yar\u0131s\u0131n\u0131 k\u00f6m\u00fcr madeninde \u00e7al\u0131\u015ft\u0131r for i , miner := range miners { if i % 2 == 0 { go miner . Mine ( finder_to_miner , iron_miner_to_smelter ) } else { go miner . Mine ( finder_to_miner , coal_miner_to_smelter ) } } // Maden i\u015fleyen i\u015f\u00e7ileri \u00e7al\u0131\u015ft\u0131r for _ , smelter := range smelters { go smelter . Smelt ( coal_miner_to_smelter , iron_miner_to_smelter , wg ) } // B\u00fct\u00fcn madenlerin bulunmas\u0131n\u0131, kaz\u0131lmas\u0131n\u0131 ve i\u015flenmesini bekle wg . Wait () }","title":"\u00d6rnek Uygulama"},{"location":"tr/data-structures/","text":"Veri Yap\u0131lar\u0131 English | T\u00fcrk\u00e7e Bu sayfa go diline ait veri yap\u0131lar\u0131 ve bu yap\u0131lar\u0131n genel programlamada uygulanan y\u00f6ntemlerle kullan\u0131m\u0131 anlat\u0131lmaktad\u0131r. Array Arrayler ayn\u0131 tipteki verileri bir arada muhafaza etmemizi sa\u011flayan yap\u0131lard\u0131r. \u00d6rne\u011fin; 4, 5, 19 ve 25'ten olu\u015fan veri b\u00fct\u00fcn\u00fc arrayi tan\u0131mlar. Go farkl\u0131 tipteki verilerden array olu\u015fturmam\u0131za izin vermez. Tan\u0131mlama Arrayler temel olarak [Boyut]Tip bi\u00e7iminde tan\u0131mlan\u0131r. Arrayleri olu\u015fturman\u0131n \u00e7e\u015fitli yollar\u0131n\u0131 a\u015fa\u011f\u0131da g\u00f6rebiliriz. int tipinde 3 birim tutabilen array. var fruits [ 3 ] string B\u00f6yle tan\u0131mland\u0131\u011f\u0131nda arraydeki her bir alan, veri tipinin \u00f6n tan\u0131ml\u0131 de\u011feri ile doldurulur. Bu \u00f6rne\u011fi baz al\u0131rsak [0, 0, 0] olarak tan\u0131mlanacakt\u0131r. Bu de\u011ferleri bulunduklar\u0131 indexler \u00fczerinden eri\u015ferek de\u011fi\u015ftirebiliriz. fruits [ 0 ] = \ud83c\udf4c fruits [ 1 ] = \ud83c\udf4f fruits // [\ud83c\udf4c \ud83c\udf4f ] Array i\u00e7in tan\u0131mlanan\u0131n d\u0131\u015f\u0131ndaki bir veri tipini kullan\u0131rsak hata ile kar\u015f\u0131la\u015f\u0131r\u0131z. arr [ 2 ] = 1 cannot use 1 ( type int ) as type string in assignment Ayn\u0131 arrayi daha k\u0131sa bir yol ile de tan\u0131mlayabiliriz. fruits := [ 3 ] int { \ud83c\udf4c , \ud83c\udf4f } fruits // [\ud83c\udf4c \ud83c\udf4f ] Bu tan\u0131mlamada ilk 2 eleman\u0131n\u0131 do\u011frudan tan\u0131mlad\u0131\u011f\u0131m\u0131z 3 birim uzunlu\u011fundaki bir arrayi arr de\u011fi\u015fkenine atad\u0131k. E\u011fer arrayi de\u011ferleri ile birlikte olu\u015fturulacaksak ... ifadesini kullan\u0131larak, boyut hesaplama k\u0131sm\u0131 compilera b\u0131rak\u0131labiliriz. fruits := [ 3 ] int { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf49] D\u00f6ng\u00fc ile kullanma Arrayler for d\u00f6ng\u00fcs\u00fc ile temel olarak 2 \u015fekilde kullan\u0131labilir. \u0130ndex ile eri\u015ferek. fruits := [ 3 ] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } for index := range fruits { fruit := fruits [ index ] fmt . Println ( fruit ) } Do\u011frudan de\u011fere eri\u015ferek. fruits := [ 3 ] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } for _ , fruit := range fruits { fmt . Println ( fruit ) } Slice Slicelar kullan\u0131m bak\u0131m\u0131ndan arraylere \u00e7ok benzer. Slicelar\u0131n fark\u0131, boyutlar\u0131n\u0131n dinamik olmas\u0131. Slice tan\u0131mlarken yine arraydeki gibi []Tip yap\u0131s\u0131n\u0131 kullan\u0131yoruz fakat k\u00f6\u015feli parantezlerin i\u00e7ini bo\u015f b\u0131rak\u0131yoruz. // nil slice tan\u0131mlama var slc [] int // nill slice a de\u011fer atama slc = [] int { 12 , 24 , 39 } // do\u011frudan tan\u0131mlama slc := [] int { 12 , 24 , 39 } make Slicelar\u0131 tan\u0131mlamak i\u00e7in `make` fonksiyonunu da kullanabiliriz. make fonksiyonunun ilk parametresi olu\u015fturulacak slice\u0131n boyutunu belirler. // boyut ile tan\u0131mlama n_items = 20 slc := make ([] int , n_items ) // boyut ve kapasite ile tan\u0131mlama capacity := 40 slc := make ([] int , n_items , capacity ) Slice \u0130\u015flemleri Slice olu\u015fturulurken kapasitesi kadar, tutaca\u011f\u0131 veri tipinin \u00f6n tan\u0131ml\u0131 de\u011feri ile doldurulur. Fakat, yaln\u0131zca uzunlu\u011fu kadar k\u0131sm\u0131na eri\u015filebilir. Bir slice\u0131n boyutunu art\u0131rmak istiyorsak bunun i\u00e7in append ve copy fonksiyonlar\u0131n\u0131 kullanabiliriz. copy copy bir slice\u0131 ayn\u0131 veya daha b\u00fcy\u00fck kapasiteye sahip bir di\u011fer slicea kopyalamam\u0131z\u0131 sa\u011flar ve ka\u00e7 adet eleman\u0131n kopyaland\u0131\u011f\u0131n\u0131 d\u00f6nd\u00fcr\u00fcr. bucket := make ([] string , 5 ) fruits := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } n_copied := copy ( bucket , fruits ) n_copied // 5 bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49] Bir slice kopyalan\u0131rken, elemanlar hedef slicedaki ayn\u0131 indexdeki elemanlar\u0131n yerini al\u0131r. fruits := [] string { \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } apples := [] string { \ud83c\udf4e , , \ud83c\udf4f } copy ( fruits , apples ) fruits // [\ud83c\udf4e \ud83c\udf4f] append append fonksiyonu, ilk parametre olarak boyutunu art\u0131raca\u011f\u0131m\u0131z slice\u0131 ve devam\u0131nda ekleyece\u011fimiz elemanlar\u0131 al\u0131r ve bize t\u00fcm elemanlar\u0131 i\u00e7eren yeni bir slice d\u00f6nd\u00fcr\u00fcr. Bu nedenle, d\u00f6n\u00fc\u015f de\u011ferini bir de\u011fi\u015fkende(genellikle eski slice de\u011fi\u015fkeninde) tutmak gerekir. bucket := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf48 , \ud83c\udf49 } green_apple := \ud83c\udf4f bucket = append ( bucket , green_apple ) bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49 \ud83c\udf4f] Bir slice\u0131 yeniden boyutland\u0131r\u0131p ba\u015fka bir de\u011fi\u015fkene atad\u0131\u011f\u0131m\u0131zda, yeni slicedaki de\u011fi\u015fiklikler orjinal slice\u0131 da etkileyecektir. fruits := [] string { \ud83c\udf4e , \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } apples := fruits [: 2 ] apples [ 0 ] = \ud83c\udf4f apples [ 1 ] = \ud83c\udf4f apples // [\ud83c\udf4f \ud83c\udf4f] fruits // [\ud83c\udf4f \ud83c\udf4f \ud83c\udf47 \ud83c\udf52 \ud83c\udf49] cut Slicedaki belli bir aral\u0131\u011f\u0131 \u00e7\u0131karmak istiyorsak a\u015fa\u011f\u0131daki y\u00f6ntemi kullanabiliriz. Bu y\u00f6ntem Sliceda belirledi\u011fimiz ba\u015flang\u0131\u00e7 indexine kadar olan elemanlar ile biti\u015f indexinden sonraki elemanlar\u0131 ekleyecek. B\u00f6ylece aradaki elemanlar\u0131 bo\u015fa \u00e7\u0131kartm\u0131\u015f olaca\u011f\u0131z. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } cut_start_index , cut_end_index := 4 , 6 edibles = append ( edibles [: cut_start_index ], edibles [ cut_end_index :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54] delete Slicedaki bir eleman\u0131 indexini kullanarak silmek istiyorsak, a\u015fa\u011f\u0131daki y\u00f6ntemi kullanabiliriz. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 edibles = append ( edibles [: index_of_cherry ], edibles [ index_of_cherry + 1 :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] Benzer i\u015flemi copy fonksiyonu ile de yapabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte, yukar\u0131dakinden farkl\u0131 olarak 4. sat\u0131rda: \u00d6nce edible slice\u0131nda \ud83c\udf52eleman\u0131ndan sonraki k\u0131sm\u0131 se\u00e7tik. Bu bize, t\u00fcm kapasiteyi de g\u00f6sterirsek, [\ud83c\udf52 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] bi\u00e7iminde bir slice verdi. Sonras\u0131nda \ud83c\udf52eleman\u0131ndan 1 index sonraki k\u0131sm\u0131, se\u00e7ilen slice ile de\u011fi\u015ftirdik . B\u00f6ylece [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54 \ud83e\udd54] listesini elde etmi\u015f olduk. sat\u0131rda da slice\u0131 yeni eleman say\u0131s\u0131na g\u00f6re dilimledik. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 n_copied := copy ( edibles [ index_of_cherry :], edibles [ index_of_cherry + 1 :]) new_length := index_of_cherry + n_copied edibles = edibles [: new_length ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] S\u0131ralamay\u0131 Dikkate Almadan Silme Silme i\u015flemini array s\u0131ralamas\u0131n\u0131 g\u00f6z ard\u0131 ederek de yapabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte, silmek istedi\u011fimiz eleman ile slicedaki en son eleman\u0131n yerini de\u011fi\u015ftirdik. Ard\u0131ndan slice\u0131n boyutunu 1 azaltt\u0131k. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 edibles [ index_of_cherry ] = edibles [ len ( edibles ) - 1 ] edibles = edibles [: len ( edibles ) - 1 ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83e\udd54 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d] Garbage Collection E\u011fer sliceda kulland\u0131\u011f\u0131m\u0131z elemanlar pointer veya pointer alanlara sahip struct ise yukar\u0131da g\u00f6sterilen cut ve delete i\u015flemleri memory leak olu\u015fturabilir. Bunun sebebi, slice\u0131n silindikten sonra da silinen eleman\u0131n referans\u0131n\u0131 tutabilmesindendir. A\u015fa\u011f\u0131daki \u00f6rneklerde daha \u00f6ncesinde yapt\u0131\u011f\u0131m\u0131z i\u015flemlere ek olarak, i\u015flemdem sonra bo\u015fta kalan alanlar\u0131 nil de\u011ferler ile doldurduk. B\u00f6ylece garbage collector bu alanlar\u0131n art\u0131k kullan\u0131lmayaca\u011f\u0131n\u0131 anlay\u0131p, sisteme geri kazand\u0131rabilir. cut (memory safe) apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } cut_start_index , cut_end_index := 1 , 5 copy ( fruits [ cut_start_index :], fruits [ cut_end_index :]) cleanup_index := len ( fruits ) - cut_end_index + cut_start_index for free_index , free_end := cleanup_index , len ( fruits ); free_index free_end ; free_index ++ { fruits [ free_index ] = nil } fruits = fruits [: cleanup_index ] fruits // [\ud83c\udf4e \ud83c\udf4c] delete (memory safe) apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } delete_index := 2 copy ( fruits [ delete_index :], fruits [ delete_index + 1 :]) fruits [ len ( fruits ) - 1 ] = nil fruits = fruits [: len ( fruits ) - 1 ] fruits // [\ud83c\udf4e \ud83c\udf4e \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c] S\u0131ralamay\u0131 Dikkate Almadan Silme (memory safe) apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } delete_index := 2 fruits [ delete_index ] = fruits [ len ( fruits ) - 1 ] fruits [ len ( fruits ) - 1 ] = nil fruits = fruits [: len ( fruits ) - 1 ] fruits // [\ud83c\udf4e \ud83c\udf4e \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c] expand Bir slice\u0131, di\u011feri birle\u015ftirmek istersek a\u015fa\u011f\u0131daki y\u00f6ntemleri kullanabiliriz. bucket := [] string { \ud83c\udf4c , \ud83c\udf47 , \ud83c\udf49 } apples := [] string { \ud83c\udf4f , \ud83c\udf4e } bucket = append ( bucket , apples ... ) bucket // [\ud83c\udf4c \ud83c\udf47 \ud83c\udf49 \ud83c\udf4f \ud83c\udf4e] A\u015fa\u011f\u0131daki \u00f6rnekte 7. sat\u0131rda apples ile belirledi\u011fimiz indexten sonraki elemanlar\u0131 birle\u015ftirdik. Sonras\u0131nda belirledi\u011fimiz indexe kadar olan bucket elemanlar\u0131na, bu slice elemanlar\u0131n\u0131 ekledik. bucket := [] string { \ud83c\udf4c , \ud83c\udf47 , \ud83c\udf49 } apples := [] string { \ud83c\udf4f , \ud83c\udf4e } expand_index := 2 bucket = append ( bucket [: expand_index ], append ( apples , bucket [ expand_index :] ... ) ... , ) bucket // [\ud83c\udf4c \ud83c\udf47 \ud83c\udf4f \ud83c\udf4e \ud83c\udf49] filter Slice elemanlar\u0131n\u0131 belirli bir kritere g\u00f6re filtreleyebiliriz. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 , \ud83c\udf4f , \ud83c\udf4e } apple_criteria := \ud83c\udf4e apples := [] string {} for _ , fruit := range fruits { if fruit == apple_criteria { apples = append ( apples , fruit ) } } apples // [\ud83c\udf4e \ud83c\udf4e] insert Slice\u0131n herhangi bir k\u0131sm\u0131na yeni bir eleman eklemek istiyorsak; bu y\u00f6ntemleri kullanabiliriz. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c insert_index := 2 fruits = append ( fruits [: insert_index ], append ([] string { banana }, fruits [ insert_index :] ... ) ... , ) fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49] {% hint style=\"warning\" %} Memory Concern sat\u0131rdaki append([]string{banana}, fruits[insert_index:]...) ****b\u00f6l\u00fcm\u00fc ba\u015fl\u0131 ba\u015f\u0131na bir slice olu\u015fturup, fruits[insert_index:] slice\u0131n\u0131n elemanlar\u0131n\u0131 bu slicea kopyal\u0131yor. Bu elemanlar daha sonra fruits slice\u0131na tekrar kopyalan\u0131yor. Yeni bir slice olu\u015fturulmas\u0131n\u0131n ve 2. kez kopyalama i\u015fleminin \u00f6n\u00fcne ge\u00e7ilebilir. {% endhint %} fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c insert_index := 2 fruits = append ( fruits , ) copy ( fruits [ insert_index + 1 :], fruits [ insert_index :]) fruits [ insert_index ] = banana fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49] pop A\u015fa\u011f\u0131daki \u00f6rnekte slice\u0131n son eleman\u0131n\u0131 \u00e7\u0131kar\u0131p bir de\u011fi\u015fkene atad\u0131k. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } item , fruits := fruits [ len ( fruits ) - 1 ], fruits [: len ( fruits ) - 1 ] item // \ud83c\udf49 fruits // [\ud83c\udf4f \ud83c\udf4e] push front (unshift) Bu \u00f6rnekte yeni bir eleman\u0131 slice\u0131n ba\u015f\u0131na koyduk. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c fruits = append ([] string { banana }, fruits ... ) fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf4e \ud83c\udf49] pop front (shift) Bu \u00f6rnekte de slice\u0131n ilk eleman\u0131n\u0131 \u00e7\u0131kar\u0131p bir de\u011fi\u015fkene atad\u0131k. fruits := [] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana , fruits := fruits [ 0 ], fruits [ 1 :] banana // \ud83c\udf4c fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf49] Map En s\u0131k kullan\u0131lan veri tiplerinden birisi de maplerdir. map unique anahtarlar\u0131, de\u011ferlerle e\u015fle\u015ftirebilen sonras\u0131nda bu anahtarla e\u015fle\u015ftirilen de\u011fere eri\u015filmesini sa\u011flayan yap\u0131lard\u0131r. Tan\u0131mlama Mapler map[AnahtarTipi]De\u011ferTipi veya make(map[AnahtarTipi]De\u011ferTipi) \u015feklinde tan\u0131mlanabilir. var mymap = map [ string ] string {} mymap = make ( map [ string ] string ) De\u011fer Atama monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 1979 : Life of Brian , } monty_python_films_by_year [ 1983 ] = The Meaning of Life Atad\u0131\u011f\u0131m\u0131z de\u011ferlere, yine ayn\u0131 keyi kullanarak eri\u015febiliriz. film_name := monty_python_films_by_year [ 1983 ] film_name // The Meaning of Life Mapin bir eleman\u0131na eri\u015firken, eleman\u0131n mapde kay\u0131tl\u0131 olup olmad\u0131\u011f\u0131n\u0131 g\u00f6steren ek bir de\u011fere daha eri\u015febiliriz. film_name , registered := monty_python_films_by_year [ 2019 ] if ! registered { fmt . Println ( Monty python did not relase a film at 2019 ) } else { fmt . Println ( film_name ) } D\u00f6ng\u00fc ile kullanma Map elemanlar\u0131na temelde 2 yolla eri\u015filebilir. For d\u00f6ng\u00fcs\u00fcnde tek de\u011fi\u015fken kullan\u0131p, keyler \u00fczerinden eri\u015ferek. monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 1979 : Life of Brian , 1983 : The Meaning of Life , } for year := range monty_python_films_by_year { film_name := monty_python_films_by_year [ year ] fmt . Println ( film_name , was released at , year ) } D\u00f6ng\u00fcde 2 de\u011fi\u015fken kullan\u0131p, hem anahtar hem de de\u011fere eri\u015ferek. for year , film_name := range monty_python_films_by_year { fmt . Println ( film_name , was released at , year ) } /* Monty Python and the Holy Grail was released at 1971 Life of Brian was released at 1979 The Meaning of Life was released at 1983 */ delete Mapdeki bir eleman\u0131 silmek i\u00e7in delete fonksiyonunu kullanabiliriz. monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 2016 : Batman v Superman , } delete ( monty_python_films_by_year , 2016 ) _ , registered := monty_python_films_by_year [ 2016 ] registered // false len ( monty_python_films_by_year ) // 1 struct Structlar kullan\u0131c\u0131 taraf\u0131ndan tan\u0131mlanan ve farkl\u0131 t\u00fcrdeki verileri isimleri ile tutabilen veri yap\u0131lar\u0131d\u0131r. Tan\u0131mlama Structlar a\u015fa\u011f\u0131daki yap\u0131da tan\u0131mlanabilir. type StructName struct { field fieldType } Struct\u0131n ayn\u0131 tipteki alanlar\u0131n\u0131 tek sat\u0131rda tan\u0131mlayabiliriz. type Film struct { name , director string imdb float32 release_year int } var new_film = Film {} new_film // { 0 0} Struct alanlar\u0131na ek olarak etiket de verebiliriz. type Film struct { Name string `json: film_name ` Director string `json: director_name ` Imdb float32 `json: imdb_score ` ReleaseYear int `json: year_of_release ` } Etiketler tip d\u00f6n\u00fc\u015f\u00fcm\u00fc ile \u00e7ok\u00e7a u\u011fra\u015fan ORMler ve serialization k\u00fct\u00fcphaneleri aras\u0131nda pop\u00fclerdir. Bu etiketlere reflect mod\u00fcl\u00fc ile eri\u015filebilir. f := Film {} t := reflect . TypeOf ( f ) for _ , f := range [] string { Name , Director , Imdb , ReleaseYear } { field , found := t . FieldByName ( f ) if ! found { continue } fmt . Println ( field . Tag . Get ( json )) } /* film_name director_name imdb_score year_of_release */ De\u011fer Atama Bir struct, parametreleri s\u0131ras\u0131yla verilerek olu\u015fturulabilir. new_film := Film { Mad Max: Fury Road , George Miller , 8.1 , 2015 } new_film // {Mad Max: Fury Road George Miller 8.1 2015} Benzer bi\u00e7imde, parametreleri ve alacaklar\u0131 de\u011ferleri : ayrac\u0131 ile belirterek de olu\u015fturulabilir. new_film := Film { Name : Ran , Director : Akira Kurosawa , Imdb : 8.2 , ReleaseYear : 1985 , } new_film // {Ran Akira Kurosawa 8.2 1985} Struct olu\u015ftururken baz\u0131 alanlar bo\u015f b\u0131rak\u0131l\u0131rsa; bu alanlar o veri tipinin bo\u015f de\u011ferleri ile tan\u0131mlan\u0131r. new_film := Film { name : Batman v Superman , director : Zack Snyder , release_year : 2016 , } new_film // {Batman v Superman Zack Snyder 0 2016} Anonymous struct Baz\u0131 \u00f6zel durumlarda structlar\u0131 fonksiyon g\u00f6vdesi i\u00e7erisinde tan\u0131mlamam\u0131z gerekebilir. Bunu a\u015fa\u011f\u0131daki y\u00f6ntemle yapabiliriz. provider_config := struct { name string baseUrl string apiKey string }{ name : mapbox , baseUrl : https://api.mapbox.com/geocoding/v5/ , apiKey : 123asds123 , } provider_config // {mapbox https://api.mapbox.com/geocoding/v5/ 123asds123} Anonymous fields Alan isimlerini belirtilmeden de struct tan\u0131mlanabilir. Bu tarz bir tan\u0131mlamada belirtilen veri tiplerinin birbirinden farkl\u0131 olmas\u0131 gerekir. type Item struct { string // code int // quantity float32 // price } item := Item { child-seat-1 , 5 , 20.1 , } item // {child-seat 5 20.1} Promoted fields Bir struct ba\u015fka bir struct i\u00e7erisinde alan ismi verilmeden kullan\u0131labilir. Bu durumda i\u00e7erideki structa kendi ismiyle eri\u015filir. A\u015fa\u011f\u0131daki \u00f6rne\u011fi baz al\u0131rsak Page i\u00e7erisindeki Content e page.Content \u015feklinde eri\u015filebilir. type Content struct { body string size int } type Page struct { nextUrl string previousURL string Content } content := Content { body : h1 Hi /h1 , size : 11 , } page := Page { nextUrl : http://.../3 , previousURL : http://.../1 , Content : content , } page // {http://.../3 http://.../1 { h1 Hi /h1 11}} page . Content // { h1 Hi /h1 11} Pointer Pointer bir ba\u015fka de\u011fi\u015fkenin memory adresini tutan bir de\u011fi\u015fkendir. \u00c7al\u0131\u015fma esnas\u0131nda yeni bir nesne olu\u015fturuldu\u011funda, bu nesneyi haf\u0131zada tutmam\u0131z gerekir. Nesne i\u00e7in haf\u0131zada ayr\u0131lan alan\u0131n yerini de\u011fi\u015fkenler ile tutar\u0131z. Tan\u0131mlama Pointer da de\u011fi\u015fkenlerdir. Di\u011fer de\u011fi\u015fkenlerden fark\u0131 herhangi bir veriyi de\u011fil, o verinin yerini belirten de\u011fi\u015fkenin adresini tutmas\u0131d\u0131r. Pointerlar var pointer *Type yap\u0131s\u0131 kullan\u0131larak tan\u0131mlan\u0131r. De\u011fer atanmad\u0131\u011f\u0131 takdirde pointerin de\u011feri nil olarak belirlenir. var ptr * int ptr // nil Pointerlar\u0131 new fonksiyonunu kullanarak da tan\u0131mlayabiliriz. ptr := new ( int ) ptr // nil De\u011fer Atama Pointera i\u015faretini kullanarak, bir ba\u015fka de\u011fi\u015flenin adresini, de\u011fer olarak atayabiliriz. * i\u015fareti ile pointeri kullanarak, i\u015faret etti\u011fi de\u011fi\u015fkene(dolay\u0131s\u0131yla tutulan veriye) eri\u015febiliriz. var carbon string = Carbon var ptrCarbon * string ptrCarbon = carbon ptrCarbon // 0xc000092030 * ptrCarbon // Carbon * ptrCarbon = Altered + * ptrCarbon carbon // Altered Carbon Fonksiyonlar Genel olarak GO'da fonksiyonlar a\u015fa\u011f\u0131daki yap\u0131da tan\u0131mlan\u0131r. func fonksiyon_ad\u0131 ( [ parametre listesi ] ) [ d\u00f6n\u00fc\u015f de\u011ferlerinin tipleri ] { fonksiyon g\u00f6vdesi } func sigmoid ( value float64 ) float64 { return 1.0 / ( 1.0 + math . Exp ( - value )) } sigmoid ( 0.5 ) // 0.62246 Parametreler GO fonksiyonlar\u0131na parametre olarak girilen de\u011fi\u015fkenler kopyalan\u0131r. Bu nedenle parametreler \u00fczerinde yap\u0131lan de\u011fi\u015fiklikler de\u011fi\u015fkenlerin fonksiyon d\u0131\u015f\u0131ndaki durumlar\u0131n\u0131 etkilemez. type Wallet struct { userID int balance float64 deposit float64 } func withdraw ( wallet Wallet , amount float64 ) { wallet . balance -= amount } Yukar\u0131daki kodda basit\u00e7e bir c\u00fczdan yap\u0131s\u0131 ve bu c\u00fczdandan para \u00e7ekebilen withdraw fonksiyonu tan\u0131mlad\u0131k. A\u015fa\u011f\u0131daki sat\u0131rlarda da bir adet c\u00fczdan olu\u015fturup bu fonksiyon ile kulland\u0131k. wallet := Wallet { userID : 1 , balance : 30000.12 , deposit : 40000.01 , } item_price := 10023.0 withdraw ( wallet , item_price ) wallet . balance // 3000.12 G\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere c\u00fczdandaki para de\u011fi\u015fmedi. Bu tarz kazalar\u0131 2 yolla \u00f6nleyebiliriz. Y\u00f6ntem, c\u00fczdandaki son para durumunu d\u00f6nd\u00fcr\u00fcp, c\u00fczdan\u0131 sonradan g\u00fcncelleyebiliriz. func withdraw ( wallet Wallet , amount float64 ) float64 { new_balance := wallet . balance - amount return new_balance } wallet . balance = withdraw ( wallet , item_price ) wallet . balance // 19977.12 Bu de\u011fi\u015fim, i\u015fi c\u00fczdandan para \u00e7ekmek olan withdraw fonksiyonunun kullan\u0131m amac\u0131n\u0131 de\u011fi\u015ftirmi\u015f oluyor. Y\u00f6ntem, c\u00fczdan de\u011fi\u015fkeni yerine, c\u00fczdan\u0131n adresini parametre olarak verebiliriz. func withdraw ( wallet * Wallet , amount float64 ) { wallet . balance -= amount } withdraw ( wallet , item_price ) wallet . balance // 19977.12 Bu y\u00f6ntemin dezavantaj\u0131 da farkl\u0131 concurrency safe olmamas\u0131d\u0131r. Farkl\u0131 threadler ile c\u00fczdandan para \u00e7ekmek istedi\u011fimizde, bakiye durumunu takip etmek zor olacakt\u0131r. Dinamik parametreler GO fonksiyonlar\u0131nda dinamik parametreler tan\u0131mlanabilir. Bu t\u00fcrdeki parametreleri tan\u0131mlamak i\u00e7in parametre tipinin \u00f6n\u00fcne ... i\u015fareti yaz\u0131l\u0131r. func ReLU ( nums ... float64 ) [] float64 { new_nums := make ([] float64 , len ( nums )) for idx , value := range nums { if value 0 { new_nums [ idx ] = value } else { new_nums [ idx ] = 0. } } return new_nums } nums := [] float64 { 1. , 0.2 , 0. , 0. , - 0.1 , 0.1 } nums = ReLU ( nums ... ) nums // [1 0.2 0 0 0 0.1] D\u00f6n\u00fc\u015f De\u011ferleri Birden fazla de\u011fer d\u00f6nd\u00fcrme GO fonksiyonlar\u0131nda birden fazla de\u011fer d\u00f6nd\u00fcr\u00fclebilir. D\u00f6n\u00fclecek de\u011ferleri () aras\u0131nda s\u0131ras\u0131yla tan\u0131mlamak gerekmektedir. func swap ( first_arg , second_arg string ) ( string , string ) { return second_arg , first_arg } var language1 , language2 string = Python , GO language1 , language2 = swap ( language1 , language2 ) language1 , language2 // GO Python D\u00f6n\u00fc\u015f de\u011ferlerini isimlendirme Fonksiyonlar\u0131n d\u00f6n\u00fc\u015f de\u011ferlerine isim verip, de\u011ferleri bu de\u011fi\u015fkenler ile belirleyebiliriz. \u0130simlendirilmi\u015f d\u00f6n\u00fc\u015f de\u011ferleri veri tipinin bo\u015f de\u011ferini alaca\u011f\u0131 i\u00e7in, fonksiyonun \u00f6n tan\u0131ml\u0131 d\u00f6n\u00fc\u015f de\u011ferleri olarak da kullan\u0131labilirler. type Record struct { id int data string } type DB struct { records [] Record locked bool } func BulkCreate ( records [] Record , db * DB ) ( n_created int , err error ) { if db . locked { err = errors . New ( DB is locked ) } else { db . records = append ( db . records , records ... ) n_created = len ( records ) } return n_created , err } db := DB { records : [] Record {}, locked : true , } data := [] Record {} for i := 0 ; i 100 ; i ++ { rec := Record { id : i , data : test , } data = append ( data , rec ) } n_created , err := BulkCreate ( data , db ) if err != nil { fmt . Println ( err ) } Anonim Fonksiyon GO'da fonksiyonlar da veri yap\u0131lar\u0131d\u0131r ve di\u011fer fonksiyonlar\u0131n i\u00e7erisinde tan\u0131mlanabilirler. Anonim fonksiyonlar\u0131, projenin k\u0131s\u0131tl\u0131 bir b\u00f6l\u00fcm\u00fcnde, spesifik bir i\u015fi halletmek i\u00e7in kullanabiliriz. A\u015fa\u011f\u0131daki kod \u00f6rne\u011finde, projenin ba\u015fka yerinde bu i\u015fleme ihtiya\u00e7 duymayaca\u011f\u0131m\u0131z\u0131 varsayarak, bir slice\u0131 belirlenen boyutta par\u00e7alayan bir anonim fonksiyon kulland\u0131k. records := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } batchSize := 3 batchedRecords := func ( data [] int , batchSize int ) [][] int { var batches [][] int for batchSize len ( data ) { data , batches = data [ batchSize :], append ( batches , data [ 0 : batchSize : batchSize ]) } batches = append ( batches , data ) return batches }( records , batchSize ) batchedRecords // [[0 1 2] [3 4 5] [6 7 8] [9]] Bu t\u00fcrdeki fonksiyonlar\u0131 bir de\u011fi\u015fkene atay\u0131p bir ka\u00e7 kez de kullanabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte spesifik bir APIden ayr\u0131 ayr\u0131 g\u00f6nderilen \u00fclke kodu ve telefon numaralar\u0131n\u0131 de\u011fi\u015fken olarak tan\u0131mlad\u0131\u011f\u0131m\u0131z fonksiyonla birle\u015ftirdik. type Vendor struct { name string countryCode string phone string } vendor := Vendor { name : Volswagen Group , countryCode : 1 , phone : 403120120 , } formatPhoneNumbers := func ( contact Vendor ) string { return + + contact . countryCode + contact . phone } formatPhoneNumbers ( vendor ) // +1403120120 Metodlar GO dilinde di\u011fer nesne y\u00f6nelimli programlama dilleri gibi classlar ve kal\u0131t\u0131m yoktur. Fakat fonksiyonlara receiver denilen ek bir arg\u00fcman ekleyerek ile kendi olu\u015fturdu\u011fumuz tiplere fonksiyonlar\u0131 ba\u011flayabiliriz. B\u00f6ylece GO dilinde de nesne y\u00f6nelimli programlamaya benzer bir deneyim yakalanabilir. type Connection struct { host string port int timeOut int isClosed bool } func ( conn * Connection ) Close () { conn . isClosed = true fmt . Println ( Connection , conn . host + : + strconv . Itoa ( conn . port ), closed. ) } Yukar\u0131daki yap\u0131da Close fonksiyonuna normal bir fonksiyona ek olarak (conn *Connection) k\u0131sm\u0131n\u0131 ekledik. B\u00f6ylece a\u015fa\u011f\u0131daki \u00f6rnekte g\u00f6r\u00fcld\u00fc\u011f\u00fc gibi c.Close() \u015feklinde Connection tipi \u00fczerinden fonksiyona eri\u015febildik. c := Connection { host : 0.0.0.0 , port : 8080 , timeOut : 1 , isClosed : false , } c . Close () // Connection 0.0.0.0:8080 closed. Pointer receiver | Value receiver Fonksiyon parametrelerinde oldu\u011fu gibi receiverlerde de yap\u0131n\u0131n de\u011feri ile mi yoksa memory adresi ile mi kullan\u0131laca\u011f\u0131na karar verilmelidir. Receiverlar\u0131 struct d\u0131\u015f\u0131ndaki tipler i\u00e7in de kullanabiliriz. type Iterable [] int func ( iterable * Iterable ) Append ( items ... int ) { * iterable = append ( * iterable , items ... ) } arr := Iterable { 1 , 2 } arr . Append ( 4 , 5 , 6 ) arr // [1 2 4 5 6] Error GOda kendi hata tiplerimizi olu\u015fturabiliriz. Bunun i\u00e7in olu\u015fturdu\u011fumuz tipin sadece Error methoduna sahip olmas\u0131 yeterlidir. Tan\u0131mlama A\u015fa\u011f\u0131daki \u00f6rnekte HTTP kodunu ve hata nedenini belirten HTTPError ad\u0131nda yeni bir hata tan\u0131mlad\u0131k. type HTTPError struct { Status int Reason string } func ( e HTTPError ) Error () string { return fmt . Sprintf ( %v: %v , e . Status , e . Reason ) } func MakeRequest () error { return HTTPError { Status : 400 , Reason : Bad Request , } } Kullan\u0131m Fonksiyon \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda d\u00f6n\u00fclen hata de\u011ferinin nil olup olmad\u0131\u011f\u0131 kontrol edilerek buna g\u00f6re \u00f6nlemler al\u0131nabilir. err := MakeRequest () if err != nil { fmt . Println ( err ) } Interface Interfaceler bir objenin sahip olabilece\u011fi methodlar\u0131 belirten yap\u0131lard\u0131r. Bu nedenle interfaceler objelerin davran\u0131\u015f\u0131n\u0131 ifade eder. \u00d6rne\u011fin; bir dosyandan veri okunabilir veya dosyaya veri yaz\u0131labilir. Bir interface okuma ve yazma methodlar\u0131n\u0131 bar\u0131nd\u0131r\u0131yorsa ve dosya objesi bu methodlara sahipse dosyan\u0131n bu interfacei implement etti\u011fi s\u00f6ylenebilir. Interfacelerin as\u0131l amac\u0131 methodlar\u0131, ald\u0131klar\u0131 parametreleri ve d\u00f6n\u00fc\u015f de\u011ferlerini genel bir \u015fekilde tan\u0131mlayarak; ayn\u0131 davran\u0131\u015f\u0131 g\u00f6steren, fakat farkl\u0131 i\u015flerde kullan\u0131lan yap\u0131lar i\u00e7in ortak bir protokol olu\u015fturmakt\u0131r. Tan\u0131mlama GO dilinde interfaceler objelerle kapal\u0131 halde uygulan\u0131r. Ba\u015fka bir deyi\u015fle; bir tipin bir interfacei kulland\u0131\u011f\u0131n\u0131 belirtmek i\u00e7in, di\u011fer \u00e7o\u011fu nesne y\u00f6nelimli dillerde oldu\u011fu gibi, class File implements IO gibi deyimler kullanmam\u0131z gerekmez. GO ayn\u0131 metodlar\u0131 payla\u015fan interface ve tipler aras\u0131ndaki ili\u015fkiyi kendisi kurar. type IOInterface interface { Read () [] byte Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } type Socket struct { ip string port int buffer [] byte } func ( sock * Socket ) Read () [] byte { return sock . buffer } func ( sock * Socket ) Write ( stream [] byte ) int { sock . buffer = append ( sock . buffer , stream ... ) return len ( stream ) } file := File { name : test , } sock := Socket { ip : 0.0.0.0 , port : 21 , } data := [] byte ( data ) file . Write ( data ) sock . Write ( file . Read ()) string ( sock . Read () // data Yukar\u0131daki uygulamada Read ve Write metodlar\u0131n\u0131 tan\u0131mlayan IOInterface interfaceini ve bu methodlara sahip File ve Socket tiplerini tan\u0131mlad\u0131k. Kullan\u0131m A\u015fa\u011f\u0131daki \u00f6rnekte Log methodu IOInterface interfaceini parametre olarak ald\u0131\u011f\u0131 i\u00e7in hangi veri tipinden geldi\u011fini \u00f6nemsemeden veriyi okuyup, i\u015fini yapabilir. type Logger struct { } func ( log * Logger ) Log ( io IOInterface ) { for _ , data := range io . Read () { fmt . Print ( string ( data )) } fmt . Println () } file := File { name : test , } sock := Socket { ip : 0.0.0.0 , port : 21 , } logger := Logger {} data := [] byte ( data ) file . Write ( data ) sock . Write ( file . Read ()) logger . Log ( file ) // data logger . Log ( sock ) // data Birden Fazla interface kullanma GO tipleri birden fazla interfacei implement edebilir. Bunun i\u00e7in interfacein belirtti\u011fi metodlara sahip olmalar\u0131 yeterlidir. type Reader interface { Read () [] byte } type Writer interface { Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } var file Reader = File { name : test , content : [] byte ( data ), } var sock Writer = Socket { ip : 0.0.0.0 , port : 21 , } sock . Write ( file . Read ()) sock . buffer // sock.buffer undefined (type Writer has no field or method buffer Tip d\u00f6n\u00fc\u015f\u00fcm\u00fc s := sock .( * Socket ) string ( s . buffer ) // data D\u00f6n\u00fc\u015ft\u00fcrd\u00fc\u011f\u00fcm\u00fcz tipin o interfacei do\u011fru bir \u015fekilde implement edip etmedi\u011fini d\u00f6n\u00fc\u015f\u00fcm s\u0131ras\u0131nda alaca\u011f\u0131m\u0131z ek bir parametre ile kontrol edebiliriz. type Serializer interface { Serialize () } s , ok := sock .( Serializer ) s , ok // nil, false Bo\u015f interface Interfaceler de di\u011fer veri yap\u0131lar\u0131 gibi tiplerdir ve ayn\u0131 \u015fekilde kullan\u0131labilir. GO projelerinde bo\u015f interface; interface{} \u015feklinde tan\u0131mlan\u0131r. Hi\u00e7bir metodu olmad\u0131\u011f\u0131 i\u00e7in bo\u015f interfacein gereksinimleri b\u00fct\u00fcn tipler taraf\u0131ndan kar\u015f\u0131lan\u0131r. bo\u015f interfacein bu \u00f6zelli\u011fi, dinamik parametreler ve de\u011ferler tan\u0131mlamam\u0131za olanak tan\u0131r. type Booking struct { Provider string CustomerID string ExtraProviderParams interface {} } booking1 := Booking { Provider : ACL , CustomerID : customer-01a , ExtraProviderParams : map [ string ] interface {}{ Passengers : 4 , PaymentTime : after-booking , }, } booking2 := Booking { Provider : DCM , CustomerID : customer-03f , ExtraProviderParams : [] interface {}{ 4 , after-booking , }, } booking1 // {ACL customer-01a map[Passengers:4 PaymentTime:after-booking]} booking2 // {DCM customer-01a [4 after-booking]} Tip Kontrol\u00fc Interface tipleri switch yap\u0131s\u0131 ile kontrol edilebilir. A\u015fa\u011f\u0131daki \u00f6rnekte Stringify fonksiyonu interface{} tipinde parametre olarak alarak farkl\u0131 veri tiplerini fonksiyonda kullanmam\u0131za olanak sa\u011fl\u0131yor. Bu fonksiyonda int string ve float gelen de\u011ferleri tiplerine g\u00f6re kontrol edip belirledi\u011fimiz \u015fekilde stringe \u00e7evirece\u011fiz. func Stringify ( value interface {}) ( string , error ) { switch value .( type ) { case string : return value .( string ), nil case float32 , float64 : return fmt . Sprintf ( %.2f , value ), nil case int : return fmt . Sprintf ( %d , value ), nil default : return , errors . New ( Invalid type ) } } Stringify ( 12 ) // 12 Stringify ( 12.52312313 ) // 12.52 Stringify ( test ) // test Containers Hemen hemen her dilde standart hale gelmi\u015f ve programlarda \u00e7ok\u00e7a kullan\u0131lan baz\u0131 kompozit veri yap\u0131lar\u0131 vard\u0131r. Go bu yap\u0131lardan 3\u00fcn\u00fc bize container paketi i\u00e7inde haz\u0131r halde sunuyor. List Heap Heap veri yap\u0131s\u0131, istedi\u011fimiz tipteki elemanlar\u0131 \u00f6ncelik s\u0131ras\u0131na g\u00f6re tutarak; \u00fczerilerinde i\u015flem yapmam\u0131z\u0131 sa\u011flar. Heap temelde bir interfacedir ve bir veri yap\u0131s\u0131n\u0131n heapi implement edebilmesi i\u00e7in Len , Less , Swap , Push ve Pop methodlar\u0131na sahip olmas\u0131 gerekir. \u00d6rnek olarak sadece int tipinde say\u0131lar\u0131 tutan bir slice olu\u015ftural\u0131m ve bunu slice\u0131 heap olarak kullanal\u0131m. type IntHeap [] int \u00d6ncelikle heap interfaceinin Len metodunu implement edelim. Slicelar\u0131n uzunlu\u011funu len fonksiyonuyla do\u011frudan alabildi\u011fimiz i\u00e7in bu metodu yazmam\u0131z \u00e7ok da zor olmayacak. func ( h IntHeap ) Len () int { return len ( h ) } \u015eimdi de heapdeki iki eleman\u0131 birbiriyle k\u0131yaslayan ve yerlerini de\u011fi\u015ftiren Less ve Swap metodlar\u0131n\u0131 tan\u0131mlayal\u0131m. func ( h IntHeap ) Less ( i , j int ) bool { return h [ i ] h [ j ] } func ( h IntHeap ) Swap ( i , j int ) { h [ i ], h [ j ] = h [ j ], h [ i ] } Son olarak eleman eklememizi ve \u00e7\u0131karmam\u0131z\u0131 sa\u011flayacak Push ve Pop metodlar\u0131n\u0131 yazal\u0131m. Bu methodlar, slice\u0131n uzunlu\u011funu etkiledi\u011fi i\u00e7in pointer receiver olarak tan\u0131mlanmas\u0131 gerekiyor. func ( h * IntHeap ) Push ( x interface {}) { * h = append ( * h , x .( int )) } func ( h * IntHeap ) Pop () interface {} { old := * h n := len ( old ) x := old [ n - 1 ] * h = old [ 0 : n - 1 ] return x } IntHeap, bir heapin olmay\u0131 gerektiren t\u00fcm \u00f6zelliklere sahip. Art\u0131k container/heap paketini kullanarak bu slice\u0131 heape \u00e7evirebiliriz. func main () { h := IntHeap { 2 , 1 , 5 } heap . Init ( h ) heap . Push ( h , 3 ) fmt . Printf ( minimum: %d\\n , ( * h )[ 0 ]) for h . Len () 0 { fmt . Printf ( %d , heap . Pop ( h )) } // Output: // minimum: 1 // 1 2 3 5 } Ring Ek Kaynaklar https://medium.com/rungo/structures-in-go-76377cc106a2 https://golangbot.com/arrays-and-slices/ https://blog.golang.org/go-slices-usage-and-internals https://gobyexample.com/slices https://medium.com/rungo/the-anatomy-of-slices-in-go-6450e3bb2b94 https://opensource.com/article/18/7/introduction-go-arrays-and-slices https://appliedgo.net/slices/ https://gobyexample.com/maps https://blog.golang.org/go-maps-in-action https://medium.com/rungo/the-anatomy-of-maps-in-go-79b82836838b https://github.com/Pungyeon/clean-go-article https://medium.com/rungo/error-handling-in-go-f0125de052f0 https://github.com/golang/go/wiki/SliceTricks https://gobyexample.com/variadic-functions https://github.com/emirpasic/gods https://github.com/avelino/awesome-go https://golangbot.com/pointers/ http://www.golang-book.com/books/intro/8 https://medium.com/rungo/the-anatomy-of-arrays-in-go-24429e4491b7 https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca https://medium.com/rungo/interfaces-in-go-ab1601159b3a https://medium.com/@dotronglong/interface-naming-convention-in-golang-f53d9f471593 https://yourbasic.org/golang/interfaces-explained/ https://medium.com/rungo/structures-in-go-76377cc106a2 https://talks.golang.org/2012/10things.slide#9 https://flaviocopes.com/go-empty-interface/ https://research.swtch.com/interfaces https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go","title":"Veri Yap\u0131lar\u0131"},{"location":"tr/data-structures/#veri-yaplar","text":"English | T\u00fcrk\u00e7e Bu sayfa go diline ait veri yap\u0131lar\u0131 ve bu yap\u0131lar\u0131n genel programlamada uygulanan y\u00f6ntemlerle kullan\u0131m\u0131 anlat\u0131lmaktad\u0131r.","title":"Veri Yap\u0131lar\u0131"},{"location":"tr/data-structures/#array","text":"Arrayler ayn\u0131 tipteki verileri bir arada muhafaza etmemizi sa\u011flayan yap\u0131lard\u0131r. \u00d6rne\u011fin; 4, 5, 19 ve 25'ten olu\u015fan veri b\u00fct\u00fcn\u00fc arrayi tan\u0131mlar. Go farkl\u0131 tipteki verilerden array olu\u015fturmam\u0131za izin vermez.","title":"Array"},{"location":"tr/data-structures/#tanmlama","text":"Arrayler temel olarak [Boyut]Tip bi\u00e7iminde tan\u0131mlan\u0131r. Arrayleri olu\u015fturman\u0131n \u00e7e\u015fitli yollar\u0131n\u0131 a\u015fa\u011f\u0131da g\u00f6rebiliriz. int tipinde 3 birim tutabilen array. var fruits [ 3 ] string B\u00f6yle tan\u0131mland\u0131\u011f\u0131nda arraydeki her bir alan, veri tipinin \u00f6n tan\u0131ml\u0131 de\u011feri ile doldurulur. Bu \u00f6rne\u011fi baz al\u0131rsak [0, 0, 0] olarak tan\u0131mlanacakt\u0131r. Bu de\u011ferleri bulunduklar\u0131 indexler \u00fczerinden eri\u015ferek de\u011fi\u015ftirebiliriz. fruits [ 0 ] = \ud83c\udf4c fruits [ 1 ] = \ud83c\udf4f fruits // [\ud83c\udf4c \ud83c\udf4f ] Array i\u00e7in tan\u0131mlanan\u0131n d\u0131\u015f\u0131ndaki bir veri tipini kullan\u0131rsak hata ile kar\u015f\u0131la\u015f\u0131r\u0131z. arr [ 2 ] = 1 cannot use 1 ( type int ) as type string in assignment Ayn\u0131 arrayi daha k\u0131sa bir yol ile de tan\u0131mlayabiliriz. fruits := [ 3 ] int { \ud83c\udf4c , \ud83c\udf4f } fruits // [\ud83c\udf4c \ud83c\udf4f ] Bu tan\u0131mlamada ilk 2 eleman\u0131n\u0131 do\u011frudan tan\u0131mlad\u0131\u011f\u0131m\u0131z 3 birim uzunlu\u011fundaki bir arrayi arr de\u011fi\u015fkenine atad\u0131k. E\u011fer arrayi de\u011ferleri ile birlikte olu\u015fturulacaksak ... ifadesini kullan\u0131larak, boyut hesaplama k\u0131sm\u0131 compilera b\u0131rak\u0131labiliriz. fruits := [ 3 ] int { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf49] D\u00f6ng\u00fc ile kullanma Arrayler for d\u00f6ng\u00fcs\u00fc ile temel olarak 2 \u015fekilde kullan\u0131labilir. \u0130ndex ile eri\u015ferek. fruits := [ 3 ] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } for index := range fruits { fruit := fruits [ index ] fmt . Println ( fruit ) } Do\u011frudan de\u011fere eri\u015ferek. fruits := [ 3 ] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf49 } for _ , fruit := range fruits { fmt . Println ( fruit ) }","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#slice","text":"Slicelar kullan\u0131m bak\u0131m\u0131ndan arraylere \u00e7ok benzer. Slicelar\u0131n fark\u0131, boyutlar\u0131n\u0131n dinamik olmas\u0131. Slice tan\u0131mlarken yine arraydeki gibi []Tip yap\u0131s\u0131n\u0131 kullan\u0131yoruz fakat k\u00f6\u015feli parantezlerin i\u00e7ini bo\u015f b\u0131rak\u0131yoruz. // nil slice tan\u0131mlama var slc [] int // nill slice a de\u011fer atama slc = [] int { 12 , 24 , 39 } // do\u011frudan tan\u0131mlama slc := [] int { 12 , 24 , 39 }","title":"Slice"},{"location":"tr/data-structures/#make","text":"Slicelar\u0131 tan\u0131mlamak i\u00e7in `make` fonksiyonunu da kullanabiliriz. make fonksiyonunun ilk parametresi olu\u015fturulacak slice\u0131n boyutunu belirler. // boyut ile tan\u0131mlama n_items = 20 slc := make ([] int , n_items ) // boyut ve kapasite ile tan\u0131mlama capacity := 40 slc := make ([] int , n_items , capacity )","title":"make"},{"location":"tr/data-structures/#slice-islemleri","text":"Slice olu\u015fturulurken kapasitesi kadar, tutaca\u011f\u0131 veri tipinin \u00f6n tan\u0131ml\u0131 de\u011feri ile doldurulur. Fakat, yaln\u0131zca uzunlu\u011fu kadar k\u0131sm\u0131na eri\u015filebilir. Bir slice\u0131n boyutunu art\u0131rmak istiyorsak bunun i\u00e7in append ve copy fonksiyonlar\u0131n\u0131 kullanabiliriz.","title":"Slice \u0130\u015flemleri"},{"location":"tr/data-structures/#copy","text":"copy bir slice\u0131 ayn\u0131 veya daha b\u00fcy\u00fck kapasiteye sahip bir di\u011fer slicea kopyalamam\u0131z\u0131 sa\u011flar ve ka\u00e7 adet eleman\u0131n kopyaland\u0131\u011f\u0131n\u0131 d\u00f6nd\u00fcr\u00fcr. bucket := make ([] string , 5 ) fruits := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } n_copied := copy ( bucket , fruits ) n_copied // 5 bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49] Bir slice kopyalan\u0131rken, elemanlar hedef slicedaki ayn\u0131 indexdeki elemanlar\u0131n yerini al\u0131r. fruits := [] string { \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } apples := [] string { \ud83c\udf4e , , \ud83c\udf4f } copy ( fruits , apples ) fruits // [\ud83c\udf4e \ud83c\udf4f]","title":"copy"},{"location":"tr/data-structures/#append","text":"append fonksiyonu, ilk parametre olarak boyutunu art\u0131raca\u011f\u0131m\u0131z slice\u0131 ve devam\u0131nda ekleyece\u011fimiz elemanlar\u0131 al\u0131r ve bize t\u00fcm elemanlar\u0131 i\u00e7eren yeni bir slice d\u00f6nd\u00fcr\u00fcr. Bu nedenle, d\u00f6n\u00fc\u015f de\u011ferini bir de\u011fi\u015fkende(genellikle eski slice de\u011fi\u015fkeninde) tutmak gerekir. bucket := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf48 , \ud83c\udf49 } green_apple := \ud83c\udf4f bucket = append ( bucket , green_apple ) bucket // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf48 \ud83c\udf49 \ud83c\udf4f] Bir slice\u0131 yeniden boyutland\u0131r\u0131p ba\u015fka bir de\u011fi\u015fkene atad\u0131\u011f\u0131m\u0131zda, yeni slicedaki de\u011fi\u015fiklikler orjinal slice\u0131 da etkileyecektir. fruits := [] string { \ud83c\udf4e , \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 } apples := fruits [: 2 ] apples [ 0 ] = \ud83c\udf4f apples [ 1 ] = \ud83c\udf4f apples // [\ud83c\udf4f \ud83c\udf4f] fruits // [\ud83c\udf4f \ud83c\udf4f \ud83c\udf47 \ud83c\udf52 \ud83c\udf49]","title":"append"},{"location":"tr/data-structures/#cut","text":"Slicedaki belli bir aral\u0131\u011f\u0131 \u00e7\u0131karmak istiyorsak a\u015fa\u011f\u0131daki y\u00f6ntemi kullanabiliriz. Bu y\u00f6ntem Sliceda belirledi\u011fimiz ba\u015flang\u0131\u00e7 indexine kadar olan elemanlar ile biti\u015f indexinden sonraki elemanlar\u0131 ekleyecek. B\u00f6ylece aradaki elemanlar\u0131 bo\u015fa \u00e7\u0131kartm\u0131\u015f olaca\u011f\u0131z. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } cut_start_index , cut_end_index := 4 , 6 edibles = append ( edibles [: cut_start_index ], edibles [ cut_end_index :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf52 \ud83c\udf49 \ud83c\udf3d \ud83e\udd54]","title":"cut"},{"location":"tr/data-structures/#delete","text":"Slicedaki bir eleman\u0131 indexini kullanarak silmek istiyorsak, a\u015fa\u011f\u0131daki y\u00f6ntemi kullanabiliriz. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 edibles = append ( edibles [: index_of_cherry ], edibles [ index_of_cherry + 1 :] ... ) edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] Benzer i\u015flemi copy fonksiyonu ile de yapabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte, yukar\u0131dakinden farkl\u0131 olarak 4. sat\u0131rda: \u00d6nce edible slice\u0131nda \ud83c\udf52eleman\u0131ndan sonraki k\u0131sm\u0131 se\u00e7tik. Bu bize, t\u00fcm kapasiteyi de g\u00f6sterirsek, [\ud83c\udf52 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54] bi\u00e7iminde bir slice verdi. Sonras\u0131nda \ud83c\udf52eleman\u0131ndan 1 index sonraki k\u0131sm\u0131, se\u00e7ilen slice ile de\u011fi\u015ftirdik . B\u00f6ylece [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54 \ud83e\udd54] listesini elde etmi\u015f olduk. sat\u0131rda da slice\u0131 yeni eleman say\u0131s\u0131na g\u00f6re dilimledik. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 n_copied := copy ( edibles [ index_of_cherry :], edibles [ index_of_cherry + 1 :]) new_length := index_of_cherry + n_copied edibles = edibles [: new_length ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d \ud83e\udd54]","title":"delete"},{"location":"tr/data-structures/#sralamay-dikkate-almadan-silme","text":"Silme i\u015flemini array s\u0131ralamas\u0131n\u0131 g\u00f6z ard\u0131 ederek de yapabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte, silmek istedi\u011fimiz eleman ile slicedaki en son eleman\u0131n yerini de\u011fi\u015ftirdik. Ard\u0131ndan slice\u0131n boyutunu 1 azaltt\u0131k. edibles := [] string { \ud83c\udf4e , \ud83c\udf47 , \ud83c\udf52 , \ud83c\udf49 , \ud83c\udf36 , \ud83c\udf46 , \ud83c\udf3d , \ud83e\udd54 } index_of_cherry := 2 edibles [ index_of_cherry ] = edibles [ len ( edibles ) - 1 ] edibles = edibles [: len ( edibles ) - 1 ] edibles // [\ud83c\udf4e \ud83c\udf47 \ud83e\udd54 \ud83c\udf49 \ud83c\udf36 \ud83c\udf46 \ud83c\udf3d] Garbage Collection E\u011fer sliceda kulland\u0131\u011f\u0131m\u0131z elemanlar pointer veya pointer alanlara sahip struct ise yukar\u0131da g\u00f6sterilen cut ve delete i\u015flemleri memory leak olu\u015fturabilir. Bunun sebebi, slice\u0131n silindikten sonra da silinen eleman\u0131n referans\u0131n\u0131 tutabilmesindendir. A\u015fa\u011f\u0131daki \u00f6rneklerde daha \u00f6ncesinde yapt\u0131\u011f\u0131m\u0131z i\u015flemlere ek olarak, i\u015flemdem sonra bo\u015fta kalan alanlar\u0131 nil de\u011ferler ile doldurduk. B\u00f6ylece garbage collector bu alanlar\u0131n art\u0131k kullan\u0131lmayaca\u011f\u0131n\u0131 anlay\u0131p, sisteme geri kazand\u0131rabilir.","title":"S\u0131ralamay\u0131 Dikkate Almadan Silme"},{"location":"tr/data-structures/#cut-40memory-safe41","text":"apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } cut_start_index , cut_end_index := 1 , 5 copy ( fruits [ cut_start_index :], fruits [ cut_end_index :]) cleanup_index := len ( fruits ) - cut_end_index + cut_start_index for free_index , free_end := cleanup_index , len ( fruits ); free_index free_end ; free_index ++ { fruits [ free_index ] = nil } fruits = fruits [: cleanup_index ] fruits // [\ud83c\udf4e \ud83c\udf4c]","title":"cut (memory safe)"},{"location":"tr/data-structures/#delete-40memory-safe41","text":"apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } delete_index := 2 copy ( fruits [ delete_index :], fruits [ delete_index + 1 :]) fruits [ len ( fruits ) - 1 ] = nil fruits = fruits [: len ( fruits ) - 1 ] fruits // [\ud83c\udf4e \ud83c\udf4e \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c]","title":"delete (memory safe)"},{"location":"tr/data-structures/#sralamay-dikkate-almadan-silme-40memory-safe41","text":"apple := \ud83c\udf4e banana := \ud83c\udf4c fruits := [] * string { apple , apple , apple , banana , banana , banana } delete_index := 2 fruits [ delete_index ] = fruits [ len ( fruits ) - 1 ] fruits [ len ( fruits ) - 1 ] = nil fruits = fruits [: len ( fruits ) - 1 ] fruits // [\ud83c\udf4e \ud83c\udf4e \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c]","title":"S\u0131ralamay\u0131 Dikkate Almadan Silme (memory safe)"},{"location":"tr/data-structures/#expand","text":"Bir slice\u0131, di\u011feri birle\u015ftirmek istersek a\u015fa\u011f\u0131daki y\u00f6ntemleri kullanabiliriz. bucket := [] string { \ud83c\udf4c , \ud83c\udf47 , \ud83c\udf49 } apples := [] string { \ud83c\udf4f , \ud83c\udf4e } bucket = append ( bucket , apples ... ) bucket // [\ud83c\udf4c \ud83c\udf47 \ud83c\udf49 \ud83c\udf4f \ud83c\udf4e] A\u015fa\u011f\u0131daki \u00f6rnekte 7. sat\u0131rda apples ile belirledi\u011fimiz indexten sonraki elemanlar\u0131 birle\u015ftirdik. Sonras\u0131nda belirledi\u011fimiz indexe kadar olan bucket elemanlar\u0131na, bu slice elemanlar\u0131n\u0131 ekledik. bucket := [] string { \ud83c\udf4c , \ud83c\udf47 , \ud83c\udf49 } apples := [] string { \ud83c\udf4f , \ud83c\udf4e } expand_index := 2 bucket = append ( bucket [: expand_index ], append ( apples , bucket [ expand_index :] ... ) ... , ) bucket // [\ud83c\udf4c \ud83c\udf47 \ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"expand"},{"location":"tr/data-structures/#filter","text":"Slice elemanlar\u0131n\u0131 belirli bir kritere g\u00f6re filtreleyebiliriz. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 , \ud83c\udf4f , \ud83c\udf4e } apple_criteria := \ud83c\udf4e apples := [] string {} for _ , fruit := range fruits { if fruit == apple_criteria { apples = append ( apples , fruit ) } } apples // [\ud83c\udf4e \ud83c\udf4e]","title":"filter"},{"location":"tr/data-structures/#insert","text":"Slice\u0131n herhangi bir k\u0131sm\u0131na yeni bir eleman eklemek istiyorsak; bu y\u00f6ntemleri kullanabiliriz. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c insert_index := 2 fruits = append ( fruits [: insert_index ], append ([] string { banana }, fruits [ insert_index :] ... ) ... , ) fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49] {% hint style=\"warning\" %} Memory Concern sat\u0131rdaki append([]string{banana}, fruits[insert_index:]...) ****b\u00f6l\u00fcm\u00fc ba\u015fl\u0131 ba\u015f\u0131na bir slice olu\u015fturup, fruits[insert_index:] slice\u0131n\u0131n elemanlar\u0131n\u0131 bu slicea kopyal\u0131yor. Bu elemanlar daha sonra fruits slice\u0131na tekrar kopyalan\u0131yor. Yeni bir slice olu\u015fturulmas\u0131n\u0131n ve 2. kez kopyalama i\u015fleminin \u00f6n\u00fcne ge\u00e7ilebilir. {% endhint %} fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c insert_index := 2 fruits = append ( fruits , ) copy ( fruits [ insert_index + 1 :], fruits [ insert_index :]) fruits [ insert_index ] = banana fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf4c \ud83c\udf49]","title":"insert"},{"location":"tr/data-structures/#pop","text":"A\u015fa\u011f\u0131daki \u00f6rnekte slice\u0131n son eleman\u0131n\u0131 \u00e7\u0131kar\u0131p bir de\u011fi\u015fkene atad\u0131k. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } item , fruits := fruits [ len ( fruits ) - 1 ], fruits [: len ( fruits ) - 1 ] item // \ud83c\udf49 fruits // [\ud83c\udf4f \ud83c\udf4e]","title":"pop"},{"location":"tr/data-structures/#push-front-40unshift41","text":"Bu \u00f6rnekte yeni bir eleman\u0131 slice\u0131n ba\u015f\u0131na koyduk. fruits := [] string { \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana := \ud83c\udf4c fruits = append ([] string { banana }, fruits ... ) fruits // [\ud83c\udf4c \ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"push front (unshift)"},{"location":"tr/data-structures/#pop-front-40shift41","text":"Bu \u00f6rnekte de slice\u0131n ilk eleman\u0131n\u0131 \u00e7\u0131kar\u0131p bir de\u011fi\u015fkene atad\u0131k. fruits := [] string { \ud83c\udf4c , \ud83c\udf4f , \ud83c\udf4e , \ud83c\udf49 } banana , fruits := fruits [ 0 ], fruits [ 1 :] banana // \ud83c\udf4c fruits // [\ud83c\udf4f \ud83c\udf4e \ud83c\udf49]","title":"pop front (shift)"},{"location":"tr/data-structures/#map","text":"En s\u0131k kullan\u0131lan veri tiplerinden birisi de maplerdir. map unique anahtarlar\u0131, de\u011ferlerle e\u015fle\u015ftirebilen sonras\u0131nda bu anahtarla e\u015fle\u015ftirilen de\u011fere eri\u015filmesini sa\u011flayan yap\u0131lard\u0131r.","title":"Map"},{"location":"tr/data-structures/#tanmlama_1","text":"Mapler map[AnahtarTipi]De\u011ferTipi veya make(map[AnahtarTipi]De\u011ferTipi) \u015feklinde tan\u0131mlanabilir. var mymap = map [ string ] string {} mymap = make ( map [ string ] string )","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#deger-atama","text":"monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 1979 : Life of Brian , } monty_python_films_by_year [ 1983 ] = The Meaning of Life Atad\u0131\u011f\u0131m\u0131z de\u011ferlere, yine ayn\u0131 keyi kullanarak eri\u015febiliriz. film_name := monty_python_films_by_year [ 1983 ] film_name // The Meaning of Life Mapin bir eleman\u0131na eri\u015firken, eleman\u0131n mapde kay\u0131tl\u0131 olup olmad\u0131\u011f\u0131n\u0131 g\u00f6steren ek bir de\u011fere daha eri\u015febiliriz. film_name , registered := monty_python_films_by_year [ 2019 ] if ! registered { fmt . Println ( Monty python did not relase a film at 2019 ) } else { fmt . Println ( film_name ) }","title":"De\u011fer Atama"},{"location":"tr/data-structures/#dongu-ile-kullanma","text":"Map elemanlar\u0131na temelde 2 yolla eri\u015filebilir. For d\u00f6ng\u00fcs\u00fcnde tek de\u011fi\u015fken kullan\u0131p, keyler \u00fczerinden eri\u015ferek. monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 1979 : Life of Brian , 1983 : The Meaning of Life , } for year := range monty_python_films_by_year { film_name := monty_python_films_by_year [ year ] fmt . Println ( film_name , was released at , year ) } D\u00f6ng\u00fcde 2 de\u011fi\u015fken kullan\u0131p, hem anahtar hem de de\u011fere eri\u015ferek. for year , film_name := range monty_python_films_by_year { fmt . Println ( film_name , was released at , year ) } /* Monty Python and the Holy Grail was released at 1971 Life of Brian was released at 1979 The Meaning of Life was released at 1983 */","title":"D\u00f6ng\u00fc ile kullanma"},{"location":"tr/data-structures/#delete_1","text":"Mapdeki bir eleman\u0131 silmek i\u00e7in delete fonksiyonunu kullanabiliriz. monty_python_films_by_year := map [ string ] string { 1971 : Monty Python and the Holy Grail , 2016 : Batman v Superman , } delete ( monty_python_films_by_year , 2016 ) _ , registered := monty_python_films_by_year [ 2016 ] registered // false len ( monty_python_films_by_year ) // 1","title":"delete"},{"location":"tr/data-structures/#struct","text":"Structlar kullan\u0131c\u0131 taraf\u0131ndan tan\u0131mlanan ve farkl\u0131 t\u00fcrdeki verileri isimleri ile tutabilen veri yap\u0131lar\u0131d\u0131r.","title":"struct"},{"location":"tr/data-structures/#tanmlama_2","text":"Structlar a\u015fa\u011f\u0131daki yap\u0131da tan\u0131mlanabilir. type StructName struct { field fieldType } Struct\u0131n ayn\u0131 tipteki alanlar\u0131n\u0131 tek sat\u0131rda tan\u0131mlayabiliriz. type Film struct { name , director string imdb float32 release_year int } var new_film = Film {} new_film // { 0 0} Struct alanlar\u0131na ek olarak etiket de verebiliriz. type Film struct { Name string `json: film_name ` Director string `json: director_name ` Imdb float32 `json: imdb_score ` ReleaseYear int `json: year_of_release ` } Etiketler tip d\u00f6n\u00fc\u015f\u00fcm\u00fc ile \u00e7ok\u00e7a u\u011fra\u015fan ORMler ve serialization k\u00fct\u00fcphaneleri aras\u0131nda pop\u00fclerdir. Bu etiketlere reflect mod\u00fcl\u00fc ile eri\u015filebilir. f := Film {} t := reflect . TypeOf ( f ) for _ , f := range [] string { Name , Director , Imdb , ReleaseYear } { field , found := t . FieldByName ( f ) if ! found { continue } fmt . Println ( field . Tag . Get ( json )) } /* film_name director_name imdb_score year_of_release */","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#deger-atama_1","text":"Bir struct, parametreleri s\u0131ras\u0131yla verilerek olu\u015fturulabilir. new_film := Film { Mad Max: Fury Road , George Miller , 8.1 , 2015 } new_film // {Mad Max: Fury Road George Miller 8.1 2015} Benzer bi\u00e7imde, parametreleri ve alacaklar\u0131 de\u011ferleri : ayrac\u0131 ile belirterek de olu\u015fturulabilir. new_film := Film { Name : Ran , Director : Akira Kurosawa , Imdb : 8.2 , ReleaseYear : 1985 , } new_film // {Ran Akira Kurosawa 8.2 1985} Struct olu\u015ftururken baz\u0131 alanlar bo\u015f b\u0131rak\u0131l\u0131rsa; bu alanlar o veri tipinin bo\u015f de\u011ferleri ile tan\u0131mlan\u0131r. new_film := Film { name : Batman v Superman , director : Zack Snyder , release_year : 2016 , } new_film // {Batman v Superman Zack Snyder 0 2016}","title":"De\u011fer Atama"},{"location":"tr/data-structures/#anonymous-struct","text":"Baz\u0131 \u00f6zel durumlarda structlar\u0131 fonksiyon g\u00f6vdesi i\u00e7erisinde tan\u0131mlamam\u0131z gerekebilir. Bunu a\u015fa\u011f\u0131daki y\u00f6ntemle yapabiliriz. provider_config := struct { name string baseUrl string apiKey string }{ name : mapbox , baseUrl : https://api.mapbox.com/geocoding/v5/ , apiKey : 123asds123 , } provider_config // {mapbox https://api.mapbox.com/geocoding/v5/ 123asds123}","title":"Anonymous struct"},{"location":"tr/data-structures/#anonymous-fields","text":"Alan isimlerini belirtilmeden de struct tan\u0131mlanabilir. Bu tarz bir tan\u0131mlamada belirtilen veri tiplerinin birbirinden farkl\u0131 olmas\u0131 gerekir. type Item struct { string // code int // quantity float32 // price } item := Item { child-seat-1 , 5 , 20.1 , } item // {child-seat 5 20.1}","title":"Anonymous fields"},{"location":"tr/data-structures/#promoted-fields","text":"Bir struct ba\u015fka bir struct i\u00e7erisinde alan ismi verilmeden kullan\u0131labilir. Bu durumda i\u00e7erideki structa kendi ismiyle eri\u015filir. A\u015fa\u011f\u0131daki \u00f6rne\u011fi baz al\u0131rsak Page i\u00e7erisindeki Content e page.Content \u015feklinde eri\u015filebilir. type Content struct { body string size int } type Page struct { nextUrl string previousURL string Content } content := Content { body : h1 Hi /h1 , size : 11 , } page := Page { nextUrl : http://.../3 , previousURL : http://.../1 , Content : content , } page // {http://.../3 http://.../1 { h1 Hi /h1 11}} page . Content // { h1 Hi /h1 11}","title":"Promoted fields"},{"location":"tr/data-structures/#pointer","text":"Pointer bir ba\u015fka de\u011fi\u015fkenin memory adresini tutan bir de\u011fi\u015fkendir. \u00c7al\u0131\u015fma esnas\u0131nda yeni bir nesne olu\u015fturuldu\u011funda, bu nesneyi haf\u0131zada tutmam\u0131z gerekir. Nesne i\u00e7in haf\u0131zada ayr\u0131lan alan\u0131n yerini de\u011fi\u015fkenler ile tutar\u0131z.","title":"Pointer"},{"location":"tr/data-structures/#tanmlama_3","text":"Pointer da de\u011fi\u015fkenlerdir. Di\u011fer de\u011fi\u015fkenlerden fark\u0131 herhangi bir veriyi de\u011fil, o verinin yerini belirten de\u011fi\u015fkenin adresini tutmas\u0131d\u0131r. Pointerlar var pointer *Type yap\u0131s\u0131 kullan\u0131larak tan\u0131mlan\u0131r. De\u011fer atanmad\u0131\u011f\u0131 takdirde pointerin de\u011feri nil olarak belirlenir. var ptr * int ptr // nil Pointerlar\u0131 new fonksiyonunu kullanarak da tan\u0131mlayabiliriz. ptr := new ( int ) ptr // nil","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#deger-atama_2","text":"Pointera i\u015faretini kullanarak, bir ba\u015fka de\u011fi\u015flenin adresini, de\u011fer olarak atayabiliriz. * i\u015fareti ile pointeri kullanarak, i\u015faret etti\u011fi de\u011fi\u015fkene(dolay\u0131s\u0131yla tutulan veriye) eri\u015febiliriz. var carbon string = Carbon var ptrCarbon * string ptrCarbon = carbon ptrCarbon // 0xc000092030 * ptrCarbon // Carbon * ptrCarbon = Altered + * ptrCarbon carbon // Altered Carbon","title":"De\u011fer Atama"},{"location":"tr/data-structures/#fonksiyonlar","text":"Genel olarak GO'da fonksiyonlar a\u015fa\u011f\u0131daki yap\u0131da tan\u0131mlan\u0131r. func fonksiyon_ad\u0131 ( [ parametre listesi ] ) [ d\u00f6n\u00fc\u015f de\u011ferlerinin tipleri ] { fonksiyon g\u00f6vdesi } func sigmoid ( value float64 ) float64 { return 1.0 / ( 1.0 + math . Exp ( - value )) } sigmoid ( 0.5 ) // 0.62246","title":"Fonksiyonlar"},{"location":"tr/data-structures/#parametreler","text":"GO fonksiyonlar\u0131na parametre olarak girilen de\u011fi\u015fkenler kopyalan\u0131r. Bu nedenle parametreler \u00fczerinde yap\u0131lan de\u011fi\u015fiklikler de\u011fi\u015fkenlerin fonksiyon d\u0131\u015f\u0131ndaki durumlar\u0131n\u0131 etkilemez. type Wallet struct { userID int balance float64 deposit float64 } func withdraw ( wallet Wallet , amount float64 ) { wallet . balance -= amount } Yukar\u0131daki kodda basit\u00e7e bir c\u00fczdan yap\u0131s\u0131 ve bu c\u00fczdandan para \u00e7ekebilen withdraw fonksiyonu tan\u0131mlad\u0131k. A\u015fa\u011f\u0131daki sat\u0131rlarda da bir adet c\u00fczdan olu\u015fturup bu fonksiyon ile kulland\u0131k. wallet := Wallet { userID : 1 , balance : 30000.12 , deposit : 40000.01 , } item_price := 10023.0 withdraw ( wallet , item_price ) wallet . balance // 3000.12 G\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere c\u00fczdandaki para de\u011fi\u015fmedi. Bu tarz kazalar\u0131 2 yolla \u00f6nleyebiliriz. Y\u00f6ntem, c\u00fczdandaki son para durumunu d\u00f6nd\u00fcr\u00fcp, c\u00fczdan\u0131 sonradan g\u00fcncelleyebiliriz. func withdraw ( wallet Wallet , amount float64 ) float64 { new_balance := wallet . balance - amount return new_balance } wallet . balance = withdraw ( wallet , item_price ) wallet . balance // 19977.12 Bu de\u011fi\u015fim, i\u015fi c\u00fczdandan para \u00e7ekmek olan withdraw fonksiyonunun kullan\u0131m amac\u0131n\u0131 de\u011fi\u015ftirmi\u015f oluyor. Y\u00f6ntem, c\u00fczdan de\u011fi\u015fkeni yerine, c\u00fczdan\u0131n adresini parametre olarak verebiliriz. func withdraw ( wallet * Wallet , amount float64 ) { wallet . balance -= amount } withdraw ( wallet , item_price ) wallet . balance // 19977.12 Bu y\u00f6ntemin dezavantaj\u0131 da farkl\u0131 concurrency safe olmamas\u0131d\u0131r. Farkl\u0131 threadler ile c\u00fczdandan para \u00e7ekmek istedi\u011fimizde, bakiye durumunu takip etmek zor olacakt\u0131r.","title":"Parametreler"},{"location":"tr/data-structures/#dinamik-parametreler","text":"GO fonksiyonlar\u0131nda dinamik parametreler tan\u0131mlanabilir. Bu t\u00fcrdeki parametreleri tan\u0131mlamak i\u00e7in parametre tipinin \u00f6n\u00fcne ... i\u015fareti yaz\u0131l\u0131r. func ReLU ( nums ... float64 ) [] float64 { new_nums := make ([] float64 , len ( nums )) for idx , value := range nums { if value 0 { new_nums [ idx ] = value } else { new_nums [ idx ] = 0. } } return new_nums } nums := [] float64 { 1. , 0.2 , 0. , 0. , - 0.1 , 0.1 } nums = ReLU ( nums ... ) nums // [1 0.2 0 0 0 0.1]","title":"Dinamik parametreler"},{"location":"tr/data-structures/#donus-degerleri","text":"","title":"D\u00f6n\u00fc\u015f De\u011ferleri"},{"location":"tr/data-structures/#birden-fazla-deger-dondurme","text":"GO fonksiyonlar\u0131nda birden fazla de\u011fer d\u00f6nd\u00fcr\u00fclebilir. D\u00f6n\u00fclecek de\u011ferleri () aras\u0131nda s\u0131ras\u0131yla tan\u0131mlamak gerekmektedir. func swap ( first_arg , second_arg string ) ( string , string ) { return second_arg , first_arg } var language1 , language2 string = Python , GO language1 , language2 = swap ( language1 , language2 ) language1 , language2 // GO Python","title":"Birden fazla de\u011fer d\u00f6nd\u00fcrme"},{"location":"tr/data-structures/#donus-degerlerini-isimlendirme","text":"Fonksiyonlar\u0131n d\u00f6n\u00fc\u015f de\u011ferlerine isim verip, de\u011ferleri bu de\u011fi\u015fkenler ile belirleyebiliriz. \u0130simlendirilmi\u015f d\u00f6n\u00fc\u015f de\u011ferleri veri tipinin bo\u015f de\u011ferini alaca\u011f\u0131 i\u00e7in, fonksiyonun \u00f6n tan\u0131ml\u0131 d\u00f6n\u00fc\u015f de\u011ferleri olarak da kullan\u0131labilirler. type Record struct { id int data string } type DB struct { records [] Record locked bool } func BulkCreate ( records [] Record , db * DB ) ( n_created int , err error ) { if db . locked { err = errors . New ( DB is locked ) } else { db . records = append ( db . records , records ... ) n_created = len ( records ) } return n_created , err } db := DB { records : [] Record {}, locked : true , } data := [] Record {} for i := 0 ; i 100 ; i ++ { rec := Record { id : i , data : test , } data = append ( data , rec ) } n_created , err := BulkCreate ( data , db ) if err != nil { fmt . Println ( err ) }","title":"D\u00f6n\u00fc\u015f de\u011ferlerini isimlendirme"},{"location":"tr/data-structures/#anonim-fonksiyon","text":"GO'da fonksiyonlar da veri yap\u0131lar\u0131d\u0131r ve di\u011fer fonksiyonlar\u0131n i\u00e7erisinde tan\u0131mlanabilirler. Anonim fonksiyonlar\u0131, projenin k\u0131s\u0131tl\u0131 bir b\u00f6l\u00fcm\u00fcnde, spesifik bir i\u015fi halletmek i\u00e7in kullanabiliriz. A\u015fa\u011f\u0131daki kod \u00f6rne\u011finde, projenin ba\u015fka yerinde bu i\u015fleme ihtiya\u00e7 duymayaca\u011f\u0131m\u0131z\u0131 varsayarak, bir slice\u0131 belirlenen boyutta par\u00e7alayan bir anonim fonksiyon kulland\u0131k. records := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } batchSize := 3 batchedRecords := func ( data [] int , batchSize int ) [][] int { var batches [][] int for batchSize len ( data ) { data , batches = data [ batchSize :], append ( batches , data [ 0 : batchSize : batchSize ]) } batches = append ( batches , data ) return batches }( records , batchSize ) batchedRecords // [[0 1 2] [3 4 5] [6 7 8] [9]] Bu t\u00fcrdeki fonksiyonlar\u0131 bir de\u011fi\u015fkene atay\u0131p bir ka\u00e7 kez de kullanabiliriz. A\u015fa\u011f\u0131daki \u00f6rnekte spesifik bir APIden ayr\u0131 ayr\u0131 g\u00f6nderilen \u00fclke kodu ve telefon numaralar\u0131n\u0131 de\u011fi\u015fken olarak tan\u0131mlad\u0131\u011f\u0131m\u0131z fonksiyonla birle\u015ftirdik. type Vendor struct { name string countryCode string phone string } vendor := Vendor { name : Volswagen Group , countryCode : 1 , phone : 403120120 , } formatPhoneNumbers := func ( contact Vendor ) string { return + + contact . countryCode + contact . phone } formatPhoneNumbers ( vendor ) // +1403120120","title":"Anonim Fonksiyon"},{"location":"tr/data-structures/#metodlar","text":"GO dilinde di\u011fer nesne y\u00f6nelimli programlama dilleri gibi classlar ve kal\u0131t\u0131m yoktur. Fakat fonksiyonlara receiver denilen ek bir arg\u00fcman ekleyerek ile kendi olu\u015fturdu\u011fumuz tiplere fonksiyonlar\u0131 ba\u011flayabiliriz. B\u00f6ylece GO dilinde de nesne y\u00f6nelimli programlamaya benzer bir deneyim yakalanabilir. type Connection struct { host string port int timeOut int isClosed bool } func ( conn * Connection ) Close () { conn . isClosed = true fmt . Println ( Connection , conn . host + : + strconv . Itoa ( conn . port ), closed. ) } Yukar\u0131daki yap\u0131da Close fonksiyonuna normal bir fonksiyona ek olarak (conn *Connection) k\u0131sm\u0131n\u0131 ekledik. B\u00f6ylece a\u015fa\u011f\u0131daki \u00f6rnekte g\u00f6r\u00fcld\u00fc\u011f\u00fc gibi c.Close() \u015feklinde Connection tipi \u00fczerinden fonksiyona eri\u015febildik. c := Connection { host : 0.0.0.0 , port : 8080 , timeOut : 1 , isClosed : false , } c . Close () // Connection 0.0.0.0:8080 closed.","title":"Metodlar"},{"location":"tr/data-structures/#pointer-receiver-124-value-receiver","text":"Fonksiyon parametrelerinde oldu\u011fu gibi receiverlerde de yap\u0131n\u0131n de\u011feri ile mi yoksa memory adresi ile mi kullan\u0131laca\u011f\u0131na karar verilmelidir. Receiverlar\u0131 struct d\u0131\u015f\u0131ndaki tipler i\u00e7in de kullanabiliriz. type Iterable [] int func ( iterable * Iterable ) Append ( items ... int ) { * iterable = append ( * iterable , items ... ) } arr := Iterable { 1 , 2 } arr . Append ( 4 , 5 , 6 ) arr // [1 2 4 5 6]","title":"Pointer receiver | Value receiver"},{"location":"tr/data-structures/#error","text":"GOda kendi hata tiplerimizi olu\u015fturabiliriz. Bunun i\u00e7in olu\u015fturdu\u011fumuz tipin sadece Error methoduna sahip olmas\u0131 yeterlidir.","title":"Error"},{"location":"tr/data-structures/#tanmlama_4","text":"A\u015fa\u011f\u0131daki \u00f6rnekte HTTP kodunu ve hata nedenini belirten HTTPError ad\u0131nda yeni bir hata tan\u0131mlad\u0131k. type HTTPError struct { Status int Reason string } func ( e HTTPError ) Error () string { return fmt . Sprintf ( %v: %v , e . Status , e . Reason ) } func MakeRequest () error { return HTTPError { Status : 400 , Reason : Bad Request , } }","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#kullanm","text":"Fonksiyon \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda d\u00f6n\u00fclen hata de\u011ferinin nil olup olmad\u0131\u011f\u0131 kontrol edilerek buna g\u00f6re \u00f6nlemler al\u0131nabilir. err := MakeRequest () if err != nil { fmt . Println ( err ) }","title":"Kullan\u0131m"},{"location":"tr/data-structures/#interface","text":"Interfaceler bir objenin sahip olabilece\u011fi methodlar\u0131 belirten yap\u0131lard\u0131r. Bu nedenle interfaceler objelerin davran\u0131\u015f\u0131n\u0131 ifade eder. \u00d6rne\u011fin; bir dosyandan veri okunabilir veya dosyaya veri yaz\u0131labilir. Bir interface okuma ve yazma methodlar\u0131n\u0131 bar\u0131nd\u0131r\u0131yorsa ve dosya objesi bu methodlara sahipse dosyan\u0131n bu interfacei implement etti\u011fi s\u00f6ylenebilir. Interfacelerin as\u0131l amac\u0131 methodlar\u0131, ald\u0131klar\u0131 parametreleri ve d\u00f6n\u00fc\u015f de\u011ferlerini genel bir \u015fekilde tan\u0131mlayarak; ayn\u0131 davran\u0131\u015f\u0131 g\u00f6steren, fakat farkl\u0131 i\u015flerde kullan\u0131lan yap\u0131lar i\u00e7in ortak bir protokol olu\u015fturmakt\u0131r.","title":"Interface"},{"location":"tr/data-structures/#tanmlama_5","text":"GO dilinde interfaceler objelerle kapal\u0131 halde uygulan\u0131r. Ba\u015fka bir deyi\u015fle; bir tipin bir interfacei kulland\u0131\u011f\u0131n\u0131 belirtmek i\u00e7in, di\u011fer \u00e7o\u011fu nesne y\u00f6nelimli dillerde oldu\u011fu gibi, class File implements IO gibi deyimler kullanmam\u0131z gerekmez. GO ayn\u0131 metodlar\u0131 payla\u015fan interface ve tipler aras\u0131ndaki ili\u015fkiyi kendisi kurar. type IOInterface interface { Read () [] byte Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } type Socket struct { ip string port int buffer [] byte } func ( sock * Socket ) Read () [] byte { return sock . buffer } func ( sock * Socket ) Write ( stream [] byte ) int { sock . buffer = append ( sock . buffer , stream ... ) return len ( stream ) } file := File { name : test , } sock := Socket { ip : 0.0.0.0 , port : 21 , } data := [] byte ( data ) file . Write ( data ) sock . Write ( file . Read ()) string ( sock . Read () // data Yukar\u0131daki uygulamada Read ve Write metodlar\u0131n\u0131 tan\u0131mlayan IOInterface interfaceini ve bu methodlara sahip File ve Socket tiplerini tan\u0131mlad\u0131k.","title":"Tan\u0131mlama"},{"location":"tr/data-structures/#kullanm_1","text":"A\u015fa\u011f\u0131daki \u00f6rnekte Log methodu IOInterface interfaceini parametre olarak ald\u0131\u011f\u0131 i\u00e7in hangi veri tipinden geldi\u011fini \u00f6nemsemeden veriyi okuyup, i\u015fini yapabilir. type Logger struct { } func ( log * Logger ) Log ( io IOInterface ) { for _ , data := range io . Read () { fmt . Print ( string ( data )) } fmt . Println () } file := File { name : test , } sock := Socket { ip : 0.0.0.0 , port : 21 , } logger := Logger {} data := [] byte ( data ) file . Write ( data ) sock . Write ( file . Read ()) logger . Log ( file ) // data logger . Log ( sock ) // data","title":"Kullan\u0131m"},{"location":"tr/data-structures/#birden-fazla-interface-kullanma","text":"GO tipleri birden fazla interfacei implement edebilir. Bunun i\u00e7in interfacein belirtti\u011fi metodlara sahip olmalar\u0131 yeterlidir. type Reader interface { Read () [] byte } type Writer interface { Write ([] byte ) int } type File struct { name string content [] byte } func ( file * File ) Read () [] byte { return file . content } func ( file * File ) Write ( content [] byte ) int { file . content = append ( file . content , content ... ) return len ( content ) } var file Reader = File { name : test , content : [] byte ( data ), } var sock Writer = Socket { ip : 0.0.0.0 , port : 21 , } sock . Write ( file . Read ()) sock . buffer // sock.buffer undefined (type Writer has no field or method buffer","title":"Birden Fazla interface kullanma"},{"location":"tr/data-structures/#tip-donusumu","text":"s := sock .( * Socket ) string ( s . buffer ) // data D\u00f6n\u00fc\u015ft\u00fcrd\u00fc\u011f\u00fcm\u00fcz tipin o interfacei do\u011fru bir \u015fekilde implement edip etmedi\u011fini d\u00f6n\u00fc\u015f\u00fcm s\u0131ras\u0131nda alaca\u011f\u0131m\u0131z ek bir parametre ile kontrol edebiliriz. type Serializer interface { Serialize () } s , ok := sock .( Serializer ) s , ok // nil, false","title":"Tip d\u00f6n\u00fc\u015f\u00fcm\u00fc"},{"location":"tr/data-structures/#bos-interface","text":"Interfaceler de di\u011fer veri yap\u0131lar\u0131 gibi tiplerdir ve ayn\u0131 \u015fekilde kullan\u0131labilir. GO projelerinde bo\u015f interface; interface{} \u015feklinde tan\u0131mlan\u0131r. Hi\u00e7bir metodu olmad\u0131\u011f\u0131 i\u00e7in bo\u015f interfacein gereksinimleri b\u00fct\u00fcn tipler taraf\u0131ndan kar\u015f\u0131lan\u0131r. bo\u015f interfacein bu \u00f6zelli\u011fi, dinamik parametreler ve de\u011ferler tan\u0131mlamam\u0131za olanak tan\u0131r. type Booking struct { Provider string CustomerID string ExtraProviderParams interface {} } booking1 := Booking { Provider : ACL , CustomerID : customer-01a , ExtraProviderParams : map [ string ] interface {}{ Passengers : 4 , PaymentTime : after-booking , }, } booking2 := Booking { Provider : DCM , CustomerID : customer-03f , ExtraProviderParams : [] interface {}{ 4 , after-booking , }, } booking1 // {ACL customer-01a map[Passengers:4 PaymentTime:after-booking]} booking2 // {DCM customer-01a [4 after-booking]}","title":"Bo\u015f interface"},{"location":"tr/data-structures/#tip-kontrolu","text":"Interface tipleri switch yap\u0131s\u0131 ile kontrol edilebilir. A\u015fa\u011f\u0131daki \u00f6rnekte Stringify fonksiyonu interface{} tipinde parametre olarak alarak farkl\u0131 veri tiplerini fonksiyonda kullanmam\u0131za olanak sa\u011fl\u0131yor. Bu fonksiyonda int string ve float gelen de\u011ferleri tiplerine g\u00f6re kontrol edip belirledi\u011fimiz \u015fekilde stringe \u00e7evirece\u011fiz. func Stringify ( value interface {}) ( string , error ) { switch value .( type ) { case string : return value .( string ), nil case float32 , float64 : return fmt . Sprintf ( %.2f , value ), nil case int : return fmt . Sprintf ( %d , value ), nil default : return , errors . New ( Invalid type ) } } Stringify ( 12 ) // 12 Stringify ( 12.52312313 ) // 12.52 Stringify ( test ) // test","title":"Tip Kontrol\u00fc"},{"location":"tr/data-structures/#containers","text":"Hemen hemen her dilde standart hale gelmi\u015f ve programlarda \u00e7ok\u00e7a kullan\u0131lan baz\u0131 kompozit veri yap\u0131lar\u0131 vard\u0131r. Go bu yap\u0131lardan 3\u00fcn\u00fc bize container paketi i\u00e7inde haz\u0131r halde sunuyor.","title":"Containers"},{"location":"tr/data-structures/#list","text":"","title":"List"},{"location":"tr/data-structures/#heap","text":"Heap veri yap\u0131s\u0131, istedi\u011fimiz tipteki elemanlar\u0131 \u00f6ncelik s\u0131ras\u0131na g\u00f6re tutarak; \u00fczerilerinde i\u015flem yapmam\u0131z\u0131 sa\u011flar. Heap temelde bir interfacedir ve bir veri yap\u0131s\u0131n\u0131n heapi implement edebilmesi i\u00e7in Len , Less , Swap , Push ve Pop methodlar\u0131na sahip olmas\u0131 gerekir. \u00d6rnek olarak sadece int tipinde say\u0131lar\u0131 tutan bir slice olu\u015ftural\u0131m ve bunu slice\u0131 heap olarak kullanal\u0131m. type IntHeap [] int \u00d6ncelikle heap interfaceinin Len metodunu implement edelim. Slicelar\u0131n uzunlu\u011funu len fonksiyonuyla do\u011frudan alabildi\u011fimiz i\u00e7in bu metodu yazmam\u0131z \u00e7ok da zor olmayacak. func ( h IntHeap ) Len () int { return len ( h ) } \u015eimdi de heapdeki iki eleman\u0131 birbiriyle k\u0131yaslayan ve yerlerini de\u011fi\u015ftiren Less ve Swap metodlar\u0131n\u0131 tan\u0131mlayal\u0131m. func ( h IntHeap ) Less ( i , j int ) bool { return h [ i ] h [ j ] } func ( h IntHeap ) Swap ( i , j int ) { h [ i ], h [ j ] = h [ j ], h [ i ] } Son olarak eleman eklememizi ve \u00e7\u0131karmam\u0131z\u0131 sa\u011flayacak Push ve Pop metodlar\u0131n\u0131 yazal\u0131m. Bu methodlar, slice\u0131n uzunlu\u011funu etkiledi\u011fi i\u00e7in pointer receiver olarak tan\u0131mlanmas\u0131 gerekiyor. func ( h * IntHeap ) Push ( x interface {}) { * h = append ( * h , x .( int )) } func ( h * IntHeap ) Pop () interface {} { old := * h n := len ( old ) x := old [ n - 1 ] * h = old [ 0 : n - 1 ] return x } IntHeap, bir heapin olmay\u0131 gerektiren t\u00fcm \u00f6zelliklere sahip. Art\u0131k container/heap paketini kullanarak bu slice\u0131 heape \u00e7evirebiliriz. func main () { h := IntHeap { 2 , 1 , 5 } heap . Init ( h ) heap . Push ( h , 3 ) fmt . Printf ( minimum: %d\\n , ( * h )[ 0 ]) for h . Len () 0 { fmt . Printf ( %d , heap . Pop ( h )) } // Output: // minimum: 1 // 1 2 3 5 }","title":"Heap"},{"location":"tr/data-structures/#ring","text":"","title":"Ring"},{"location":"tr/data-structures/#ek-kaynaklar","text":"https://medium.com/rungo/structures-in-go-76377cc106a2 https://golangbot.com/arrays-and-slices/ https://blog.golang.org/go-slices-usage-and-internals https://gobyexample.com/slices https://medium.com/rungo/the-anatomy-of-slices-in-go-6450e3bb2b94 https://opensource.com/article/18/7/introduction-go-arrays-and-slices https://appliedgo.net/slices/ https://gobyexample.com/maps https://blog.golang.org/go-maps-in-action https://medium.com/rungo/the-anatomy-of-maps-in-go-79b82836838b https://github.com/Pungyeon/clean-go-article https://medium.com/rungo/error-handling-in-go-f0125de052f0 https://github.com/golang/go/wiki/SliceTricks https://gobyexample.com/variadic-functions https://github.com/emirpasic/gods https://github.com/avelino/awesome-go https://golangbot.com/pointers/ http://www.golang-book.com/books/intro/8 https://medium.com/rungo/the-anatomy-of-arrays-in-go-24429e4491b7 https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca https://medium.com/rungo/interfaces-in-go-ab1601159b3a https://medium.com/@dotronglong/interface-naming-convention-in-golang-f53d9f471593 https://yourbasic.org/golang/interfaces-explained/ https://medium.com/rungo/structures-in-go-76377cc106a2 https://talks.golang.org/2012/10things.slide#9 https://flaviocopes.com/go-empty-interface/ https://research.swtch.com/interfaces https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go","title":"Ek Kaynaklar"},{"location":"tr/unit-testing/","text":"Unit Testing Code without tests is broken as designed. Jacob Kaplan-Moss Giri\u015f Unit testing, projedeki fonksiyonel her bir birimin t\u00fcm davran\u0131\u015flar\u0131n\u0131n test edildi\u011fi yaz\u0131l\u0131m test y\u00f6ntemidir. Biraz daha a\u00e7mak gerekirse; bir birim, testi m\u00fcmk\u00fcn olan en k\u00fc\u00e7\u00fck yaz\u0131l\u0131m bile\u015fenidir ve \u00e7o\u011funlukla tek bir i\u015f, yapmakla g\u00f6revlidir. Unit testin amac\u0131, program\u0131n k\u00fc\u00e7\u00fck b\u00f6l\u00fcmlere ay\u0131r\u0131p, t\u00fcm b\u00f6l\u00fcmlerin beklenildi\u011fi gibi \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131ndan emin olmakt\u0131r. Unit testleri yaz\u0131lan bir projede: Projeye yeni eklenen kodun, istenildi\u011fi gibi \u00e7al\u0131\u015f\u0131p, \u00e7al\u0131\u015fmad\u0131\u011f\u0131n\u0131 kontrol edilebilir. Varolan kod d\u00fczenlendi\u011finde, projenin davran\u0131\u015f\u0131n\u0131n beklenmedik \u015fekilde de\u011fi\u015ftirmedi\u011finden emin olunur. Yaz\u0131l\u0131mc\u0131, projeye eklenecek karma\u015f\u0131k \u00f6zellikleri k\u00fc\u00e7\u00fck, anla\u015f\u0131l\u0131r par\u00e7alara b\u00f6lmesine dolay\u0131s\u0131yla i\u015fe yarar minimum fonksiyonelli\u011fe h\u0131zl\u0131ca eri\u015fip gereksiz optimizasyondan ka\u00e7\u0131nmas\u0131na yard\u0131mc\u0131 olur. Ekibe yeni kat\u0131lan yaz\u0131l\u0131mc\u0131lar, testleri d\u00f6k\u00fcman olarak kullanabilir. Testlerin bir projedeki b\u00fct\u00fcn hatalar\u0131 \u00e7\u00f6zmesi beklenmemelidir. Projelerde her zaman hata vard\u0131r. Bu hatalar, test edilmeyen bir durumdan, yanl\u0131\u015f test etmekten veya testlerin kontrol edemeyece\u011fi 3. parti k\u00fct\u00fcphanelerden, APIlerden, konfig\u00fcrasyon sorunlar\u0131nlar\u0131nda kaynakl\u0131 olabilir. Test etmek package main import fmt func main () { fmt . Println ( Hello, world ) } Yukar\u0131daki kodu test etmeden \u00f6nce yan etkilerden ar\u0131nd\u0131rmal\u0131y\u0131z. Buradaki side-effect Println fonksiyonu. package main import fmt func Hello () string { return Hello, world } func main () { fmt . Println ( Hello ()) } \u015eimdi Hello fonksiyonunu i\u00e7in test yazal\u0131m. func TestHello ( t * testing . T ) { got := Hello () want := Hello, world if got != want { t . Errorf ( got %q want %q , got , want ) } } Go testlerini \u00e7al\u0131\u015ft\u0131rmak i\u00e7in ek ara\u00e7lara veya frameworklere ihtiyac\u0131m\u0131z yok. Sadece go test komutu ile yazd\u0131\u011f\u0131m\u0131z testleri \u00e7al\u0131\u015ft\u0131rabiliriz. Test yazman\u0131n belirli kurallar \u00e7er\u00e7evesinde fonksiyonlar yazmaktan fark\u0131 yoktur. Bu fonksiyonlar\u0131n test olarak kabul edilmesi i\u00e7in: xxx_test.go gibi bir dosya i\u00e7inde olmas\u0131 Fonksiyon isminin Test ile ba\u015flamas\u0131 Fonksiyonun yaln\u0131zca t *testing.T parametresini almas\u0131 gerekir. Yeni \u00d6zellikler Eklemek Test ba\u015far\u0131l\u0131 bir \u015fekilde \u00e7al\u0131\u015ft\u0131\u011f\u0131na g\u00f6re art\u0131k uygulamaya yeni \u00f6zellikler ekleyebiliriz. \u015eimdi Hello fonksiyonu parametre olarak bir isim als\u0131n ve o ismi selamlas\u0131n. Bunun i\u00e7in \u00f6ncellikle kodun yeni halini test eden ve ba\u015far\u0131s\u0131z olan bir test yazaca\u011f\u0131z. func TestHello ( t * testing . T ) { got := Hello ( Mehmet ) want := Hello, Mehmet if got != want { t . Errorf ( got %q want %q , got , want ) } } Testi ge\u00e7irecek kadar kod yazal\u0131m. func Hello ( name string ) string { return Hello, Mehmet } Yukar\u0131daki \u00f6rnekte amac\u0131m\u0131z\u0131n d\u0131\u015f\u0131nda bir kod yazarak testin ge\u00e7mesini sa\u011flad\u0131k. Bu \u00f6rnek her ne kadar abes dursada, bu t\u00fcr durumlar daha b\u00fcy\u00fck \u00f6l\u00e7ekli i\u015flerde ba\u015f\u0131m\u0131za gelebilir ve fark edilmedi\u011finde anla\u015f\u0131lmas\u0131 zor buglar ortaya \u00e7\u0131kartabilir. Ekledi\u011fimiz \u00f6zelli\u011fin d\u00fczg\u00fcn \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan emin olmak i\u00e7in bir test daha ekleyelim. func TestHello ( t * testing . T ) { got := Hello ( Mehmet ) want := Hello, Mehmet if got != want { t . Errorf ( got %q want %q , got , want ) } } func TestHelloWithAnotherName ( t * testing . T ) { got := Hello ( Ahmet ) want := Hello, Ahmet if got != want { t . Errorf ( got %q want %q , got , want ) } } \u015eimdi de testi ge\u00e7ecek kodu yazal\u0131m. func Hello ( name string ) string { return Hello, + name } Bu a\u015famada elimizde testleri ile birlikte \u00e7al\u0131\u015fan yeni \u00f6zelli\u011fi commit edebiliriz. Bu a\u015famada, TDD ya\u015fam d\u00f6ng\u00fcs\u00fc gere\u011fi kod refactor edilmeye \u00e7al\u0131\u015f\u0131l\u0131r. \"Hello, \" her durumda sabit oldu\u011fu i\u00e7in globalde tan\u0131mlayabiliriz. const englishHelloPrefix = Hello, func Hello ( name string ) string { return englishHelloPrefix + name } Refactor yap\u0131ld\u0131ktan sonra mutlaka testler yeniden \u00e7al\u0131\u015ft\u0131r\u0131lmal\u0131 ve kod davran\u0131\u015f\u0131n\u0131n de\u011fi\u015fmedi\u011finden emin olunmal\u0131d\u0131r. \u015eimdi uygulamam\u0131za bir \u00f6zellik daha ekleyelim. Bu kez Hello fonksiyonuna bo\u015f isim verilince \u00f6n tan\u0131ml\u0131 mesajla selamlas\u0131n. Tabiki \u00f6nce testini yaz\u0131yoruz. Ayn\u0131 kod par\u00e7as\u0131 i\u00e7in yaz\u0131lan testleri tek fonksiyon alt\u0131nda toplayabiliriz. t.Run yap\u0131s\u0131 sayesinde verdi\u011fimiz farkl\u0131 test mesajlar\u0131 ile birlikte testleri bir araya getirebiliriz. func TestHello ( t * testing . T ) { t . Run ( Say hello to a specific name , func ( t * testing . T ) { got := Hello ( Mehmet ) want := Hello, Mehmet if got != want { t . Errorf ( got %q want %q , got , want ) } }) t . Run ( Say Hello, Dude when an empty string is provided , func ( t * testing . T ) { got := Hello ( ) want := Hello, Dude if got != want { t . Errorf ( got %q want %q , got , want ) } }) } Refactoring sadece business logic i\u00e7eren kodlar i\u00e7in de\u011fildir. Test kodlar\u0131na da projede t\u0131pk\u0131 di\u011fer kodlar gibi yakla\u015f\u0131lmal\u0131d\u0131r. Bu a\u015famada testlerimizde tekrar eden k\u0131s\u0131mlar i\u00e7in bir fonksiyon yazabiliriz. func TestHello ( t * testing . T ) { assertCorrectMessage := func ( t * testing . T , got , want string ) { t . Helper () if got != want { t . Errorf ( got %q want %q , got , want ) } } t . Run ( Say hello to a specific name , func ( t * testing . T ) { got := Hello ( Mehmet ) want := Hello, Mehmet assertCorrectMessage ( t , got , want ) }) t . Run ( Say Hello, Dude when an empty string is provided , func ( t * testing . T ) { got := Hello ( ) want := Hello, Dude assertCorrectMessage ( t , got , want ) }) } \u015eimdi elimizde d\u00fczg\u00fcn bir \u015fekilde yaz\u0131lm\u0131\u015f hata veren bir test var. Uygulamaya testi ge\u00e7mek i\u00e7in yeterli kodu yazal\u0131m. const englishHelloPrefix = Hello, func Hello ( name string ) string { if name == { name = Dude } return englishHelloPrefix + name } B\u00f6ylece uygulamam\u0131za \u00f6nceki \u00f6zellikleri etkilemeden yeni bir \u00f6zellik eklemi\u015f olduk. Bu a\u015famada eski commiti amend edip, fonksiyonumuzu yeni versiyonu ile de\u011fi\u015ftirebiliriz. Geli\u015ftirme Disiplini Yeni \u00f6zelli\u011fi kullanan bir test yaz Kodun derlendi\u011finden emin ol Testi \u00e7al\u0131\u015ft\u0131r, hatay\u0131 g\u00f6zlemle Testi ge\u00e7irecek minimum kodu yaz Refactor Bu kadar ad\u0131m zahmetli ve paranoyak\u00e7a gelebilir fakat her ad\u0131mda kodun durumunu kontrol etmek olduk\u00e7a \u00f6nemlidir. Bu disipline sad\u0131k kalarak sadece amac\u0131na uygun testler yazmakla kalmay\u0131z ayn\u0131 zamanda otomatikle\u015ftirilmi\u015f testlerle s\u00fcrekli d\u00fczenlenen ve iyi \u015fekilde tasarlanan bir yaz\u0131l\u0131m geli\u015ftirmi\u015f oluruz. Testlerin ne i\u00e7in yaz\u0131ld\u0131\u011f\u0131n\u0131 anla\u015f\u0131l\u0131r bir \u015fekilde hata mesaj\u0131nda g\u00f6stermek \u00e7ok \u00f6nemlidir. Yaz\u0131l\u0131mc\u0131n\u0131n, testin neden hata verdi\u011fini anlayamamas\u0131 problemi \u00e7\u00f6zmeyi zorla\u015ft\u0131racakt\u0131r. Testlerin h\u0131zl\u0131 \u00e7al\u0131\u015fmas\u0131 ve kolay bir \u015fekilde \u00e7al\u0131\u015ft\u0131r\u0131labilmesi gerekir. Bu ak\u0131c\u0131 bir \u015fekilde kod yazmam\u0131z\u0131 sa\u011flayacakt\u0131r. Testsiz kod yazarak, uygulaman\u0131n ak\u0131\u015f\u0131n\u0131 ve olas\u0131 her durumunu kontrol etme i\u015fini kendinize y\u00fcklemi\u015f olursunuz. Bu da uzun d\u00f6nemde ciddi vakit kayb\u0131na yol a\u00e7acakt\u0131r. Daha fazla \u00f6zellik Yeni iste\u011fe g\u00f6re uygulamam\u0131za dil deste\u011fi ekleyece\u011fiz. E\u011fer dil sistemimiz taraf\u0131ndan destekleniyorsa selamlama mesaj\u0131 verilen dilde sa\u011flanacak. Desteklenmiyorsa \u00f6n tan\u0131ml\u0131 olan \u0130ngilizce mesaj g\u00f6nderilecek. Ba\u015flang\u0131\u00e7 olarak Frans\u0131zca dil deste\u011fi i\u00e7in test yazal\u0131m. t . Run ( in French , func ( t * testing . T ) { got := Hello ( Lara Fabian , French ) want := Bonjour, Lara Fabian assertCorrectMessage ( t , got , want ) }) Bu haliyle Hello tek parametre ald\u0131\u011f\u0131 i\u00e7in compiler hata verecektir. Bu ad\u0131mda, hile yap\u0131p do\u011frudan kodu yazmaktan ka\u00e7\u0131nmal\u0131y\u0131z. Fonksiyona gerekli olan 2. parametreyi ekleyelim. func Hello ( name string , language string ) string { if name == { name = Dude } return englishHelloPrefix + name } Testleri \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda, yeni \u00f6zelli\u011fe g\u00f6re tasarlanmad\u0131\u011f\u0131 i\u00e7in eski testler hata verecektir. Eski testlere parametre olarak bo\u015f string vererek compiler hatas\u0131ndan kurtulal\u0131m. Bu durumda, sadece yeni ekledi\u011fimiz testin fail olmas\u0131 gerekir. \u015eimdi response bodyi Yeni bir if ekleyerek Frans\u0131zca i\u00e7in yazd\u0131\u011f\u0131m\u0131z testi ge\u00e7ebiliriz. func Hello ( name string , language string ) string { if name == { name = Dude } if language == French { return Bonjour, + name } return englishHelloPrefix + name } Bu haliyle b\u00fct\u00fcn testleri ba\u015far\u0131l\u0131 olmas\u0131 gerekiyor. \u015eimdi kodumuzu refactor edebiliriz. \u0130\u015fe, kod i\u00e7inde tan\u0131ml\u0131 stringlerden ba\u015flayabiliriz. Yap\u0131lan her de\u011fi\u015fiklikte testlerin ba\u015far\u0131l\u0131 oldu\u011funu kontrol etmeliyiz. const french = French const englishHelloPrefix = Hello, const frenchHelloPrefix = Bonjour, func Hello ( name string , language string ) string { if name == { name = Dude } if language == french { return frenchHelloPrefix + name } return englishHelloPrefix + name } Yeni dil \u015eimdi Koreceye de destek verelim. Bunun i\u00e7in daha \u00f6nce yapt\u0131\u011f\u0131m\u0131z gibi: Korean yazd\u0131\u011f\u0131m\u0131zda \uc548\ub155 ile ba\u015flayan bir mesaj bekleyen test yazaca\u011f\u0131z Testi \u00e7al\u0131\u015ft\u0131r\u0131p hata alaca\u011f\u0131z ve hata mesaj\u0131n\u0131n d\u00fczg\u00fcn oldu\u011funa dikkat edece\u011fiz Kod \u00fczerinde testi ge\u00e7ecek minimum de\u011fi\u015fikli\u011fi yapaca\u011f\u0131z De\u011fi\u015fikliklerden sonra elimizde a\u015fa\u011f\u0131 yukar\u0131 b\u00f6yle bir kod olacak: func TestHello ( t * testing . T ) { assertCorrectMessage := func ( t * testing . T , got , want string ) { t . Helper () if got != want { t . Errorf ( got %q want %q , got , want ) } } t . Run ( Say hello to a specific name , func ( t * testing . T ) { got := Hello ( Mehmet , ) want := Hello, Mehmet assertCorrectMessage ( t , got , want ) }) t . Run ( Say Hello, Dude when an empty string is provided , func ( t * testing . T ) { got := Hello ( , ) want := Hello, Dude assertCorrectMessage ( t , got , want ) }) t . Run ( in French , func ( t * testing . T ) { got := Hello ( Lara Fabian , French ) want := Bonjour, Lara Fabian assertCorrectMessage ( t , got , want ) }) t . Run ( in Korean , func ( t * testing . T ) { got := Hello ( \uc138\uc0c1 , Korean ) want := \uc548\ub155 \uc138\uc0c1 assertCorrectMessage ( t , got , want ) }) } const french = French const korean = Korean const englishHelloPrefix = Hello, const frenchHelloPrefix = Bonjour, const koreanHelloPrefix = \uc548\ub155 func Hello ( name string , language string ) string { if name == { name = Dude } if language == french { return frenchHelloPrefix + name } if language == korean { return koreanHelloPrefix + name } return englishHelloPrefix + name } Yeni \u00f6zelli\u011fimizi, \u00e7al\u0131\u015fan testi ile ekledi\u011fimize g\u00f6re \u015fimdi kodumuzu refactor edebiliriz. func Hello ( name string , language string ) string { if name == { name = Dude } prefix := englishHelloPrefix switch language { case french : prefix = frenchHelloPrefix case korean : prefix = koreanHelloPrefix } return prefix + name } Real World Example Ger\u00e7ek bir uygulamaya testlerin nas\u0131l yaz\u0131ld\u0131\u011f\u0131n\u0131 incelemek i\u00e7in https://randomuser.me/api/ APIsinden kullan\u0131c\u0131lar\u0131 \u00e7eken bir HTTP Client yazal\u0131m. UserClient yap\u0131s\u0131 ile, verilerin \u00e7ekilece\u011fi URLi, ka\u00e7 sayfa veri \u00e7ekece\u011fini ve her sayfada ne kadar veri alaca\u011f\u0131 ve de HTTP isteklerinin at\u0131laca\u011f\u0131 k\u00fct\u00fcphane belirliyoruz. type UserClient struct { BaseUrl string TaskCount , ResultPerPage int } uc := UserClient { BaseUrl : https://randomuser.me/api/ , TaskCount : 20 , ResultPerPage : 100 , requester : http . Client {}, } user , _ := uc . Get () users , _ := uc . FetchAll () fmt . Println ( len ( res )) // 2000 Mocking Unit testlerin \u00e7al\u0131\u015ft\u0131\u011f\u0131 ortamdan, d\u0131\u015f kaynaklardan ve k\u00fct\u00fcphanelerden ba\u011f\u0131ms\u0131z olmas\u0131 gerekir. Bu y\u00fczden http.Client ayn\u0131 davran\u0131\u015f\u0131 sergileyen fakat sahte veri d\u00f6nen ba\u015fka bir mod\u00fcl ile de\u011fi\u015ftirilmeli. Ortak davran\u0131\u015flara sahip mod\u00fcller geli\u015ftirmenin en kolay yolu ortak interface kullanmak. http.Clientin kullanaca\u011f\u0131m\u0131z methodlar\u0131na sahip Requester ad\u0131nda bir interface tan\u0131mlayal\u0131m. type Requester interface { Get ( url string ) ( resp * http . Response , err error ) } type UserClient struct { BaseUrl string TaskCount , ResultPerPage int requester Requester } func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { } func ( d * UserClient ) FetchAll () ( result [] map [ string ] interface {}, err error ) { } Testleri \u00e7al\u0131\u015ft\u0131r\u0131rken kullanaca\u011f\u0131m\u0131z, http.Client gibi Requesteri implement eden sahte bir client olu\u015ftural\u0131m ve FakeClient\u0131 kullanarak UserClient i\u00e7in bir test yazal\u0131m. type FakeClient struct { Body [] byte Error error } func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } func TestGetUser ( t * testing . T ) { userclient := UserClient {} t . Run ( get userclient returns err on bad response , func ( t * testing . T ) { userclient . requester = FakeClient { Error : errors . New ( Bad Request ), } _ , err := userclient . Get () if err == nil { t . Error ( Expected to get an error ) } }) } http.Clienti, sahtesi ile a\u015fa\u011f\u0131daki \u015fekilde de\u011fi\u015ftirdik. userclient . requester = FakeClient { Body : [] byte ( `{ status : ok }` ), } FakeClient ald\u0131\u011f\u0131 Body verisini Get methodu \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda bize http.Clientinkine benzer \u015fekilde d\u00f6necek. func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } Art\u0131k elimizde fail olan bir test var. Bu testi ge\u00e7ecek kodu yazabiliriz. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { err := erros . New ( Error ) return } \u015eimdi de response bodyi kontrol eden bir test yazal\u0131m. t . Run ( get userclient returns err if response body invalid , func ( t * testing . T ) { userclient . requester = FakeClient {} _ , err := userclient . Get () if err == nil { t . Error ( Expected to get an error ) } }) Art\u0131k testi ge\u00e7mek i\u00e7in kod yazabiliriz. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( %s?results=%d , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } } Son olarak ba\u015far\u0131l\u0131 response durumunu test edelim. t . Run ( get userclient returns unmarshalled response body on success , func ( t * testing . T ) { userclient . requester = FakeClient { Body : [] byte ( `{ status : ok }` ), } got , _ := userclient . Get () want := map [ string ] interface {}{ status : ok , } if ! reflect . DeepEqual ( got , want ) { t . Errorf ( got %q want %q , got , want ) } }) Art\u0131k byte JSONu d\u00fczg\u00fcnce parse eden bir kod yazmam\u0131z gerekiyor. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( %s?results=%d , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } defer res . Body . Close () buf := new ( bytes . Buffer ) buf . ReadFrom ( res . Body ) newStr := buf . String () var data map [ string ] interface {} err = json . Unmarshal ([] byte ( newStr ), data ) response = data return } Table Test Kod tekrar\u0131n\u0131 azaltmak i\u00e7in table driven test y\u00f6ntemini kullanabiliriz. func TestFetchAll ( t * testing . T ) { testCases := [] struct { name string client * UserClient expected [] map [ string ] interface {} }{ { get userclient returns err on bad response , UserClient { ResultPerPage : 1 , TaskCount : 0 , requester : FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), }, }, [] map [ string ] interface {}{}, }, { get userclient returns err if response body invalid , UserClient { ResultPerPage : 0 , TaskCount : 1 , requester : FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), }, }, [] map [ string ] interface {}{}, }, { get userclient returns unmarshalled response body on success , UserClient { ResultPerPage : 0 , TaskCount : 1 , requester : FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), }, }, [] map [ string ] interface {}{}, }, } for _ , tt := range testCases { t . Run ( tt . name , func ( t * testing . T ) { got , _ := tt . client . FetchAll () if ! reflect . DeepEqual ( got , tt . expected ) { t . Errorf ( got %q want %q , got , tt . expected ) } }) } } Anti-Patternler \u0130kinci S\u0131n\u0131f Vatanda\u015fl\u0131k D i\u011fer kodlar\u0131 yazarken uygulad\u0131\u011f\u0131m\u0131z yaz\u0131l\u0131m prensipleri test kodlar\u0131 i\u00e7in de ge\u00e7erli. Obsessive Coverage Test coverage\u0131n y\u00fcksek olmas\u0131, projenin b\u00fct\u00fcn durumlar\u0131n\u0131n test edildi\u011fini g\u00f6stermez. Bir projenin d\u00fczg\u00fcn test edildi\u011finin g\u00f6stergesi sadece coverage raporlar\u0131 de\u011fildir. Structural Inspection Projede structlar\u0131n, ve di\u011fer veri yap\u0131lar\u0131n\u0131n ald\u0131klar\u0131 de\u011ferleri de\u011fil methodlar\u0131 ve fonksiyonlar\u0131n davran\u0131\u015flar\u0131n\u0131 test etmeliyiz. God Object Test edilmesi zor, b\u00fcy\u00fck yap\u0131lar par\u00e7alanmal\u0131d\u0131r. E\u011fer test etti\u011fimiz kod \u00e7ok fazla mock kulland\u0131r\u0131yorsa bu God Objectin belirtisi olabilir. Mockery Testlerde a\u015f\u0131r\u0131 mock kullan\u0131m\u0131, uygulama davran\u0131\u015f\u0131n\u0131 de\u011fil mockerlar\u0131n de\u011ferlerini test etmemizle sonu\u00e7lan\u0131r. Instance Reuse Test edilen yap\u0131lar, \u00e7al\u0131\u015ft\u0131r\u0131lan her test i\u00e7in yeniden \u00fcretilmelidir. Local Hero Testler \u00e7al\u0131\u015ft\u0131\u011f\u0131 ortamdan ve makineden ba\u011f\u0131ms\u0131z olmal\u0131d\u0131r. Happy Path Testing Uygulamada sadece ba\u015far\u0131l\u0131 sonu\u00e7lar\u0131 de\u011fil, olas\u0131 b\u00fct\u00fcn durumlar\u0131 test etmeliyiz. K\u00f6t\u00fc \u0130simlendirme (S\u0131ral\u0131 \u0130simlendirme) Testlerin isimleri ve mesajlar\u0131 a\u00e7\u0131klay\u0131c\u0131 ve ay\u0131rt edici olmal\u0131d\u0131r. Yeni Test Yerine Assertion Ekleme Birime yeni \u00f6zellik eklendi\u011finde, veya bir k\u0131sm\u0131 de\u011fi\u015ftirildi\u011finde var olan bir teste ekstra bir kontrol eklenmemelidir. Sadece bu durumu yeni bir test yaz\u0131lmal\u0131d\u0131r. package main import ( bytes encoding/json fmt net/http ) type Requester interface { Get ( url string ) ( resp * http . Response , err error ) } type UserClient struct { BaseUrl string TaskCount , ResultPerPage int requester Requester } func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( %s?results=%d , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } defer res . Body . Close () buf := new ( bytes . Buffer ) buf . ReadFrom ( res . Body ) newStr := buf . String () var data map [ string ] interface {} err = json . Unmarshal ([] byte ( newStr ), data ) response = data return } func ( d * UserClient ) FetchAll () ( result [] map [ string ] interface {}, err error ) { ch1 := make ( chan map [ string ] interface {}, 1 ) expectedCount := d . TaskCount * d . ResultPerPage result = [] map [ string ] interface {}{} if d . TaskCount == 0 || d . ResultPerPage == 0 { return } for i := 0 ; i d . TaskCount ; i ++ { go func ( ch chan map [ string ] interface {}) { response , err := d . Get () if err != nil { for j := 0 ; j d . ResultPerPage ; j ++ { ch - map [ string ] interface {}{} } } else { data := response [ results ].([] interface {}) for _ , datum := range data { ch - datum .( map [ string ] interface {}) } } }( ch1 ) } for data := range ch1 { result = append ( result , data ) if len ( result ) == expectedCount { close ( ch1 ) } } return result , nil } func main () { uc := UserClient { BaseUrl : https://randomuser.me/api/ , TaskCount : 20 , ResultPerPage : 100 , requester : http . Client {}, } res , _ := uc . FetchAll () fmt . Println ( len ( res )) } package main import ( bytes errors io/ioutil net/http reflect testing ) type FakeClient struct { Body [] byte Error error } func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } func TestGetUser ( t * testing . T ) { userclient := UserClient {} t . Run ( get userclient returns err on bad response , func ( t * testing . T ) { userclient . requester = FakeClient { Error : errors . New ( Bad Request ), } _ , err := userclient . Get () if err == nil { t . Error ( Expected to get an error ) } }) t . Run ( get userclient returns err if response body invalid , func ( t * testing . T ) { userclient . requester = FakeClient {} _ , err := userclient . Get () if err == nil { t . Error ( Expected to get an error ) } }) t . Run ( get userclient returns unmarshalled response body on success , func ( t * testing . T ) { userclient . requester = FakeClient { Body : [] byte ( `{ status : ok }` ), } got , _ := userclient . Get () want := map [ string ] interface {}{ status : ok , } if ! reflect . DeepEqual ( got , want ) { t . Errorf ( got %q want %q , got , want ) } }) } func TestFetchAll ( t * testing . T ) { t . Run ( fetchall returns empty list if task count is 0 , func ( t * testing . T ) { userclient := UserClient { ResultPerPage : 1 , TaskCount : 0 , } userclient . requester = FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), } got , _ := userclient . FetchAll () want := [] map [ string ] interface {}{} if ! reflect . DeepEqual ( got , want ) { t . Errorf ( got %q want %q , got , want ) } }) t . Run ( fetchall returns empty list if per page is 0 , func ( t * testing . T ) { userclient := UserClient { ResultPerPage : 0 , TaskCount : 1 , } userclient . requester = FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), } got , _ := userclient . FetchAll () want := [] map [ string ] interface {}{} if ! reflect . DeepEqual ( got , want ) { t . Errorf ( got %q want %q , got , want ) } }) t . Run ( fetchall returns the same amount of records with item count , func ( t * testing . T ) { userclient := UserClient { TaskCount : 5 , ResultPerPage : 2 , } userclient . requester = FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), } res , _ := userclient . FetchAll () got := len ( res ) want := 10 if got != want { t . Errorf ( got %d want %d , got , want ) } }) }","title":"Unit Testing"},{"location":"tr/unit-testing/#unit-testing","text":"Code without tests is broken as designed. Jacob Kaplan-Moss","title":"Unit Testing"},{"location":"tr/unit-testing/#giris","text":"Unit testing, projedeki fonksiyonel her bir birimin t\u00fcm davran\u0131\u015flar\u0131n\u0131n test edildi\u011fi yaz\u0131l\u0131m test y\u00f6ntemidir. Biraz daha a\u00e7mak gerekirse; bir birim, testi m\u00fcmk\u00fcn olan en k\u00fc\u00e7\u00fck yaz\u0131l\u0131m bile\u015fenidir ve \u00e7o\u011funlukla tek bir i\u015f, yapmakla g\u00f6revlidir. Unit testin amac\u0131, program\u0131n k\u00fc\u00e7\u00fck b\u00f6l\u00fcmlere ay\u0131r\u0131p, t\u00fcm b\u00f6l\u00fcmlerin beklenildi\u011fi gibi \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131ndan emin olmakt\u0131r. Unit testleri yaz\u0131lan bir projede: Projeye yeni eklenen kodun, istenildi\u011fi gibi \u00e7al\u0131\u015f\u0131p, \u00e7al\u0131\u015fmad\u0131\u011f\u0131n\u0131 kontrol edilebilir. Varolan kod d\u00fczenlendi\u011finde, projenin davran\u0131\u015f\u0131n\u0131n beklenmedik \u015fekilde de\u011fi\u015ftirmedi\u011finden emin olunur. Yaz\u0131l\u0131mc\u0131, projeye eklenecek karma\u015f\u0131k \u00f6zellikleri k\u00fc\u00e7\u00fck, anla\u015f\u0131l\u0131r par\u00e7alara b\u00f6lmesine dolay\u0131s\u0131yla i\u015fe yarar minimum fonksiyonelli\u011fe h\u0131zl\u0131ca eri\u015fip gereksiz optimizasyondan ka\u00e7\u0131nmas\u0131na yard\u0131mc\u0131 olur. Ekibe yeni kat\u0131lan yaz\u0131l\u0131mc\u0131lar, testleri d\u00f6k\u00fcman olarak kullanabilir. Testlerin bir projedeki b\u00fct\u00fcn hatalar\u0131 \u00e7\u00f6zmesi beklenmemelidir. Projelerde her zaman hata vard\u0131r. Bu hatalar, test edilmeyen bir durumdan, yanl\u0131\u015f test etmekten veya testlerin kontrol edemeyece\u011fi 3. parti k\u00fct\u00fcphanelerden, APIlerden, konfig\u00fcrasyon sorunlar\u0131nlar\u0131nda kaynakl\u0131 olabilir.","title":"Giri\u015f"},{"location":"tr/unit-testing/#test-etmek","text":"package main import fmt func main () { fmt . Println ( Hello, world ) } Yukar\u0131daki kodu test etmeden \u00f6nce yan etkilerden ar\u0131nd\u0131rmal\u0131y\u0131z. Buradaki side-effect Println fonksiyonu. package main import fmt func Hello () string { return Hello, world } func main () { fmt . Println ( Hello ()) } \u015eimdi Hello fonksiyonunu i\u00e7in test yazal\u0131m. func TestHello ( t * testing . T ) { got := Hello () want := Hello, world if got != want { t . Errorf ( got %q want %q , got , want ) } } Go testlerini \u00e7al\u0131\u015ft\u0131rmak i\u00e7in ek ara\u00e7lara veya frameworklere ihtiyac\u0131m\u0131z yok. Sadece go test komutu ile yazd\u0131\u011f\u0131m\u0131z testleri \u00e7al\u0131\u015ft\u0131rabiliriz. Test yazman\u0131n belirli kurallar \u00e7er\u00e7evesinde fonksiyonlar yazmaktan fark\u0131 yoktur. Bu fonksiyonlar\u0131n test olarak kabul edilmesi i\u00e7in: xxx_test.go gibi bir dosya i\u00e7inde olmas\u0131 Fonksiyon isminin Test ile ba\u015flamas\u0131 Fonksiyonun yaln\u0131zca t *testing.T parametresini almas\u0131 gerekir.","title":"Test etmek"},{"location":"tr/unit-testing/#yeni-ozellikler-eklemek","text":"Test ba\u015far\u0131l\u0131 bir \u015fekilde \u00e7al\u0131\u015ft\u0131\u011f\u0131na g\u00f6re art\u0131k uygulamaya yeni \u00f6zellikler ekleyebiliriz. \u015eimdi Hello fonksiyonu parametre olarak bir isim als\u0131n ve o ismi selamlas\u0131n. Bunun i\u00e7in \u00f6ncellikle kodun yeni halini test eden ve ba\u015far\u0131s\u0131z olan bir test yazaca\u011f\u0131z. func TestHello ( t * testing . T ) { got := Hello ( Mehmet ) want := Hello, Mehmet if got != want { t . Errorf ( got %q want %q , got , want ) } } Testi ge\u00e7irecek kadar kod yazal\u0131m. func Hello ( name string ) string { return Hello, Mehmet } Yukar\u0131daki \u00f6rnekte amac\u0131m\u0131z\u0131n d\u0131\u015f\u0131nda bir kod yazarak testin ge\u00e7mesini sa\u011flad\u0131k. Bu \u00f6rnek her ne kadar abes dursada, bu t\u00fcr durumlar daha b\u00fcy\u00fck \u00f6l\u00e7ekli i\u015flerde ba\u015f\u0131m\u0131za gelebilir ve fark edilmedi\u011finde anla\u015f\u0131lmas\u0131 zor buglar ortaya \u00e7\u0131kartabilir. Ekledi\u011fimiz \u00f6zelli\u011fin d\u00fczg\u00fcn \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan emin olmak i\u00e7in bir test daha ekleyelim. func TestHello ( t * testing . T ) { got := Hello ( Mehmet ) want := Hello, Mehmet if got != want { t . Errorf ( got %q want %q , got , want ) } } func TestHelloWithAnotherName ( t * testing . T ) { got := Hello ( Ahmet ) want := Hello, Ahmet if got != want { t . Errorf ( got %q want %q , got , want ) } } \u015eimdi de testi ge\u00e7ecek kodu yazal\u0131m. func Hello ( name string ) string { return Hello, + name } Bu a\u015famada elimizde testleri ile birlikte \u00e7al\u0131\u015fan yeni \u00f6zelli\u011fi commit edebiliriz. Bu a\u015famada, TDD ya\u015fam d\u00f6ng\u00fcs\u00fc gere\u011fi kod refactor edilmeye \u00e7al\u0131\u015f\u0131l\u0131r. \"Hello, \" her durumda sabit oldu\u011fu i\u00e7in globalde tan\u0131mlayabiliriz. const englishHelloPrefix = Hello, func Hello ( name string ) string { return englishHelloPrefix + name } Refactor yap\u0131ld\u0131ktan sonra mutlaka testler yeniden \u00e7al\u0131\u015ft\u0131r\u0131lmal\u0131 ve kod davran\u0131\u015f\u0131n\u0131n de\u011fi\u015fmedi\u011finden emin olunmal\u0131d\u0131r. \u015eimdi uygulamam\u0131za bir \u00f6zellik daha ekleyelim. Bu kez Hello fonksiyonuna bo\u015f isim verilince \u00f6n tan\u0131ml\u0131 mesajla selamlas\u0131n. Tabiki \u00f6nce testini yaz\u0131yoruz. Ayn\u0131 kod par\u00e7as\u0131 i\u00e7in yaz\u0131lan testleri tek fonksiyon alt\u0131nda toplayabiliriz. t.Run yap\u0131s\u0131 sayesinde verdi\u011fimiz farkl\u0131 test mesajlar\u0131 ile birlikte testleri bir araya getirebiliriz. func TestHello ( t * testing . T ) { t . Run ( Say hello to a specific name , func ( t * testing . T ) { got := Hello ( Mehmet ) want := Hello, Mehmet if got != want { t . Errorf ( got %q want %q , got , want ) } }) t . Run ( Say Hello, Dude when an empty string is provided , func ( t * testing . T ) { got := Hello ( ) want := Hello, Dude if got != want { t . Errorf ( got %q want %q , got , want ) } }) } Refactoring sadece business logic i\u00e7eren kodlar i\u00e7in de\u011fildir. Test kodlar\u0131na da projede t\u0131pk\u0131 di\u011fer kodlar gibi yakla\u015f\u0131lmal\u0131d\u0131r. Bu a\u015famada testlerimizde tekrar eden k\u0131s\u0131mlar i\u00e7in bir fonksiyon yazabiliriz. func TestHello ( t * testing . T ) { assertCorrectMessage := func ( t * testing . T , got , want string ) { t . Helper () if got != want { t . Errorf ( got %q want %q , got , want ) } } t . Run ( Say hello to a specific name , func ( t * testing . T ) { got := Hello ( Mehmet ) want := Hello, Mehmet assertCorrectMessage ( t , got , want ) }) t . Run ( Say Hello, Dude when an empty string is provided , func ( t * testing . T ) { got := Hello ( ) want := Hello, Dude assertCorrectMessage ( t , got , want ) }) } \u015eimdi elimizde d\u00fczg\u00fcn bir \u015fekilde yaz\u0131lm\u0131\u015f hata veren bir test var. Uygulamaya testi ge\u00e7mek i\u00e7in yeterli kodu yazal\u0131m. const englishHelloPrefix = Hello, func Hello ( name string ) string { if name == { name = Dude } return englishHelloPrefix + name } B\u00f6ylece uygulamam\u0131za \u00f6nceki \u00f6zellikleri etkilemeden yeni bir \u00f6zellik eklemi\u015f olduk. Bu a\u015famada eski commiti amend edip, fonksiyonumuzu yeni versiyonu ile de\u011fi\u015ftirebiliriz.","title":"Yeni \u00d6zellikler Eklemek"},{"location":"tr/unit-testing/#gelistirme-disiplini","text":"Yeni \u00f6zelli\u011fi kullanan bir test yaz Kodun derlendi\u011finden emin ol Testi \u00e7al\u0131\u015ft\u0131r, hatay\u0131 g\u00f6zlemle Testi ge\u00e7irecek minimum kodu yaz Refactor Bu kadar ad\u0131m zahmetli ve paranoyak\u00e7a gelebilir fakat her ad\u0131mda kodun durumunu kontrol etmek olduk\u00e7a \u00f6nemlidir. Bu disipline sad\u0131k kalarak sadece amac\u0131na uygun testler yazmakla kalmay\u0131z ayn\u0131 zamanda otomatikle\u015ftirilmi\u015f testlerle s\u00fcrekli d\u00fczenlenen ve iyi \u015fekilde tasarlanan bir yaz\u0131l\u0131m geli\u015ftirmi\u015f oluruz. Testlerin ne i\u00e7in yaz\u0131ld\u0131\u011f\u0131n\u0131 anla\u015f\u0131l\u0131r bir \u015fekilde hata mesaj\u0131nda g\u00f6stermek \u00e7ok \u00f6nemlidir. Yaz\u0131l\u0131mc\u0131n\u0131n, testin neden hata verdi\u011fini anlayamamas\u0131 problemi \u00e7\u00f6zmeyi zorla\u015ft\u0131racakt\u0131r. Testlerin h\u0131zl\u0131 \u00e7al\u0131\u015fmas\u0131 ve kolay bir \u015fekilde \u00e7al\u0131\u015ft\u0131r\u0131labilmesi gerekir. Bu ak\u0131c\u0131 bir \u015fekilde kod yazmam\u0131z\u0131 sa\u011flayacakt\u0131r. Testsiz kod yazarak, uygulaman\u0131n ak\u0131\u015f\u0131n\u0131 ve olas\u0131 her durumunu kontrol etme i\u015fini kendinize y\u00fcklemi\u015f olursunuz. Bu da uzun d\u00f6nemde ciddi vakit kayb\u0131na yol a\u00e7acakt\u0131r.","title":"Geli\u015ftirme Disiplini"},{"location":"tr/unit-testing/#daha-fazla-ozellik","text":"Yeni iste\u011fe g\u00f6re uygulamam\u0131za dil deste\u011fi ekleyece\u011fiz. E\u011fer dil sistemimiz taraf\u0131ndan destekleniyorsa selamlama mesaj\u0131 verilen dilde sa\u011flanacak. Desteklenmiyorsa \u00f6n tan\u0131ml\u0131 olan \u0130ngilizce mesaj g\u00f6nderilecek. Ba\u015flang\u0131\u00e7 olarak Frans\u0131zca dil deste\u011fi i\u00e7in test yazal\u0131m. t . Run ( in French , func ( t * testing . T ) { got := Hello ( Lara Fabian , French ) want := Bonjour, Lara Fabian assertCorrectMessage ( t , got , want ) }) Bu haliyle Hello tek parametre ald\u0131\u011f\u0131 i\u00e7in compiler hata verecektir. Bu ad\u0131mda, hile yap\u0131p do\u011frudan kodu yazmaktan ka\u00e7\u0131nmal\u0131y\u0131z. Fonksiyona gerekli olan 2. parametreyi ekleyelim. func Hello ( name string , language string ) string { if name == { name = Dude } return englishHelloPrefix + name } Testleri \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda, yeni \u00f6zelli\u011fe g\u00f6re tasarlanmad\u0131\u011f\u0131 i\u00e7in eski testler hata verecektir. Eski testlere parametre olarak bo\u015f string vererek compiler hatas\u0131ndan kurtulal\u0131m. Bu durumda, sadece yeni ekledi\u011fimiz testin fail olmas\u0131 gerekir. \u015eimdi response bodyi Yeni bir if ekleyerek Frans\u0131zca i\u00e7in yazd\u0131\u011f\u0131m\u0131z testi ge\u00e7ebiliriz. func Hello ( name string , language string ) string { if name == { name = Dude } if language == French { return Bonjour, + name } return englishHelloPrefix + name } Bu haliyle b\u00fct\u00fcn testleri ba\u015far\u0131l\u0131 olmas\u0131 gerekiyor. \u015eimdi kodumuzu refactor edebiliriz. \u0130\u015fe, kod i\u00e7inde tan\u0131ml\u0131 stringlerden ba\u015flayabiliriz. Yap\u0131lan her de\u011fi\u015fiklikte testlerin ba\u015far\u0131l\u0131 oldu\u011funu kontrol etmeliyiz. const french = French const englishHelloPrefix = Hello, const frenchHelloPrefix = Bonjour, func Hello ( name string , language string ) string { if name == { name = Dude } if language == french { return frenchHelloPrefix + name } return englishHelloPrefix + name }","title":"Daha fazla \u00f6zellik"},{"location":"tr/unit-testing/#yeni-dil","text":"\u015eimdi Koreceye de destek verelim. Bunun i\u00e7in daha \u00f6nce yapt\u0131\u011f\u0131m\u0131z gibi: Korean yazd\u0131\u011f\u0131m\u0131zda \uc548\ub155 ile ba\u015flayan bir mesaj bekleyen test yazaca\u011f\u0131z Testi \u00e7al\u0131\u015ft\u0131r\u0131p hata alaca\u011f\u0131z ve hata mesaj\u0131n\u0131n d\u00fczg\u00fcn oldu\u011funa dikkat edece\u011fiz Kod \u00fczerinde testi ge\u00e7ecek minimum de\u011fi\u015fikli\u011fi yapaca\u011f\u0131z De\u011fi\u015fikliklerden sonra elimizde a\u015fa\u011f\u0131 yukar\u0131 b\u00f6yle bir kod olacak: func TestHello ( t * testing . T ) { assertCorrectMessage := func ( t * testing . T , got , want string ) { t . Helper () if got != want { t . Errorf ( got %q want %q , got , want ) } } t . Run ( Say hello to a specific name , func ( t * testing . T ) { got := Hello ( Mehmet , ) want := Hello, Mehmet assertCorrectMessage ( t , got , want ) }) t . Run ( Say Hello, Dude when an empty string is provided , func ( t * testing . T ) { got := Hello ( , ) want := Hello, Dude assertCorrectMessage ( t , got , want ) }) t . Run ( in French , func ( t * testing . T ) { got := Hello ( Lara Fabian , French ) want := Bonjour, Lara Fabian assertCorrectMessage ( t , got , want ) }) t . Run ( in Korean , func ( t * testing . T ) { got := Hello ( \uc138\uc0c1 , Korean ) want := \uc548\ub155 \uc138\uc0c1 assertCorrectMessage ( t , got , want ) }) } const french = French const korean = Korean const englishHelloPrefix = Hello, const frenchHelloPrefix = Bonjour, const koreanHelloPrefix = \uc548\ub155 func Hello ( name string , language string ) string { if name == { name = Dude } if language == french { return frenchHelloPrefix + name } if language == korean { return koreanHelloPrefix + name } return englishHelloPrefix + name } Yeni \u00f6zelli\u011fimizi, \u00e7al\u0131\u015fan testi ile ekledi\u011fimize g\u00f6re \u015fimdi kodumuzu refactor edebiliriz. func Hello ( name string , language string ) string { if name == { name = Dude } prefix := englishHelloPrefix switch language { case french : prefix = frenchHelloPrefix case korean : prefix = koreanHelloPrefix } return prefix + name }","title":"Yeni dil"},{"location":"tr/unit-testing/#real-world-example","text":"Ger\u00e7ek bir uygulamaya testlerin nas\u0131l yaz\u0131ld\u0131\u011f\u0131n\u0131 incelemek i\u00e7in https://randomuser.me/api/ APIsinden kullan\u0131c\u0131lar\u0131 \u00e7eken bir HTTP Client yazal\u0131m. UserClient yap\u0131s\u0131 ile, verilerin \u00e7ekilece\u011fi URLi, ka\u00e7 sayfa veri \u00e7ekece\u011fini ve her sayfada ne kadar veri alaca\u011f\u0131 ve de HTTP isteklerinin at\u0131laca\u011f\u0131 k\u00fct\u00fcphane belirliyoruz. type UserClient struct { BaseUrl string TaskCount , ResultPerPage int } uc := UserClient { BaseUrl : https://randomuser.me/api/ , TaskCount : 20 , ResultPerPage : 100 , requester : http . Client {}, } user , _ := uc . Get () users , _ := uc . FetchAll () fmt . Println ( len ( res )) // 2000","title":"Real World Example"},{"location":"tr/unit-testing/#mocking","text":"Unit testlerin \u00e7al\u0131\u015ft\u0131\u011f\u0131 ortamdan, d\u0131\u015f kaynaklardan ve k\u00fct\u00fcphanelerden ba\u011f\u0131ms\u0131z olmas\u0131 gerekir. Bu y\u00fczden http.Client ayn\u0131 davran\u0131\u015f\u0131 sergileyen fakat sahte veri d\u00f6nen ba\u015fka bir mod\u00fcl ile de\u011fi\u015ftirilmeli. Ortak davran\u0131\u015flara sahip mod\u00fcller geli\u015ftirmenin en kolay yolu ortak interface kullanmak. http.Clientin kullanaca\u011f\u0131m\u0131z methodlar\u0131na sahip Requester ad\u0131nda bir interface tan\u0131mlayal\u0131m. type Requester interface { Get ( url string ) ( resp * http . Response , err error ) } type UserClient struct { BaseUrl string TaskCount , ResultPerPage int requester Requester } func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { } func ( d * UserClient ) FetchAll () ( result [] map [ string ] interface {}, err error ) { } Testleri \u00e7al\u0131\u015ft\u0131r\u0131rken kullanaca\u011f\u0131m\u0131z, http.Client gibi Requesteri implement eden sahte bir client olu\u015ftural\u0131m ve FakeClient\u0131 kullanarak UserClient i\u00e7in bir test yazal\u0131m. type FakeClient struct { Body [] byte Error error } func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } func TestGetUser ( t * testing . T ) { userclient := UserClient {} t . Run ( get userclient returns err on bad response , func ( t * testing . T ) { userclient . requester = FakeClient { Error : errors . New ( Bad Request ), } _ , err := userclient . Get () if err == nil { t . Error ( Expected to get an error ) } }) } http.Clienti, sahtesi ile a\u015fa\u011f\u0131daki \u015fekilde de\u011fi\u015ftirdik. userclient . requester = FakeClient { Body : [] byte ( `{ status : ok }` ), } FakeClient ald\u0131\u011f\u0131 Body verisini Get methodu \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda bize http.Clientinkine benzer \u015fekilde d\u00f6necek. func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } Art\u0131k elimizde fail olan bir test var. Bu testi ge\u00e7ecek kodu yazabiliriz. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { err := erros . New ( Error ) return } \u015eimdi de response bodyi kontrol eden bir test yazal\u0131m. t . Run ( get userclient returns err if response body invalid , func ( t * testing . T ) { userclient . requester = FakeClient {} _ , err := userclient . Get () if err == nil { t . Error ( Expected to get an error ) } }) Art\u0131k testi ge\u00e7mek i\u00e7in kod yazabiliriz. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( %s?results=%d , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } } Son olarak ba\u015far\u0131l\u0131 response durumunu test edelim. t . Run ( get userclient returns unmarshalled response body on success , func ( t * testing . T ) { userclient . requester = FakeClient { Body : [] byte ( `{ status : ok }` ), } got , _ := userclient . Get () want := map [ string ] interface {}{ status : ok , } if ! reflect . DeepEqual ( got , want ) { t . Errorf ( got %q want %q , got , want ) } }) Art\u0131k byte JSONu d\u00fczg\u00fcnce parse eden bir kod yazmam\u0131z gerekiyor. func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( %s?results=%d , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } defer res . Body . Close () buf := new ( bytes . Buffer ) buf . ReadFrom ( res . Body ) newStr := buf . String () var data map [ string ] interface {} err = json . Unmarshal ([] byte ( newStr ), data ) response = data return }","title":"Mocking"},{"location":"tr/unit-testing/#table-test","text":"Kod tekrar\u0131n\u0131 azaltmak i\u00e7in table driven test y\u00f6ntemini kullanabiliriz. func TestFetchAll ( t * testing . T ) { testCases := [] struct { name string client * UserClient expected [] map [ string ] interface {} }{ { get userclient returns err on bad response , UserClient { ResultPerPage : 1 , TaskCount : 0 , requester : FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), }, }, [] map [ string ] interface {}{}, }, { get userclient returns err if response body invalid , UserClient { ResultPerPage : 0 , TaskCount : 1 , requester : FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), }, }, [] map [ string ] interface {}{}, }, { get userclient returns unmarshalled response body on success , UserClient { ResultPerPage : 0 , TaskCount : 1 , requester : FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), }, }, [] map [ string ] interface {}{}, }, } for _ , tt := range testCases { t . Run ( tt . name , func ( t * testing . T ) { got , _ := tt . client . FetchAll () if ! reflect . DeepEqual ( got , tt . expected ) { t . Errorf ( got %q want %q , got , tt . expected ) } }) } }","title":"Table Test"},{"location":"tr/unit-testing/#anti-patternler","text":"\u0130kinci S\u0131n\u0131f Vatanda\u015fl\u0131k D i\u011fer kodlar\u0131 yazarken uygulad\u0131\u011f\u0131m\u0131z yaz\u0131l\u0131m prensipleri test kodlar\u0131 i\u00e7in de ge\u00e7erli. Obsessive Coverage Test coverage\u0131n y\u00fcksek olmas\u0131, projenin b\u00fct\u00fcn durumlar\u0131n\u0131n test edildi\u011fini g\u00f6stermez. Bir projenin d\u00fczg\u00fcn test edildi\u011finin g\u00f6stergesi sadece coverage raporlar\u0131 de\u011fildir. Structural Inspection Projede structlar\u0131n, ve di\u011fer veri yap\u0131lar\u0131n\u0131n ald\u0131klar\u0131 de\u011ferleri de\u011fil methodlar\u0131 ve fonksiyonlar\u0131n davran\u0131\u015flar\u0131n\u0131 test etmeliyiz. God Object Test edilmesi zor, b\u00fcy\u00fck yap\u0131lar par\u00e7alanmal\u0131d\u0131r. E\u011fer test etti\u011fimiz kod \u00e7ok fazla mock kulland\u0131r\u0131yorsa bu God Objectin belirtisi olabilir. Mockery Testlerde a\u015f\u0131r\u0131 mock kullan\u0131m\u0131, uygulama davran\u0131\u015f\u0131n\u0131 de\u011fil mockerlar\u0131n de\u011ferlerini test etmemizle sonu\u00e7lan\u0131r. Instance Reuse Test edilen yap\u0131lar, \u00e7al\u0131\u015ft\u0131r\u0131lan her test i\u00e7in yeniden \u00fcretilmelidir. Local Hero Testler \u00e7al\u0131\u015ft\u0131\u011f\u0131 ortamdan ve makineden ba\u011f\u0131ms\u0131z olmal\u0131d\u0131r. Happy Path Testing Uygulamada sadece ba\u015far\u0131l\u0131 sonu\u00e7lar\u0131 de\u011fil, olas\u0131 b\u00fct\u00fcn durumlar\u0131 test etmeliyiz. K\u00f6t\u00fc \u0130simlendirme (S\u0131ral\u0131 \u0130simlendirme) Testlerin isimleri ve mesajlar\u0131 a\u00e7\u0131klay\u0131c\u0131 ve ay\u0131rt edici olmal\u0131d\u0131r. Yeni Test Yerine Assertion Ekleme Birime yeni \u00f6zellik eklendi\u011finde, veya bir k\u0131sm\u0131 de\u011fi\u015ftirildi\u011finde var olan bir teste ekstra bir kontrol eklenmemelidir. Sadece bu durumu yeni bir test yaz\u0131lmal\u0131d\u0131r. package main import ( bytes encoding/json fmt net/http ) type Requester interface { Get ( url string ) ( resp * http . Response , err error ) } type UserClient struct { BaseUrl string TaskCount , ResultPerPage int requester Requester } func ( d * UserClient ) Get () ( response map [ string ] interface {}, err error ) { url := fmt . Sprintf ( %s?results=%d , d . BaseUrl , d . ResultPerPage ) res , err := d . requester . Get ( url ) if err != nil { return nil , err } defer res . Body . Close () buf := new ( bytes . Buffer ) buf . ReadFrom ( res . Body ) newStr := buf . String () var data map [ string ] interface {} err = json . Unmarshal ([] byte ( newStr ), data ) response = data return } func ( d * UserClient ) FetchAll () ( result [] map [ string ] interface {}, err error ) { ch1 := make ( chan map [ string ] interface {}, 1 ) expectedCount := d . TaskCount * d . ResultPerPage result = [] map [ string ] interface {}{} if d . TaskCount == 0 || d . ResultPerPage == 0 { return } for i := 0 ; i d . TaskCount ; i ++ { go func ( ch chan map [ string ] interface {}) { response , err := d . Get () if err != nil { for j := 0 ; j d . ResultPerPage ; j ++ { ch - map [ string ] interface {}{} } } else { data := response [ results ].([] interface {}) for _ , datum := range data { ch - datum .( map [ string ] interface {}) } } }( ch1 ) } for data := range ch1 { result = append ( result , data ) if len ( result ) == expectedCount { close ( ch1 ) } } return result , nil } func main () { uc := UserClient { BaseUrl : https://randomuser.me/api/ , TaskCount : 20 , ResultPerPage : 100 , requester : http . Client {}, } res , _ := uc . FetchAll () fmt . Println ( len ( res )) } package main import ( bytes errors io/ioutil net/http reflect testing ) type FakeClient struct { Body [] byte Error error } func ( c * FakeClient ) Get ( url string ) ( resp * http . Response , err error ) { resp = http . Response { Body : ioutil . NopCloser ( bytes . NewBuffer ( c . Body )), } return resp , c . Error } func TestGetUser ( t * testing . T ) { userclient := UserClient {} t . Run ( get userclient returns err on bad response , func ( t * testing . T ) { userclient . requester = FakeClient { Error : errors . New ( Bad Request ), } _ , err := userclient . Get () if err == nil { t . Error ( Expected to get an error ) } }) t . Run ( get userclient returns err if response body invalid , func ( t * testing . T ) { userclient . requester = FakeClient {} _ , err := userclient . Get () if err == nil { t . Error ( Expected to get an error ) } }) t . Run ( get userclient returns unmarshalled response body on success , func ( t * testing . T ) { userclient . requester = FakeClient { Body : [] byte ( `{ status : ok }` ), } got , _ := userclient . Get () want := map [ string ] interface {}{ status : ok , } if ! reflect . DeepEqual ( got , want ) { t . Errorf ( got %q want %q , got , want ) } }) } func TestFetchAll ( t * testing . T ) { t . Run ( fetchall returns empty list if task count is 0 , func ( t * testing . T ) { userclient := UserClient { ResultPerPage : 1 , TaskCount : 0 , } userclient . requester = FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), } got , _ := userclient . FetchAll () want := [] map [ string ] interface {}{} if ! reflect . DeepEqual ( got , want ) { t . Errorf ( got %q want %q , got , want ) } }) t . Run ( fetchall returns empty list if per page is 0 , func ( t * testing . T ) { userclient := UserClient { ResultPerPage : 0 , TaskCount : 1 , } userclient . requester = FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), } got , _ := userclient . FetchAll () want := [] map [ string ] interface {}{} if ! reflect . DeepEqual ( got , want ) { t . Errorf ( got %q want %q , got , want ) } }) t . Run ( fetchall returns the same amount of records with item count , func ( t * testing . T ) { userclient := UserClient { TaskCount : 5 , ResultPerPage : 2 , } userclient . requester = FakeClient { Body : [] byte ( `{ results : [{ test : ok }]` ), } res , _ := userclient . FetchAll () got := len ( res ) want := 10 if got != want { t . Errorf ( got %d want %d , got , want ) } }) }","title":"Anti-Patternler"}]}